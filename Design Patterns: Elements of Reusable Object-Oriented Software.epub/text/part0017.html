<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Appendix A. Glossary</title>
    <link rel="stylesheet" type="application/vnd.adobe-page-template+xml" href="page-template.xpgt"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="../page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<p class="calibre1"><a id="app01"></a></p>
<div class="calibre5"></div><h2 class="calibre6" id="calibre_pb_0"><a id="page_359" class="calibre3"></a>Appendix A. Glossary</h2>
<p class="glossary"><a id="gloss01_001"></a><strong class="calibre4">abstract class</strong> A class whose primary purpose is to define an interface. An abstract class defers some or all of its implementation to subclasses. An abstract class cannot be instantiated.</p>
<p class="glossary"><a id="gloss01_002"></a><strong class="calibre4">abstract coupling</strong> Given a class <em class="calibre7">A</em> that maintains a reference to an abstract class <em class="calibre7">B,</em> class <em class="calibre7">A</em> is said to be <em class="calibre7">abstractly coupled</em> to <em class="calibre7">B.</em> We call this abstract coupling because <em class="calibre7">A</em> refers to a <em class="calibre7">type</em> of object, not a concrete object.</p>
<p class="glossary"><a id="gloss01_003"></a><strong class="calibre4">abstract operation</strong> An operation that declares a signature but doesn’t implement it. In C++, an abstract operation corresponds to a <strong class="calibre4">pure virtual member function.</strong></p>
<p class="glossary"><a id="gloss01_004"></a><strong class="calibre4">acquaintance relationship</strong> A class that refers to another class has an <em class="calibre7">acquaintance</em> with that class.</p>
<p class="glossary"><a id="gloss01_005"></a><strong class="calibre4">aggregate object</strong> An object that’s composed of subobjects. The subobjects are called the aggregate’s <strong class="calibre4">parts,</strong> and the aggregate is responsible for them.</p>
<p class="glossary"><a id="gloss01_006"></a><strong class="calibre4">aggregation relationship</strong> The relationship of an aggregate object to its parts. A class defines this relationship for its instances (e.g., aggregate objects).</p>
<p class="glossary"><a id="gloss01_007"></a><strong class="calibre4">black-box reuse</strong> A style of reuse based on object composition. Composed objects reveal no internal details to each other and are thus analogous to “black boxes.”</p>
<p class="glossary"><a id="gloss01_008"></a><strong class="calibre4">class</strong> A class defines an object’s interface and implementation. It specifies the object’s internal representation and defines the operations the object can perform.</p>
<p class="glossary"><a id="gloss01_009"></a><strong class="calibre4">class diagram</strong> A diagram that depicts classes, their internal structure and operations, and the static relationships between them.</p>
<p class="glossary"><a id="gloss01_010"></a><strong class="calibre4">class operation</strong> An operation targeted to a class and not to an individual object. In C++, class operations are are called <strong class="calibre4">static member functions.</strong></p>
<p class="glossary"><a id="gloss01_011"></a><strong class="calibre4">concrete class</strong> A class having no abstract operations. It can be instantiated.</p>
<p class="glossary"><a id="gloss01_012"></a><a id="page_360"></a><strong class="calibre4">constructor</strong> In C++, an operation that is automatically invoked to initialize new instances.</p>
<p class="glossary"><a id="gloss01_013"></a><strong class="calibre4">coupling</strong> The degree to which software components depend on each other.</p>
<p class="glossary"><a id="gloss01_014"></a><strong class="calibre4">delegation</strong> An implementation mechanism in which an object forwards or <em class="calibre7">delegates</em> a request to another object. The delegate carries out the request on behalf of the original object.</p>
<p class="glossary"><a id="gloss01_015"></a><strong class="calibre4">design pattern</strong> A design pattern systematically names, motivates, and explains a general design that addresses a recurring design problem in object-oriented systems. It describes the problem, the solution, when to apply the solution, and its consequences. It also gives implementation hints and examples. The solution is a general arrangement of objects and classes that solve the problem. The solution is customized and implemented to solve the problem in a particular context.</p>
<p class="glossary"><a id="gloss01_016"></a><strong class="calibre4">destructor</strong> In C++, an operation that is automatically invoked to finalize an object that is about to be deleted.</p>
<p class="glossary"><a id="gloss01_017"></a><strong class="calibre4">dynamic binding</strong> The run-time association of a request to an object and one of its operations. In C++, only virtual functions are dynamically bound.</p>
<p class="glossary"><a id="gloss01_018"></a><strong class="calibre4">encapsulation</strong> The result of hiding a representation and implementation in an object. The representation is not visible and cannot be accessed directly from outside the object. Operations are the only way to access and modify an object’s representation.</p>
<p class="glossary"><a id="gloss01_019"></a><strong class="calibre4">framework</strong> A set of cooperating classes that makes up a reusable design for a specific class of software. A framework provides architectural guidance by partitioning the design into abstract classes and defining their responsibilities and collaborations. A developer customizes the framework to a particular application by subclassing and composing instances of framework classes.</p>
<p class="glossary"><a id="gloss01_020"></a><strong class="calibre4">friend class</strong> In C++, a class that has the same access rights to the operations and data of a class as that class itself.</p>
<p class="glossary"><a id="gloss01_021"></a><strong class="calibre4">inheritance</strong> A relationship that defines one entity in terms of another. <strong class="calibre4">Class inheritance</strong> defines a new class in terms of one or more parent classes. The new class inherits its interface and implementation from its parents. The new class is called a <strong class="calibre4">subclass</strong> or (in C++) a <strong class="calibre4">derived class</strong>. Class inheritance combines <strong class="calibre4">interface inheritance</strong> and <strong class="calibre4">implementation inheritance</strong>. Interface inheritance defines a new interface in terms of one or more existing interfaces. Implementation inheritance defines a new implementation in terms of one or more existing implementations.</p>
<p class="glossary"><a id="gloss01_022"></a><strong class="calibre4">instance variable</strong> A piece of data that defines part of an object’s representation. C++ uses the term <strong class="calibre4">data member</strong>.</p>
<p class="glossary"><a id="gloss01_023"></a><strong class="calibre4">interaction diagram</strong> A diagram that shows the flow of requests between objects.</p>
<p class="glossary"><a id="gloss01_024"></a><a id="page_361"></a><strong class="calibre4">interface</strong> The set of all signatures defined by an object’s operations. The interface describes the set of requests to which an object can respond.</p>
<p class="glossary"><a id="gloss01_025"></a><strong class="calibre4">metaclass</strong> Classes are objects in Smalltalk. A metaclass is the class of a class object.</p>
<p class="glossary"><a id="gloss01_026"></a><strong class="calibre4">mixin class</strong> A class designed to be combined with other classes through inheritance. Mixin classes are usually abstract.</p>
<p class="glossary"><a id="gloss01_027"></a><strong class="calibre4">object</strong> A run-time entity that packages both data and the procedures that operate on that data.</p>
<p class="glossary"><a id="gloss01_028"></a><strong class="calibre4">object composition</strong> Assembling or <em class="calibre7">composing</em> objects to get more complex behavior.</p>
<p class="glossary"><a id="gloss01_029"></a><strong class="calibre4">object diagram</strong> A diagram that depicts a particular object structure at run-time.</p>
<p class="glossary"><a id="gloss01_030"></a><strong class="calibre4">object reference</strong> A value that identifies another object.</p>
<p class="glossary"><a id="gloss01_031"></a><strong class="calibre4">operation</strong> An object’s data can be manipulated only by its operations. An object performs an operation when it receives a request. In C++, operations are called <strong class="calibre4">member functions.</strong> Smalltalk uses the term <strong class="calibre4">method.</strong></p>
<p class="glossary"><a id="gloss01_032"></a><strong class="calibre4">overriding</strong> Redefining an operation (inherited from a parent class) in a subclass.</p>
<p class="glossary"><a id="gloss01_033"></a><strong class="calibre4">parameterized type</strong> A type that leaves some constituent types unspecified. The unspecified types are supplied as parameters at the point of use. In C++, parameterized types are called <strong class="calibre4">templates.</strong></p>
<p class="glossary"><a id="gloss01_034"></a><strong class="calibre4">parent class</strong> The class from which another class inherits. Synonyms are <strong class="calibre4">superclass</strong> (Smalltalk), <strong class="calibre4">base class</strong> (C++), and <strong class="calibre4">ancestor class.</strong></p>
<p class="glossary"><a id="gloss01_035"></a><strong class="calibre4">polymorphism</strong> The ability to substitute objects of matching interface for one another at run-time.</p>
<p class="glossary"><a id="gloss01_036"></a><strong class="calibre4">private inheritance</strong> In C++, a class inherited solely for its implementation.</p>
<p class="glossary"><a id="gloss01_037"></a><strong class="calibre4">protocol</strong> Extends the concept of an interface to include the allowable sequences of requests.</p>
<p class="glossary"><a id="gloss01_038"></a><strong class="calibre4">receiver</strong> The target object of a request.</p>
<p class="glossary"><a id="gloss01_039"></a><strong class="calibre4">request</strong> An object performs an operation when it receives a corresponding request from another object. A common synonym for request is <strong class="calibre4">message.</strong></p>
<p class="glossary"><a id="gloss01_040"></a><strong class="calibre4">signature</strong> An operation’s signature defines its name, parameters, and return value.</p>
<p class="glossary"><a id="gloss01_041"></a><strong class="calibre4">subclass</strong> A class that inherits from another class. In C++, a subclass is called a <strong class="calibre4">derived class.</strong></p>
<p class="glossary"><a id="gloss01_042"></a><strong class="calibre4">subsystem</strong> An independent group of classes that collaborate to fulfill a set of responsibilities.</p>
<p class="glossary"><a id="gloss01_043"></a><a id="page_362"></a><strong class="calibre4">subtype</strong> A type is a subtype of another if its interface contains the interface of the other type.</p>
<p class="glossary"><a id="gloss01_044"></a><strong class="calibre4">supertype</strong> The parent type from which a type inherits.</p>
<p class="glossary"><a id="gloss01_045"></a><strong class="calibre4">toolkit</strong> A collection of classes that provides useful functionality but does not define the design of an application.</p>
<p class="glossary"><a id="gloss01_046"></a><strong class="calibre4">type</strong> The name of a particular interface.</p>
<p class="glossary"><a id="gloss01_047"></a><strong class="calibre4">white-box reuse</strong> A style of reuse based on class inheritance. A subclass reuses the interface and implementation of its parent class, but it may have access to otherwise private aspects of its parent.</p>
</body></html>
