<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Chapter 5. Behavioral Patterns</title>
    <link href="page-template.xpgt" type="application/vnd.adobe-page-template+xml" rel="stylesheet"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="../page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<p class="calibre1"><a id="ch05"></a></p>
<div class="calibre5"></div><div class="calibre14" id="calibre_pb_0"></div><h2 class="calibre6" id="calibre_pb_1"><a id="page_221" class="calibre3"></a>Chapter 5. Behavioral Patterns</h2>
<p class="calibre1">Behavioral patterns are concerned with algorithms and the assignment of responsibilities between objects. Behavioral patterns describe not just patterns of objects or classes but also the patterns of communication between them. These patterns characterize complex control flow that’s difficult to follow at run-time. They shift your focus away from flow of control to let you concentrate just on the way objects are interconnected.</p>
<p class="calibre1">Behavioral class patterns use inheritance to distribute behavior between classes. This chapter includes two such patterns. Template Method (<a href="part0015.html#page_325">325</a>) is the simpler and more common of the two. A template method is an abstract definition of an algorithm. It defines the algorithm step by step. Each step invokes either an abstract operation or a primitive operation. A subclass fleshes out the algorithm by defining the abstract operations. The other behavioral class pattern is Interpreter (<a href="part0015.html#page_243">243</a>), which represents a grammar as a class hierarchy and implements an interpreter as an operation on instances of these classes.</p>
<p class="calibre1">Behavioral object patterns use object composition rather than inheritance. Some describe how a group of peer objects cooperate to perform a task that no single object can carry out by itself. An important issue here is how peer objects know about each other. Peers could maintain explicit references to each other, but that would increase their coupling. In the extreme, every object would know about every other. The Mediator (<a href="part0015.html#page_273">273</a>) pattern avoids this by introducing a mediator object between peers. The mediator provides the indirection needed for loose coupling.</p>
<p class="calibre1">Chain of Responsibility (<a href="part0015.html#page_223">223</a>) provides even looser coupling. It lets you send requests to an object implicitly through a chain of candidate objects. Any candidate may fulfill the request depending on run-time conditions. The number of candidates is open-ended, and you can select which candidates participate in the chain at run-time.</p>
<p class="calibre1">The Observer (<a href="part0015.html#page_293">293</a>) pattern defines and maintains a dependency between objects. The classic example of Observer is in Smalltalk Model/View/Controller, where all views of the model are notified whenever the model’s state changes.</p>
<p class="calibre1"><a id="page_222"></a>Other behavioral object patterns are concerned with encapsulating behavior in an object and delegating requests to it. The Strategy (<a href="part0015.html#page_315">315</a>) pattern encapsulates an algorithm in an object. Strategy makes it easy to specify and change the algorithm an object uses. The Command (<a href="part0015.html#page_233">233</a>) pattern encapsulates a request in an object so that it can be passed as a parameter, stored on a history list, or manipulated in other ways. The State (<a href="part0015.html#page_305">305</a>) pattern encapsulates the states of an object so that the object can change its behavior when its state object changes. Visitor (<a href="part0015.html#page_331">331</a>) encapsulates behavior that would otherwise be distributed across classes, and Iterator (<a href="part0015.html#page_257">257</a>) abstracts the way you access and traverse objects in an aggregate.</p>
<p class="calibre1"><a id="ch05sec1lev1"></a></p>
<h3 class="calibre2"><a id="page_223" class="calibre3"></a>Object Behavioral: Chain of Responsibility</h3>
<p class="calibre1"><a id="ch05sec2lev1"></a></p>
<h4 class="calibre15">Intent</h4>
<p class="calibre1">Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it.</p>
<p class="calibre1"><a id="ch05sec2lev2"></a></p>
<h4 class="calibre15">Motivation</h4>
<p class="calibre1">Consider a context-sensitive help facility for a graphical user interface. The user can obtain help information on any part of the interface just by clicking on it. The help that’s provided depends on the part of the interface that’s selected and its context; for example, a button widget in a dialog box might have different help information than a similar button in the main window. If no specific help information exists for that part of the interface, then the help system should display a more general help message about the immediate context—the dialog box as a whole, for example.</p>
<p class="calibre1">Hence it’s natural to organize help information according to its generality—from the most specific to the most general. Furthermore, it’s clear that a help request is handled by one of several user interface objects; which one depends on the context and how specific the available help is.</p>
<p class="calibre1">The problem here is that the object that ultimately <em class="calibre7">provides</em> the help isn’t known explicitly to the object (e.g., the button) that <em class="calibre7">initiates</em> the help request. What we need is a way to decouple the button that initiates the help request from the objects that might provide help information. The Chain of Responsibility pattern defines how that happens.</p>
<p class="calibre1">The idea of this pattern is to decouple senders and receivers by giving multiple objects a chance to handle a request. The request gets passed along a chain of objects until one of them handles it.</p>
<p class="image"><img src="../images/00239.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1"><a id="page_224"></a>The first object in the chain receives the request and either handles it or forwards it to the next candidate on the chain, which does likewise. The object that made the request has no explicit knowledge of who will handle it—we say the request has an <strong class="calibre4">implicit receiver</strong>.</p>
<p class="calibre1">Let’s assume the user clicks for help on a button widget marked “Print.” The button is contained in an instance of PrintDialog, which knows the application object it belongs to (see preceding object diagram). The following interaction diagram illustrates how the help request gets forwarded along the chain:</p>
<p class="image"><img src="../images/00240.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">In this case, neither aPrintButton nor aPrintDialog handles the request; it stops at anApplication, which can handle it or ignore it. The client that issued the request has no direct reference to the object that ultimately fulfills it.</p>
<p class="calibre1">To forward the request along the chain, and to ensure receivers remain implicit, each object on the chain shares a common interface for handling requests and for accessing its <strong class="calibre4">successor</strong> on the chain. For example, the help system might define a HelpHandler class with a corresponding HandleHelp operation. HelpHandler can be the parent class for candidate object classes, or it can be defined as a mixin class. Then classes that want to handle help requests can make HelpHandler a parent:</p>
<p class="image"><img src="../images/00241.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1"><a id="page_225"></a>The Button, Dialog, and Application classes use HelpHandler operations to handle help requests. HelpHandler’s HandleHelp operation forwards the request to the successor by default. Subclasses can override this operation to provide help under the right circumstances; otherwise they can use the default implementation to forward the request.</p>
<p class="calibre1"><a id="ch05sec2lev3"></a></p>
<h4 class="calibre15">Applicability</h4>
<p class="calibre1">Use Chain of Responsibility when</p>
<p class="indenthangingB1">• more than one object may handle a request, and the handler isn’t known <em class="calibre7">a priori.</em> The handler should be ascertained automatically.</p>
<p class="indenthangingB1">• you want to issue a request to one of several objects without specifying the receiver explicitly.</p>
<p class="indenthangingB1">• the set of objects that can handle a request should be specified dynamically.</p>
<p class="calibre1"><a id="ch05sec2lev4"></a></p>
<h4 class="calibre15">Structure</h4>
<p class="image"><img src="../images/00242.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">A typical object structure might look like this:</p>
<p class="image"><img src="../images/00243.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1"><a id="ch05sec2lev5"></a></p>
<h4 class="calibre15">Participants</h4>
<p class="indenthangingB1">• <strong class="calibre4">Handler</strong> (HelpHandler)</p>
<p class="indenthangingB2">– defines an interface for handling requests.</p>
<p class="indenthangingB2">– (optional) implements the successor link.</p>
<p class="indenthangingB1"><a id="page_226"></a>• <strong class="calibre4">ConcreteHandler</strong> (PrintButton, PrintDialog)</p>
<p class="indenthangingB2">– handles requests it is responsible for.</p>
<p class="indenthangingB2">– can access its successor.</p>
<p class="indenthangingB2">– if the ConcreteHandler can handle the request, it does so; otherwise it forwards the request to its successor.</p>
<p class="indenthangingB1">• <strong class="calibre4">Client</strong></p>
<p class="indenthangingB2">– initiates the request to a ConcreteHandler object on the chain.</p>
<p class="calibre1"><a id="ch05sec2lev6"></a></p>
<h4 class="calibre15">Collaborations</h4>
<p class="indenthangingB1">• When a client issues a request, the request propagates along the chain until a ConcreteHandler object takes responsibility for handling it.</p>
<p class="calibre1"><a id="ch05sec2lev7"></a></p>
<h4 class="calibre15">Consequences</h4>
<p class="calibre1">Chain of Responsibility has the following benefits and liabilities:</p>
<p class="indenthangingN">1. <em class="calibre7">Reduced coupling.</em> The pattern frees an object from knowing which other object handles a request. An object only has to know that a request will be handled “appropriately.” Both the receiver and the sender have no explicit knowledge of each other, and an object in the chain doesn’t have to know about the chain’s structure.</p>
<p class="indentpara">As a result, Chain of Responsibility can simplify object interconnections. Instead of objects maintaining references to all candidate receivers, they keep a single reference to their successor.</p>
<p class="indenthangingN">2. <em class="calibre7">Added flexibility in assigning responsibilities to objects.</em> Chain of Responsibility gives you added flexibility in distributing responsibilities among objects. You can add or change responsibilities for handling a request by adding to or otherwise changing the chain at run-time. You can combine this with subclassing to specialize handlers statically.</p>
<p class="indenthangingN">3. <em class="calibre7">Receipt isn’t guaranteed.</em> Since a request has no explicit receiver, there’s no <em class="calibre7">guarantee</em> it’ll be handled—the request can fall off the end of the chain without ever being handled. A request can also go unhandled when the chain is not configured properly.</p>
<p class="calibre1"><a id="ch05sec2lev8"></a></p>
<h4 class="calibre15">Implementation</h4>
<p class="calibre1">Here are implementation issues to consider in Chain of Responsibility:</p>
<p class="indenthangingN">1. <em class="calibre7">Implementing the successor chain.</em> There are two possible ways to implement the successor chain:</p>
<p class="indenthangingN1">(a) Define new links (usually in the Handler, but ConcreteHandlers could define them instead).</p>
<p class="indenthangingN1"><a id="page_227"></a>(b) Use existing links.</p>
<p class="indentpara">Our examples so far define new links, but often you can use existing object references to form the successor chain. For example, parent references in a part-whole hierarchy can define a part’s successor. A widget structure might already have such links. Composite (<a href="part0014.html#page_163">163</a>) discusses parent references in more detail.</p>
<p class="indentpara">Using existing links works well when the links support the chain you need. It saves you from defining links explicitly, and it saves space. But if the structure doesn’t reflect the chain of responsibility your application requires, then you’ll have to define redundant links.</p>
<p class="indenthangingN">2. <em class="calibre7">Connecting successors.</em> If there are no preexisting references for defining a chain, then you’ll have to introduce them yourself. In that case, the Handler not only defines the interface for the requests but usually maintains the successor as well. That lets the handler provide a default implementation of HandleRequest that forwards the request to the successor (if any). If a ConcreteHandler subclass isn’t interested in the request, it doesn’t have to override the forwarding operation, since its default implementation forwards unconditionally.</p>
<p class="indentpara">Here’s a HelpHandler base class that maintains a successor link:</p>
<p class="programlisting2"><img src="../images/00244.jpeg" alt="image" class="calibre11"/></p>
<p class="indenthangingN">3. <em class="calibre7">Representing requests.</em> Different options are available for representing requests. In the simplest form, the request is a hard-coded operation invocation, as in the case of HandleHelp. This is convenient and safe, but you can forward only the fixed set of requests that the Handler class defines.</p>
<p class="indentpara">An alternative is to use a single handler function that takes a request code (e.g., an integer constant or a string) as parameter. This supports an open-ended set of requests. The only requirement is that the sender and receiver agree on how the request should be encoded.</p>
<p class="indentpara">This approach is more flexible, but it requires conditional statements for dispatching the request based on its code. Moreover, there’s no type-safe way to pass parameters, so they must be packed and unpacked manually. Obviously this is less safe than invoking an operation directly.</p>
<p class="indentpara"><a id="page_228"></a>To address the parameter-passing problem, we can use separate request <em class="calibre7">objects</em> that bundle request parameters. A <code class="calibre13">Request</code> class can represent requests explicitly, and new kinds of requests can be defined by subclassing. Subclasses can define different parameters. Handlers must know the kind of request (that is, which <code class="calibre13">Request</code> subclass they’re using) to access these parameters.</p>
<p class="indentpara">To identify the request, <code class="calibre13">Request</code> can define an accessor function that returns an identifier for the class. Alternatively, the receiver can use run-time type information if the implementation languages supports it.</p>
<p class="indentpara">Here is a sketch of a dispatch function that uses request objects to identify requests. A <code class="calibre13">GetKind</code> operation defined in the base <code class="calibre13">Request</code> class identifies the kind of request:</p>
<p class="programlisting2"><img src="../images/00245.jpeg" alt="image" class="calibre11"/></p>
<p class="indentpara">Subclasses can extend the dispatch by overriding <code class="calibre13">HandleRequest</code>. The subclass handles only the requests in which it’s interested; other requests are forwarded to the parent class. In this way, subclasses effectively extend (rather than override) the <code class="calibre13">HandleRequest</code> operation. For example, here’s how an <code class="calibre13">ExtendedHandler</code> subclass extends <code class="calibre13">Handler</code>’s version of <code class="calibre13">HandleRequest</code>:</p>
<p class="programlisting2"><img src="../images/00246.jpeg" alt="image" class="calibre11"/></p>
<p class="indenthangingN"><a id="page_229"></a>4. <em class="calibre7">Automatic forwarding in Smalltalk.</em> You can use the <code class="calibre13">doesNotUnderstand</code> mechanism in Smalltalk to forward requests. Messages that have no corresponding methods are trapped in the implementation of <code class="calibre13">doesNotUnderstand</code>, which can be overridden to forward the message to an object’s successor. Thus it isn’t necessary to implement forwarding manually; the class handles only the request in which it’s interested, and it relies on <code class="calibre13">doesNotUnderstand</code> to forward all others.</p>
<p class="calibre1"><a id="ch05sec2lev9"></a></p>
<h4 class="calibre15">Sample Code</h4>
<p class="calibre1">The following example illustrates how a chain of responsibility can handle requests for an on-line help system like the one described earlier. The help request is an explicit operation. We’ll use existing parent references in the widget hierarchy to propagate requests between widgets in the chain, and we’ll define a reference in the Handler class to propagate help requests between nonwidgets in the chain.</p>
<p class="calibre1">The <code class="calibre13">HelpHandler</code> class defines the interface for handling help requests. It maintains a help topic (which is empty by default) and keeps a reference to its successor on the chain of help handlers. The key operation is <code class="calibre13">HandleHelp</code>, which subclasses override. <code class="calibre13">HasHelp</code> is a convenience operation for checking whether there is an associated help topic.</p>
<p class="programlisting"><img src="../images/00247.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1"><a id="page_230"></a>All widgets are subclasses of the <code class="calibre13">Widget</code> abstract class. <code class="calibre13">Widget</code> is a subclass of <code class="calibre13">HelpHandler</code>, since all user interface elements can have help associated with them. (We could have used a mixin-based implementation just as well.)</p>
<p class="programlisting"><img src="../images/00248.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">In our example, a button is the first handler on the chain. The <code class="calibre13">Button</code> class is a subclass of <code class="calibre13">Widget</code>. The <code class="calibre13">Button</code> constructor takes two parameters: a reference to its enclosing widget and the help topic.</p>
<p class="programlisting"><img src="../images/00249.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1"><code class="calibre13">Button</code>’s version of <code class="calibre13">HandleHelp</code> first tests to see if there is a help topic for buttons. If the developer hasn’t defined one, then the request gets forwarded to the successor using the <code class="calibre13">HandleHelp</code> operation in <code class="calibre13">HelpHandler</code>. If there <em class="calibre7">is</em> a help topic, then the button displays it, and the search ends.</p>
<p class="programlisting"><img src="../images/00250.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1"><code class="calibre13">Dialog</code> implements a similar scheme, except that its successor is not a widget but <em class="calibre7">any</em> help handler. In our application this successor will be an instance of <code class="calibre13">Application.</code></p>
<p class="programlisting"><a id="page_231"></a><img src="../images/00251.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">At the end of the chain is an instance of <code class="calibre13">Application</code>. The application is not a widget, so <code class="calibre13">Application</code> is subclassed directly from <code class="calibre13">HelpHandler</code>. When a help request propagates to this level, the application can supply information on the application in general, or it can offer a list of different help topics:</p>
<p class="programlisting"><img src="../images/00252.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">The following code creates and connects these objects. Here the dialog concerns printing, and so the objects have printing-related topics assigned.</p>
<p class="programlisting"><img src="../images/00253.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">We can invoke the help request by calling <code class="calibre13">HandleHelp</code> on any object on the chain. To start the search at the button object, just call <code class="calibre13">HandleHelp</code> on it:</p>
<p class="programlisting"><a id="page_232"></a>button-&gt;HandleHelp();</p>
<p class="calibre1">In this case, the button will handle the request immediately. Note that any <code class="calibre13">HelpHandler</code> class could be made the successor of <code class="calibre13">Dialog</code>. Moreover, its successor could be changed dynamically. So no matter where a dialog is used, you’ll get the proper context-dependent help information for it.</p>
<p class="calibre1"><a id="ch05sec2lev10"></a></p>
<h4 class="calibre15">Known Uses</h4>
<p class="calibre1">Several class libraries use the Chain of Responsibility pattern to handle user events. They use different names for the Handler class, but the idea is the same: When the user clicks the mouse or presses a key, an event gets generated and passed along the chain. MacApp <a href="part0020.html#bib01_004">[App89]</a> and ET++ <a href="part0020.html#bib01_089">[WGM88]</a> call it “Event-Handler,” Symantec’s TCL library <a href="part0020.html#bib01_082">[Sym93b]</a> calls it “Bureaucrat,” and NeXT’s AppKit <a href="part0020.html#bib01_001">[Add94]</a> uses the name “Responder.”</p>
<p class="calibre1">The Unidraw framework for graphical editors defines Command objects that encapsulate requests to Component and Component View objects <a href="part0020.html#bib01_086">[VL90]</a>. Commands are requests in the sense that a component or component view may interpret a command to perform an operation. This corresponds to the “requests as objects” approach described in Implementation. Components and component views may be structured hierarchically. A component or a component view may forward command interpretation to its parent, which may in turn forward it to its parent, and so on, thereby forming a chain of responsibility.</p>
<p class="calibre1">ET++ uses Chain of Responsibility to handle graphical update. A graphical object calls the InvalidateRect operation whenever it must update a part of its appearance. A graphical object can’t handle InvalidateRect by itself, because it doesn’t know enough about its context. For example, a graphical object can be enclosed in objects like Scrollers or Zoomers that transform its coordinate system. That means the object might be scrolled or zoomed so that it’s partially out of view. Therefore the default implementation of InvalidateRect forwards the request to the enclosing container object. The last object in the forwarding chain is a Window instance. By the time Window receives the request, the invalidation rectangle is guaranteed to be transformed properly. The Window handles InvalidateRect by notifying the window system interface and requesting an update.</p>
<p class="calibre1"><a id="ch05sec2lev11"></a></p>
<h4 class="calibre15">Related Patterns</h4>
<p class="calibre1">Chain of Responsibility is often applied in conjunction with Composite (<a href="part0014.html#page_163">163</a>). There, a component’s parent can act as its successor.</p>
<p class="calibre1"><a id="ch05sec1lev2"></a></p>
<h3 class="calibre2"><a id="page_233" class="calibre3"></a>Object Behavioral: Command</h3>
<p class="calibre1"><a id="ch05sec2lev12"></a></p>
<h4 class="calibre15">Intent</h4>
<p class="calibre1">Encapsulate a request as an object, thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations.</p>
<p class="calibre1"><a id="ch05sec2lev13"></a></p>
<h4 class="calibre15">Also Known As</h4>
<p class="calibre1">Action, Transaction</p>
<p class="calibre1"><a id="ch05sec2lev14"></a></p>
<h4 class="calibre15">Motivation</h4>
<p class="calibre1">Sometimes it’s necessary to issue requests to objects without knowing anything about the operation being requested or the receiver of the request. For example, user interface toolkits include objects like buttons and menus that carry out a request in response to user input. But the toolkit can’t implement the request explicitly in the button or menu, because only applications that use the toolkit know what should be done on which object. As toolkit designers we have no way of knowing the receiver of the request or the operations that will carry it out.</p>
<p class="calibre1">The Command pattern lets toolkit objects make requests of unspecified application objects by turning the request itself into an object. This object can be stored and passed around like other objects. The key to this pattern is an abstract Command class, which declares an interface for executing operations. In the simplest form this interface includes an abstract Execute operation. Concrete Command subclasses specify a receiver-action pair by storing the receiver as an instance variable and by implementing Execute to invoke the request. The receiver has the knowledge required to carry out the request.</p>
<p class="image"><img src="../images/00254.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">Menus can be implemented easily with Command objects. Each choice in a Menu is an instance of a Menultem class. An Application class creates these menus and <a id="page_234"></a>their menu items along with the rest of the user interface. The Application class also keeps track of Document objects that a user has opened.</p>
<p class="calibre1">The application configures each Menultem with an instance of a concrete Command subclass. When the user selects a Menultem, the Menultem calls Execute on its command, and Execute carries out the operation. Menultems don’t know which subclass of Command they use. Command subclasses store the receiver of the request and invoke one or more operations on the receiver.</p>
<p class="calibre1">For example, PasteCommand supports pasting text from the clipboard into a Document. PasteCommand’s receiver is the Document object it is supplied upon instantiation. The Execute operation invokes Paste on the receiving Document.</p>
<p class="image"><img src="../images/00255.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">OpenCommand’s Execute operation is different: it prompts the user for a document name, creates a corresponding Document object, adds the document to the receiving application, and opens the document.</p>
<p class="image"><img src="../images/00256.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">Sometimes a Menultem needs to execute a <em class="calibre7">sequence</em> of commands. For example, a Menultem for centering a page at normal size could be constructed from a CenterDocumentCommand object and a NormalSizeCommand object. Because it’s common to string commands together in this way, we can define a MacroCommand class to allow a Menultem to execute an open-ended number of commands.</p>
<p class="calibre1"><a id="page_235"></a>MacroCommand is a concrete Command subclass that simply executes a sequence of Commands. MacroCommand has no explicit receiver, because the commands it sequences define their own receiver.</p>
<p class="image"><img src="../images/00257.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">In each of these examples, notice how the Command pattern decouples the object that invokes the operation from the one having the knowledge to perform it. This gives us a lot of flexibility in designing our user interface. An application can provide both a menu and a push button interface to a feature just by making the menu and the push button share an instance of the same concrete Command subclass. We can replace commands dynamically, which would be useful for implementing context-sensitive menus. We can also support command scripting by composing commands into larger ones. All of this is possible because the object that issues a request only needs to know how to issue it; it doesn’t need to know how the request will be carried out.</p>
<p class="calibre1"><a id="ch05sec2lev15"></a></p>
<h4 class="calibre15">Applicability</h4>
<p class="calibre1">Use the Command pattern when you want to</p>
<p class="indenthangingB1">• parameterize objects by an action to perform, as Menultem objects did above. You can express such parameterization in a procedural language with a <strong class="calibre4">callback</strong> function, that is, a function that’s registered somewhere to be called at a later point. Commands are an object-oriented replacement for callbacks.</p>
<p class="indenthangingB1">• specify, queue, and execute requests at different times. A Command object can have a lifetime independent of the original request. If the receiver of a request can be represented in an address space-independent way, then you can transfer a command object for the request to a different process and fulfill the request there.</p>
<p class="indenthangingB1">• support undo. The Command’s Execute operation can store state for reversing its effects in the command itself. The Command interface must have an added Unexecute operation that reverses the effects of a previous call to Execute. <a id="page_236"></a>Executed commands are stored in a history list. Unlimited-level undo and redo is achieved by traversing this list backwards and forwards calling Unexecute and Execute, respectively.</p>
<p class="indenthangingB1">• support logging changes so that they can be reapplied in case of a system crash. By augmenting the Command interface with load and store operations, you can keep a persistent log of changes. Recovering from a crash involves reloading logged commands from disk and reexecuting them with the Execute operation.</p>
<p class="indenthangingB1">• structure a system around high-level operations built on primitives operations. Such a structure is common in information systems that support <strong class="calibre4">transactions.</strong> A transaction encapsulates a set of changes to data. The Command pattern offers a way to model transactions. Commands have a common interface, letting you invoke all transactions the same way. The pattern also makes it easy to extend the system with new transactions.</p>
<p class="calibre1"><a id="ch05sec2lev16"></a></p>
<h4 class="calibre15">Structure</h4>
<p class="image"><img src="../images/00258.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1"><a id="ch05sec2lev17"></a></p>
<h4 class="calibre15">Participants</h4>
<p class="indenthangingB1">• <strong class="calibre4">Command</strong></p>
<p class="indenthangingB2">– declares an interface for executing an operation.</p>
<p class="indenthangingB1">• <strong class="calibre4">ConcreteCommand</strong> (PasteCommand, OpenCommand)</p>
<p class="indenthangingB2">– defines a binding between a Receiver object and an action.</p>
<p class="indenthangingB2">– implements Execute by invoking the corresponding operation(s) on Receiver.</p>
<p class="indenthangingB1">• <strong class="calibre4">Client</strong> (Application)</p>
<p class="indenthangingB2">– creates a ConcreteCommand object and sets its receiver.</p>
<p class="indenthangingB1">• <strong class="calibre4">Invoker</strong> (Menultem)</p>
<p class="indenthangingB2">– asks the command to carry out the request.</p>
<p class="indenthangingB1"><a id="page_237"></a>• <strong class="calibre4"><a href="part0017.html#gloss01_038">Receiver</a></strong> (Document, Application)</p>
<p class="indenthangingB2">– knows how to perform the operations associated with carrying out a request. Any class may serve as a Receiver.</p>
<p class="calibre1"><a id="ch05sec2lev18"></a></p>
<h4 class="calibre15">Collaborations</h4>
<p class="indenthangingB1">• The client creates a ConcreteCommand object and specifies its receiver.</p>
<p class="indenthangingB1">• An Invoker object stores the ConcreteCommand object.</p>
<p class="indenthangingB1">• The invoker issues a request by calling Execute on the command. When commands are undoable, ConcreteCommand stores state for undoing the command prior to invoking Execute.</p>
<p class="indenthangingB1">• The ConcreteCommand object invokes operations on its receiver to carry out the request.</p>
<p class="calibre1">The following diagram shows the interactions between these objects. It illustrates how Command decouples the invoker from the receiver (and the request it carries out).</p>
<p class="image"><img src="../images/00259.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1"><a id="ch05sec2lev19"></a></p>
<h4 class="calibre15">Consequences</h4>
<p class="calibre1">The Command pattern has the following consequences:</p>
<p class="indenthangingN">1. Command decouples the object that invokes the operation from the one that knows how to perform it.</p>
<p class="indenthangingN">2. Commands are first-class objects. They can be manipulated and extended like any other object.</p>
<p class="indenthangingN">3. You can assemble commands into a composite command. An example is the MacroCommand class described earlier. In general, composite commands are an instance of the Composite (<a href="part0014.html#page_163">163</a>) pattern.</p>
<p class="indenthangingN">4. It’s easy to add new Commands, because you don’t have to change existing classes.</p>
<p class="calibre1"><a id="ch05sec2lev20"></a></p>
<h4 class="calibre15"><a id="page_238"></a>Implementation</h4>
<p class="calibre1">Consider the following issues when implementing the Command pattern:</p>
<p class="indenthangingN">1. <em class="calibre7">How intelligent should a command be?</em> A command can have a wide range of abilities. At one extreme it merely defines a binding between a receiver and the actions that carry out the request. At the other extreme it implements everything itself without delegating to a receiver at all. The latter extreme is useful when you want to define commands that are independent of existing classes, when no suitable receiver exists, or when a command knows its receiver implicitly. For example, a command that creates another application window may be just as capable of creating the window as any other object. Somewhere in between these extremes are commands that have enough knowledge to find their receiver dynamically.</p>
<p class="indenthangingN">2. <em class="calibre7">Supporting undo and redo.</em> Commands can support undo and redo capabilities if they provide a way to reverse their execution (e.g., an Unexecute or Undo operation). A ConcreteCommand class might need to store additional state to do so. This state can include</p>
<p class="indenthangingB3">• the Receiver object, which actually carries out operations in response to the request,</p>
<p class="indenthangingB3">• the arguments to the operation performed on the receiver, and</p>
<p class="indenthangingB3">• any original values in the receiver that can change as a result of handling the request. The receiver must provide operations that let the command return the receiver to its prior state.</p>
<p class="indentpara">To support one level of undo, an application needs to store only the command that was executed last. For multiple-level undo and redo, the application needs a <strong class="calibre4">history list</strong> of commands that have been executed, where the maximum length of the list determines the number of undo/redo levels. The history list stores sequences of commands that have been executed. Traversing backward through the list and reverse-executing commands cancels their effect; traversing forward and executing commands reexecutes them.</p>
<p class="indentpara">An undoable command might have to be copied before it can be placed on the history list. That’s because the command object that carried out the original request, say, from a Menultem, will perform other requests at later times. Copying is required to distinguish different invocations of the same command if its state can vary across invocations.</p>
<p class="indentpara">For example, a DeleteCommand that deletes selected objects must store different sets of objects each time it’s executed. Therefore the DeleteCommand object must be copied following execution, and the copy is placed on the history list. If the command’s state never changes on execution, then copying is not required—only a reference to the command need be placed on the history list. Commands that must be copied before being placed on the history list act as prototypes (see <a href="part0013.html#ch03sec1lev4">Prototype</a> (<a href="part0013.html#ch03sec1lev4">117</a>)).</p>
<p class="indenthangingN"><a id="page_239"></a>3. <em class="calibre7">Avoiding error accumulation in the undo process.</em> Hysteresis can be a problem in ensuring a reliable, semantics-preserving undo/redo mechanism. Errors can accumulate as commands are executed, unexecuted, and reexecuted repeatedly so that an application’s state eventually diverges from original values. It may be necessary therefore to store more information in the command to ensure that objects are restored to their original state. The Memento (<a href="part0015.html#page_283">283</a>) pattern can be applied to give the command access to this information without exposing the internals of other objects.</p>
<p class="indenthangingN">4. <em class="calibre7">Using</em> C++ <em class="calibre7">templates.</em> For commands that (1) aren’t undoable and (2) don’t require arguments, we can use C++ templates to avoid creating a Command subclass for every kind of action and receiver. We show how to do this in the Sample Code section.</p>
<p class="calibre1"><a id="ch05sec2lev21"></a></p>
<h4 class="calibre15">Sample Code</h4>
<p class="calibre1">The C++ code shown here sketches the implementation of the Command classes in the Motivation section. We’ll define <code class="calibre13">OpenCommand</code>, <code class="calibre13">PasteCommand</code>, and <code class="calibre13">MacroCommand</code>. First the abstract <code class="calibre13">Command</code> class:</p>
<p class="programlisting"><img src="../images/00260.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1"><code class="calibre13">OpenCommand</code> opens a document whose name is supplied by the user. An <code class="calibre13">OpenCommand</code> must be passed an <code class="calibre13">Application</code> object in its constructor. <code class="calibre13">AskUser</code> is an implementation routine that prompts the user for the name of the document to open.</p>
<p class="programlisting"><img src="../images/00261.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1"><a id="page_240"></a>A <code class="calibre13">PasteCommand</code> must be passed a <code class="calibre13">Document</code> object as its receiver. The receiver is given as a parameter to <code class="calibre13">PasteCommand</code>’s constructor.</p>
<p class="programlisting"><img src="../images/00262.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">For simple commands that aren’t undoable and don’t require arguments, we can use a class template to parameterize the command’s receiver. We’ll define a template subclass <code class="calibre13">SimpleCommand</code> for such commands. <code class="calibre13">SimpleCommand</code> is parameterized by the <code class="calibre13">Receiver</code> type and maintains a binding between a receiver object and an action stored as a pointer to a member function.</p>
<p class="programlisting"><img src="../images/00263.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">The constructor stores the receiver and the action in the corresponding instance variables. <code class="calibre13">Execute</code> simply applies the action to the receiver.</p>
<p class="programlisting"><a id="page_241"></a><img src="../images/00264.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">To create a command that calls <code class="calibre13">Action</code> on an instance of class <code class="calibre13">MyClass</code>, a client simply writes</p>
<p class="programlisting"><img src="../images/00265.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">Keep in mind that this solution only works for simple commands. More complex commands that keep track of not only their receivers but also arguments and/or undo state require a <code class="calibre13">Command</code> subclass.</p>
<p class="calibre1">A <code class="calibre13">MacroCommand</code> manages a sequence of subcommands and provides operations for adding and removing subcommands. No explicit receiver is required, because the subcommands already define their receiver.</p>
<p class="programlisting"><img src="../images/00266.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">The key to the <code class="calibre13">MacroCommand</code> is its <code class="calibre13">Execute</code> member function. This traverses all the subcommands and performs <code class="calibre13">Execute</code> on each of them.</p>
<p class="programlisting"><img src="../images/00267.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">Note that should the <code class="calibre13">MacroCommand</code> implement an <code class="calibre13">Unexecute</code> operation, then its subcommands must be unexecuted in <em class="calibre7">reverse</em> order relative to <code class="calibre13">Execute</code>’s implementation.</p>
<p class="calibre1">Finally, <code class="calibre13">MacroCommand</code> must provide operations to manage its subcommands. The <code class="calibre13">MacroCommand</code> is also responsible for deleting its subcommands.</p>
<p class="programlisting"><a id="page_242"></a><img src="../images/00268.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1"><a id="ch05sec2lev22"></a></p>
<h4 class="calibre15">Known Uses</h4>
<p class="calibre1">Perhaps the first example of the Command pattern appears in a paper by Lieberman <a href="part0020.html#bib01_053">[Lie85]</a>. MacApp <a href="part0020.html#bib01_004">[App89]</a> popularized the notion of commands for implementing undoable operations. ET++ <a href="part0020.html#bib01_089">[WGM88]</a>, Interviews <a href="part0020.html#bib01_050">[LCI<sup class="calibre8">+</sup>92]</a>, and Unidraw <a href="part0020.html#bib01_086">[VL90]</a> also define classes that follow the Command pattern. Interviews defines an Action abstract class that provides command functionality. It also defines an ActionCallback template, parameterized by action method, that can instantiate command subclasses automatically.</p>
<p class="calibre1">The THINK class library <a href="part0020.html#bib01_082">[Sym93b]</a> also uses commands to support undoable actions. Commands in THINK are called “Tasks.” Task objects are passed along a Chain of Responsibility (<a href="part0015.html#page_223">223</a>) for consumption.</p>
<p class="calibre1">Unidraw’s command objects are unique in that they can behave like messages. A Unidraw command may be sent to another object for interpretation, and the result of the interpration varies with the receiving object. Moreover, the receiver may delegate the interpretation to another object, typically the receiver’s parent in a larger structure as in a Chain of Responsibility. The receiver of a Unidraw command is thus computed rather than stored. Unidraw’s interpretation mechanism depends on run-time type information.</p>
<p class="calibre1">Coplien describes how to implement <strong class="calibre4">functors,</strong> objects that are functions, in C++ <a href="part0020.html#bib01_022">[Cop92]</a>. He achieves a degree of transparency in their use by overloading the function call operator <code class="calibre13">(operator())</code>. The Command pattern is different; its focus is on maintaining a <em class="calibre7">binding between</em> a receiver and a function (i.e., action), not just maintaining a function.</p>
<p class="calibre1"><a id="ch05sec2lev23"></a></p>
<h4 class="calibre15">Related Patterns</h4>
<p class="calibre1">A Composite (<a href="part0014.html#page_163">163</a>) can be used to implement MacroCommands.</p>
<p class="calibre1">A Memento (<a href="part0015.html#page_283">283</a>) can keep state the command requires to undo its effect.</p>
<p class="calibre1">A command that must be copied before being placed on the history list acts as a Prototype (<a href="part0013.html#page_117">117</a>).</p>
<p class="calibre1"><a id="ch05sec1lev3"></a></p>
<h3 class="calibre2"><a id="page_243" class="calibre3"></a>Ciass Behavioral: Interpreter</h3>
<p class="calibre1"><a id="ch05sec2lev24"></a></p>
<h4 class="calibre15">Intent</h4>
<p class="calibre1">Given a language, define a represention for its grammar along with an interpreter that uses the representation to interpret sentences in the language.</p>
<p class="calibre1"><a id="ch05sec2lev25"></a></p>
<h4 class="calibre15">Motivation</h4>
<p class="calibre1">If a particular kind of problem occurs often enough, then it might be worthwhile to express instances of the problem as sentences in a simple language. Then you can build an interpreter that solves the problem by interpreting these sentences.</p>
<p class="calibre1">For example, searching for strings that match a pattern is a common problem. Regular expressions are a standard language for specifying patterns of strings. Rather than building custom algorithms to match each pattern against strings, search algorithms could interpret a regular expression that specifies a set of strings to match.</p>
<p class="calibre1">The Interpreter pattern describes how to define a grammar for simple languages, represent sentences in the language, and interpret these sentences. In this example, the pattern describes how to define a grammar for regular expressions, represent a particular regular expression, and how to interpret that regular expression.</p>
<p class="calibre1">Suppose the following grammar defines the regular expressions:</p>
<p class="programlisting"><img src="../images/00269.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">The symbol <code class="calibre13">expression</code> is the start symbol, and <code class="calibre13">literal</code> is a terminal symbol defining simple words</p>
<p class="calibre1">The Interpreter pattern uses a class to represent each grammar rule. Symbols on the right-hand side of the rule are instance variables of these classes. The grammar above is represented by five classes: an abstract class RegularExpression and its four subclasses LiteralExpression, AlternationExpression, SequenceExpression, and RepetitionExpression. The last three classes define variables that hold subexpressions.</p>
<p class="image"><a id="page_244"></a><img src="../images/00270.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">Every regular expression defined by this grammar is represented by an abstract syntax tree made up of instances of these classes. For example, the abstract syntax tree</p>
<p class="image"><img src="../images/00271.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">represents the regular expression</p>
<p class="programlisting">raining &amp; (dogs | cats) *</p>
<p class="calibre1">We can create an interpreter for these regular expressions by defining the Interpret operation on each subclass of RegularExpression. Interpret takes as an argument the context in which to interpret the expression. The context contains the input string and information on how much of it has been matched so far. Each subclass of RegularExpression implements Interpret to match the next part of the input string based on the current context. For example,</p>
<p class="indenthangingB1"><a id="page_245"></a>• LiteralExpression will check if the input matches the literal it defines,</p>
<p class="indenthangingB1">• AlternationExpression will check if the input matches any of its alternatives,</p>
<p class="indenthangingB1">• RepetitionExpression will check if the input has multiple copies of expression it repeats,</p>
<p class="calibre1">and so on.</p>
<p class="calibre1"><a id="ch05sec2lev26"></a></p>
<h4 class="calibre15">Applicability</h4>
<p class="calibre1">Use the Interpreter pattern when there is a language to interpret, and you can represent statements in the language as abstract syntax trees. The Interpreter pattern works best when</p>
<p class="indenthangingB1">• the grammar is simple. For complex grammars, the class hierarchy for the grammar becomes large and unmanageable. Tools such as parser generators are a better alternative in such cases. They can interpret expressions without building abstract syntax trees, which can save space and possibly time.</p>
<p class="indenthangingB1">• efficiency is not a critical concern. The most efficient interpreters are usually <em class="calibre7">not</em> implemented by interpreting parse trees directly but by first translating them into another form. For example, regular expressions are often transformed into state machines. But even then, the <em class="calibre7">translator</em> can be implemented by the Interpreter pattern, so the pattern is still applicable.</p>
<p class="calibre1"><a id="ch05sec2lev27"></a></p>
<h4 class="calibre15">Structure</h4>
<p class="image"><img src="../images/00272.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1"><a id="ch05sec2lev28"></a></p>
<h4 class="calibre15">Participants</h4>
<p class="indenthangingB1">• <strong class="calibre4">AbstractExpression</strong> (RegularExpression)</p>
<p class="indenthangingB2">– declares an abstract Interpret operation that is common to all nodes in the abstract syntax tree.</p>
<p class="indenthangingB1"><a id="page_246"></a>• <strong class="calibre4">TerminalExpression</strong> (LiteralExpression)</p>
<p class="indenthangingB2">– implements an Interpret operation associated with terminal symbols in the grammar.</p>
<p class="indenthangingB2">– an instance is required for every terminal symbol in a sentence.</p>
<p class="indenthangingB1">• <strong class="calibre4">NonterminalExpression</strong> (AlternationExpression, RepetitionExpression, SequenceExpressions)</p>
<p class="indenthangingB2">– one such class is required for every rule <em class="calibre7">R</em> ::= <em class="calibre7">R</em><sub class="calibre17">1</sub><em class="calibre7">R</em><sub class="calibre17">2</sub>...<em class="calibre7">R<sub class="calibre17">n</sub></em> in the grammar.</p>
<p class="indenthangingB2">– maintains instance variables of type AbstractExpression for each of the symbols <em class="calibre7">R</em><sub class="calibre17">1</sub> through <em class="calibre7">R<sub class="calibre17">n</sub></em>.</p>
<p class="indenthangingB2">– implements an Interpret operation for nonterminal symbols in the grammar. Interpret typically calls itself recursively on the variables representing <em class="calibre7">R</em><sub class="calibre17">1</sub> through <em class="calibre7">R<sub class="calibre17">n</sub></em>.</p>
<p class="indenthangingB1">• <strong class="calibre4">Context</strong></p>
<p class="indenthangingB2">– contains information that’s global to the interpreter.</p>
<p class="indenthangingB1">• <strong class="calibre4">Client</strong></p>
<p class="indenthangingB2">– builds (or is given) an abstract syntax tree representing a particular sentence in the language that the grammar defines. The abstract syntax tree is assembled from instances of the NonterminalExpression and TerminalExpression classes.</p>
<p class="indenthangingB2">– invokes the Interpret operation.</p>
<p class="calibre1"><a id="ch05sec2lev29"></a></p>
<h4 class="calibre15">Collaborations</h4>
<p class="indenthangingB1">• The client builds (or is given) the sentence as an abstract syntax tree of NonterminalExpression and TerminalExpression instances. Then the client initializes the context and invokes the Interpret operation.</p>
<p class="indenthangingB1">• Each NonterminalExpression node defines Interpret in terms of Interpret on each subexpression. The Interpret operation of each TerminalExpression defines the base case in the recursion.</p>
<p class="indenthangingB1">• The Interpret operations at each node use the context to store and access the state of the interpreter.</p>
<p class="calibre1"><a id="ch05sec2lev30"></a></p>
<h4 class="calibre15">Consequences</h4>
<p class="calibre1">The Interpreter pattern has the following benefits and liabilities:</p>
<p class="indenthangingN">1. <em class="calibre7">It’s easy to change and extend the grammar.</em> Because the pattern uses classes to represent grammar rules, you can use inheritance to change or extend the grammar. Existing expressions can be modified incrementally, and new expressions can be defined as variations on old ones.</p>
<p class="indenthangingN"><a id="page_247"></a>2. <em class="calibre7">Implementing the grammar is easy, too.</em> Classes defining nodes in the abstract syntax tree have similar implementations. These classes are easy to write, and often their generation can be automated with a compiler or parser generator.</p>
<p class="indenthangingN">3. <em class="calibre7">Complex grammars are hard to maintain.</em> The Interpreter pattern defines at least one class for every rule in the grammar (grammar rules defined using BNF may require multiple classes). Hence grammars containing many rules can be hard to manage and maintain. Other design patterns can be applied to mitigate the problem (see <a href="part0015.html#ch05sec2lev8">Implementation</a>). But when the grammar is very complex, other techniques such as parser or compiler generators are more appropriate.</p>
<p class="indenthangingN">4. <em class="calibre7">Adding new ways to interpret expressions.</em> The Interpreter pattern makes it easier to evaluate an expression in a new way. For example, you can support pretty printing or type-checking an expression by defining a new operation on the expression classes. If you keep creating new ways of interpreting an expression, then consider using the Visitor (<a href="part0015.html#page_331">331</a>) pattern to avoid changing the grammar classes.</p>
<p class="calibre1"><a id="ch05sec2lev31"></a></p>
<h4 class="calibre15">Implementation</h4>
<p class="calibre1">The Interpreter and Composite (<a href="part0014.html#page_163">163</a>) patterns share many implementation issues. The following issues are specific to Interpreter:</p>
<p class="indenthangingN">1. <em class="calibre7">Creating the abstract syntax tree.</em> The Interpreter pattern doesn’t explain how to <em class="calibre7">create</em> an abstract syntax tree. In other words, it doesn’t address parsing. The abstract syntax tree can be created by a table-driven parser, by a hand-crafted (usually recursive descent) parser, or directly by the client.</p>
<p class="indenthangingN">2. <em class="calibre7">Defining the Interpret operation.</em> You don’t have to define the Interpret operation in the expression classes. If it’s common to create a new interpreter, then it’s better to use the Visitor (<a href="part0015.html#page_331">331</a>) pattern to put Interpret in a separate “visitor” object. For example, a grammar for a programming language will have many operations on abstract syntax trees, such as as type-checking, optimization, code generation, and so on. It will be more likely to use a visitor to avoid defining these operations on every grammar class.</p>
<p class="indenthangingN">3. <em class="calibre7">Sharing terminal symbols with the Flyweight pattern.</em> Grammars whose sentences contain many occurrences of a terminal symbol might benefit from sharing a single copy of that symbol. Grammars for computer programs are good examples—each program variable will appear in many places throughout the code. In the Motivation example, a sentence can have the terminal symbol <code class="calibre13">dog</code> (modeled by the LiteralExpression class) appearing many times.</p>
<p class="indentpara">Terminal nodes generally don’t store information about their position in the abstract syntax tree. Parent nodes pass them whatever context they need during interpretation. Hence there is a distinction between shared (intrinsic) state and passed-in (extrinsic) state, and the Flyweight (<a href="part0014.html#page_195">195</a>) pattern applies.</p>
<p class="indentpara"><a id="page_248"></a>For example, each instance of LiteralExpression for <code class="calibre13">dog</code> receives a context containing the substring matched so far. And every such LiteralExpression does the same thing in its Interpret operation—it checks whether the next part of the input contains a <code class="calibre13">dog</code>—no matter where the instance appears in the tree.</p>
<p class="calibre1"><a id="ch05sec2lev32"></a></p>
<h4 class="calibre15">Sample Code</h4>
<p class="calibre1">Here are two examples. The first is a complete example in Smalltalk for checking whether a sequence matches a regular expression. The second is a C++ program for evaluating Boolean expressions.</p>
<p class="calibre1">The regular expression matcher tests whether a string is in the language defined by the regular expression. The regular expression is defined by the following grammar:</p>
<p class="programlisting"><img src="../images/00273.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">This grammar is a slight modification of the Motivation example. We changed the concrete syntax of regular expressions a little, because symbol <code class="calibre13">"*"</code> can’t be a postfix operation in Smalltalk. So we use <code class="calibre13">repeat</code> instead. For example, the regular expression</p>
<p class="programlisting">(('dog ' | 'cat ') repeat &amp; 'weather')</p>
<p class="calibre1">matches the input string <code class="calibre13">"dog dog cat weather"</code>.</p>
<p class="calibre1">To implement the matcher, we define the five classes described on page <a href="part0015.html#ch05sec1lev3">243</a>. The class <code class="calibre13">SequenceExpression</code> has instance variables <code class="calibre13">expression1</code> and <code class="calibre13">expression2</code> for its children in the abstract syntax tree. <code class="calibre13">AlternationExpression</code> stores its alternatives in the instance variables <code class="calibre13">alternativel</code> and <code class="calibre13">alternative2</code>, while <code class="calibre13">RepetitionExpression</code> holds the expression it repeats in its <code class="calibre13">repetition</code> instance variable. LiteralExpression has a <code class="calibre13">components</code> instance variable that holds a list of objects (probably characters). These represent the literal string that must match the input sequence.</p>
<p class="calibre1">The <code class="calibre13">match:</code> operation implements an interpreter for the regular expression. Each of the classes defining the abstract syntax tree implements this operation. It takes <code class="calibre13">inputState</code> as an argument representing the current state of the matching process, having read part of the input string.</p>
<p class="calibre1">This current state is characterized by a set of input streams representing the set of inputs that the regular expression could have accepted so far. (This is roughly equivalent to recording all states that the equivalent finite state automata would be in, having recognized the input stream to this point).</p>
<p class="calibre1"><a id="page_249"></a>The current state is most important to the <code class="calibre13">repeat</code> operation. For example, if the regular expression were</p>
<p class="programlisting">'a' repeat</p>
<p class="calibre1">then the interpreter could match <code class="calibre13">"a"</code>, <code class="calibre13">"aa"</code>, <code class="calibre13">"aaa"</code>, and so on. If it were</p>
<p class="programlisting">'a' repeat &amp; 'be'</p>
<p class="calibre1">then it could match <code class="calibre13">"abc"</code>, <code class="calibre13">"aabc"</code>, <code class="calibre13">"aaabc"</code>, and so on. But if the regular expression were</p>
<p class="programlisting">'a' repeat &amp; 'abc'</p>
<p class="calibre1">then matching the input <code class="calibre13">"aabc"</code> against the subexpression <code class="calibre13">"'a' repeat"</code> would yield two input streams, one having matched one character of the input, and the other having matched two characters. Only the stream that has accepted one character will match the remaining <code class="calibre13">"abc"</code>.</p>
<p class="calibre1">Now we consider the definitions of <code class="calibre13">match:</code> for each class defining the regular expression. The definition for <code class="calibre13">SequenceExpression</code> matches each of its subexpressions in sequence. Usually it will eliminate input streams from its <code class="calibre13">inputState.</code></p>
<p class="programlisting"><img src="../images/00274.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">An <code class="calibre13">AlternationExpression</code> will return a state that consists of the union of states from either alternative. The definition of <code class="calibre13">match</code>: for <code class="calibre13">AlternationExpression</code> is</p>
<p class="programlisting"><img src="../images/00275.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">The <code class="calibre13">match</code>: operation for <code class="calibre13">RepetitionExpression</code> tries to find as many states that could match as possible:</p>
<p class="programlisting"><img src="../images/00276.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1"><a id="page_250"></a>Its output state usually contains more states than its input state, because a <code class="calibre13">RepetitionExpression</code> can match one, two, or many occurrences of <code class="calibre13">repetition</code> on the input state. The output states represent all these possibilities, allowing subsequent elements of the regular expression to decide which state is the correct one.</p>
<p class="calibre1">Finally, the definition of <code class="calibre13">match:</code> for <code class="calibre13">LiteralExpression</code> tries to match its components against each possible input stream. It keeps only those input streams that have a match:</p>
<p class="programlisting"><img src="../images/00277.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">The <code class="calibre13">nextAvailable:</code> message advances the input stream. This is the only <code class="calibre13">match:</code> operation that advances the stream. Notice how the state that’s returned contains a copy of the input stream, thereby ensuring that matching a literal never changes the input stream. This is important because each alternative of an <code class="calibre13">AlternationExpression</code> should see identical copies of the input stream.</p>
<p class="calibre1">Now that we’ve defined the classes that make up an abstract syntax tree, we can describe how to build it. Rather than write a parser for regular expressions, we’ll define some operations on the <code class="calibre13">RegularExpression</code> classes so that evaluating a Smalltalk expression will produce an abstract syntax tree for the corresponding regular expression. That lets us use the built-in Smalltalk compiler as if it were a parser for regular expressions.</p>
<p class="calibre1">To build the abstract syntax tree, we’ll need to define <code class="calibre13">"|"</code>, <code class="calibre13">"repeat"</code>, and <code class="calibre13">"&amp;"</code> as operations on <code class="calibre13">RegularExpression</code>. These operations are defined in class <code class="calibre13">RegularExpression</code> like this:</p>
<p class="programlisting"><img src="../images/00278.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1"><a id="page_251"></a>The <code class="calibre13">asRExp</code> operation will convert literals into <code class="calibre13">RegularExpressions</code>. These operations are defined in class <code class="calibre13">String</code>:</p>
<p class="programlisting"><img src="../images/00279.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">If we defined these operations higher up in the class hierarchy (<code class="calibre13">Sequenceable-Collection</code> in Smalltalk-80, <code class="calibre13">IndexedCollection</code> in Smalltalk/V), then they would also be defined for classes such as <code class="calibre13">Array</code> and <code class="calibre13">OrderedCollection</code>. This would let regular expressions match sequences of any kind of object.</p>
<p class="calibre1">The second example is a system for manipulating and evaluating Boolean expressions implemented in C++. The terminal symbols in this language are Boolean variables, that is, the constants <code class="calibre13">true</code> and <code class="calibre13">false</code>. Nonterminal symbols represent expressions containing the operators <code class="calibre13">and</code>, <code class="calibre13">or</code>, and <code class="calibre13">not</code>. The grammar is defined as follows<sup class="calibre8"><a id="ch05fn_01"></a><a href="part0022.html#ch05fn01">1</a></sup>:</p>
<p class="programlisting"><img src="../images/00280.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">We define two operations on Boolean expressions. The first, <code class="calibre13">Evaluate</code>, evaluates a Boolean expression in a context that assigns a true or false value to each variable. The second operation, <code class="calibre13">Replace</code>, produces a new Boolean expression by replacing a variable with an expression. <code class="calibre13">Replace</code> shows how the Interpreter pattern can be used for more than just evaluating expressions. In this case, it manipulates the expression itself.</p>
<p class="calibre1"><a id="page_252"></a>We give details of just the <code class="calibre13">BooleanExp</code>, <code class="calibre13">VariableExp</code>, and <code class="calibre13">AndExp</code> classes here. Classes <code class="calibre13">OrExp</code> and <code class="calibre13">NotExp</code> are similar to <code class="calibre13">AndExp</code>. The <code class="calibre13">Constant</code> class represents the Boolean constants.</p>
<p class="calibre1"><code class="calibre13">BooleanExp</code> defines the interface for all classes that define a Boolean expression:</p>
<p class="programlisting"><img src="../images/00281.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">The class <code class="calibre13">Context</code> defines a mapping from variables to Boolean values, which we represent with the C++ constants <code class="calibre13">true</code> and <code class="calibre13">false</code>. <code class="calibre13">Context</code> has the following interface:</p>
<p class="programlisting"><img src="../images/00282.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">A <code class="calibre13">VariableExp</code> represents a named variable:</p>
<p class="programlisting"><img src="../images/00283.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">The constructor takes the variable’s name as an argument:</p>
<p class="programlisting"><img src="../images/00284.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">Evaluating a variable returns its value in the current context.</p>
<p class="programlisting"><img src="../images/00285.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1"><a id="page_253"></a>Copying a variable returns a new <code class="calibre13">VariableExp</code>:</p>
<p class="programlisting"><img src="../images/00286.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">To replace a variable with an expression, we check to see if the variable has the same name as the one it is passed as an argument:</p>
<p class="programlisting"><img src="../images/00287.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">An <code class="calibre13">AndExp</code> represents an expression made by ANDing two Boolean expressions together.</p>
<p class="programlisting"><img src="../images/00288.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">Evaluating an <code class="calibre13">AndExp</code> evaluates its operands and returns the logical “and” of the results.</p>
<p class="programlisting"><img src="../images/00289.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">An <code class="calibre13">AndExp</code> implements <code class="calibre13">Copy</code> and <code class="calibre13">Replace</code> by making recursive calls on its operands:</p>
<p class="programlisting"><a id="page_254"></a><img src="../images/00290.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">Now we can define the Boolean expression</p>
<p class="programlisting">(true and x) or (y and (not x))</p>
<p class="calibre1">and evaluate it for a given assignment of <code class="calibre13">true</code> or <code class="calibre13">false</code> to the variables <code class="calibre13">x</code> and <code class="calibre13">y</code>:</p>
<p class="programlisting"><img src="../images/00291.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">The expression evaluates to <code class="calibre13">true</code> for this assignment to <code class="calibre13">x</code> and <code class="calibre13">y</code>. We can evaluate the expression with a different assignment to the variables simply by changing the context.</p>
<p class="calibre1">Finally, we can replace the variable <code class="calibre13">y</code> with a new expression and then reevaluate it:</p>
<p class="programlisting"><img src="../images/00292.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">This example illustrates an important point about the Interpreter pattern: many kinds of operations can “interpret” a sentence. Of the three operations defined <a id="page_255"></a>for <code class="calibre13">BooleanExp</code>, <code class="calibre13">Evaluate</code> fits our idea of what an interpreter should do most closely—that is, it interprets a program or expression and returns a simple result.</p>
<p class="calibre1">However, <code class="calibre13">Replace</code> can be viewed as an interpreter as well. It’s an interpreter whose context is the name of the variable being replaced along with the expression that replaces it, and whose result is a new expression. Even <code class="calibre13">Copy</code> can be thought of as an interpreter with an empty context. It may seem a little strange to consider <code class="calibre13">Replace</code> and <code class="calibre13">Copy</code> to be interpreters, because these are just basic operations on trees. The examples in Visitor (<a href="part0015.html#page_331">331</a>) illustrate how all three operations can be refactored into a separate “interpreter” visitor, thus showing that the similarity is deep.</p>
<p class="calibre1">The Interpreter pattern is more than just an operation distributed over a class hierarchy that uses the Composite (<a href="part0014.html#page_163">163</a>) pattern. We consider <code class="calibre13">Evaluate</code> an interpreter because we think of the <code class="calibre13">BooleanExp</code> class hierarchy as representing a language. Given a similar class hierarchy for representing automotive part assemblies, it’s unlikely we’d consider operations like <code class="calibre13">Weight</code> and <code class="calibre13">Copy</code> as interpreters even though they are distributed over a class hierarchy that uses the Composite pattern—we just don’t think of automotive parts as a language. It’s a matter of perspective; if we started publishing grammars of automotive parts, then we could consider operations on those parts to be ways of interpreting the language.</p>
<p class="calibre1"><a id="ch05sec2lev33"></a></p>
<h4 class="calibre15">Known Uses</h4>
<p class="calibre1">The Interpreter pattern is widely used in compilers implemented with object-oriented languages, as the Smalltalk compilers are. SPECTalk uses the pattern to interpret descriptions of input file formats <a href="part0020.html#bib01_083">[Sza92]</a>. The QOCA constraint-solving toolkit uses it to evaluate constraints <a href="part0020.html#bib01_036">[HHMV92]</a>.</p>
<p class="calibre1">Considered in its most general form (i.e., an operation distributed over a class hierarchy based on the Composite pattern), nearly every use of the Composite pattern will also contain the Interpreter pattern. But the Interpreter pattern should be reserved for those cases in which you want to think of the class hierarchy as defining a language.</p>
<p class="calibre1"><a id="ch05sec2lev34"></a></p>
<h4 class="calibre15">Related Patterns</h4>
<p class="calibre1">Composite (<a href="part0014.html#page_163">163</a>): The abstract syntax tree is an instance of the Composite pattern.</p>
<p class="calibre1">Flyweight (<a href="part0014.html#page_195">195</a>) shows how to share terminal symbols within the abstract syntax tree.</p>
<p class="calibre1">Iterator (<a href="part0015.html#page_257">257</a>): The interpreter can use an Iterator to traverse the structure.</p>
<p class="calibre1">Visitor (<a href="part0015.html#page_331">331</a>) can be used to maintain the behavior in each node in the abstract syntax tree in one class.</p>
<p class="calibre1"><a id="ch05sec1lev4"></a></p>
<h3 class="calibre2"><a id="page_257" class="calibre3"></a>Object Behavioral: Iterator</h3>
<p class="calibre1"><a id="ch05sec2lev35"></a></p>
<h4 class="calibre15">Intent</h4>
<p class="calibre1">Provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation.</p>
<p class="calibre1"><a id="ch05sec2lev36"></a></p>
<h4 class="calibre15">Also Known As</h4>
<p class="calibre1">Cursor</p>
<p class="calibre1"><a id="ch05sec2lev37"></a></p>
<h4 class="calibre15">Motivation</h4>
<p class="calibre1">An aggregate object such as a list should give you a way to access its elements without exposing its internal structure. Moreover, you might want to traverse the list in different ways, depending on what you want to accomplish. But you probably don’t want to bloat the List interface with operations for different traversals, even if you could anticipate the ones you will need. You might also need to have more than one traversal pending on the same list.</p>
<p class="calibre1">The Iterator pattern lets you do all this. The key idea in this pattern is to take the responsibility for access and traversal out of the list object and put it into an <strong class="calibre4">iterator</strong> object. The Iterator class defines an interface for accessing the list’s elements. An iterator object is responsible for keeping track of the current element; that is, it knows which elements have been traversed already.</p>
<p class="calibre1">For example, a List class would call for a ListIterator with the following relationship between them:</p>
<p class="image"><img src="../images/00293.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">Before you can instantiate ListIterator, you must supply the List to traverse. Once you have the ListIterator instance, you can access the list’s elements sequentially. The CurrentItem operation returns the current element in the list, First initializes the current element to the first element, Next advances the current element to the next element, and IsDone tests whether we’ve advanced beyond the last element—that is, we’re finished with the traversal.</p>
<p class="calibre1"><a id="page_258"></a>Separating the traversal mechanism from the List object lets us define iterators for different traversal policies without enumerating them in the List interface. For example, FilteringListIterator might provide access only to those elements that satisfy specific filtering constraints.</p>
<p class="calibre1">Notice that the iterator and the list are coupled, and the client must know that it is a <em class="calibre7">list</em> that’s traversed as opposed to some other aggregate structure. Hence the client commits to a particular aggregate structure. It would be better if we could change the aggregate class without changing client code. We can do this by generalizing the iterator concept to support <strong class="calibre4">polymorphic iteration</strong>.</p>
<p class="calibre1">As an example, let’s assume that we also have a SkipList implementation of a list. A skiplist <a href="part0020.html#bib01_068">[Pug90]</a> is a probabilistic data structure with characteristics similar to balanced trees. We want to be able to write code that works for both List and SkipList objects.</p>
<p class="calibre1">We define an AbstractList class that provides a common interface for manipulating lists. Similarly, we need an abstract Iterator class that defines a common iteration interface. Then we can define concrete Iterator subclasses for the different list implementations. As a result, the iteration mechanism becomes independent of concrete aggregate classes.</p>
<p class="image"><img src="../images/00294.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">The remaining problem is how to create the iterator. Since we want to write code that’s independent of the concrete List subclasses, we cannot simply instantiate a specific class. Instead, we make the list objects responsible for creating their corresponding iterator. This requires an operation like CreateIterator through which clients request an iterator object.</p>
<p class="calibre1">CreateIterator is an example of a factory method (see <a href="part0013.html#ch03sec1lev3">Factory Method</a> (<a href="part0013.html#ch03sec1lev3">107</a>)). We use it here to let a client ask a list object for the appropriate iterator. The Factory Method approach give rise to two class hierarchies, one for lists and another for iterators. The CreateIterator factory method “connects” the two hierarchies.</p>
<p class="calibre1"><a id="ch05sec2lev38"></a></p>
<h4 class="calibre15"><a id="page_259"></a>Applicability</h4>
<p class="calibre1">Use the Iterator pattern</p>
<p class="indenthangingB1">• to access an aggregate object’s contents without exposing its internal representation.</p>
<p class="indenthangingB1">• to support multiple traversals of aggregate objects.</p>
<p class="indenthangingB1">• to provide a uniform interface for traversing different aggregate structures (that is, to support polymorphic iteration).</p>
<p class="calibre1"><a id="ch05sec2lev39"></a></p>
<h4 class="calibre15">Structure</h4>
<p class="image"><img src="../images/00295.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1"><a id="ch05sec2lev40"></a></p>
<h4 class="calibre15">Participants</h4>
<p class="indenthangingB1">• <strong class="calibre4">Iterator</strong></p>
<p class="indenthangingB2">– defines an interface for accessing and traversing elements.</p>
<p class="indenthangingB1">• <strong class="calibre4">ConcreteIterator</strong></p>
<p class="indenthangingB2">– implements the Iterator interface.</p>
<p class="indenthangingB2">– keeps track of the current position in the traversal of the aggregate.</p>
<p class="indenthangingB1">• <strong class="calibre4">Aggregate</strong></p>
<p class="indenthangingB2">– defines an interface for creating an Iterator object.</p>
<p class="indenthangingB1">• <strong class="calibre4">ConcreteAggregate</strong></p>
<p class="indenthangingB2">– implements the Iterator creation interface to return an instance of the proper ConcreteIterator.</p>
<p class="calibre1"><a id="ch05sec2lev41"></a></p>
<h4 class="calibre15"><a id="page_260"></a>Collaborations</h4>
<p class="indenthangingB1">• A ConcreteIterator keeps track of the current object in the aggregate and can compute the succeeding object in the traversal.</p>
<p class="calibre1"><a id="ch05sec2lev42"></a></p>
<h4 class="calibre15">Consequences</h4>
<p class="calibre1">The Iterator pattern has three important consequences:</p>
<p class="indenthangingN">1. <em class="calibre7">It supports variations in the traversal of an aggregate.</em> Complex aggregates may be traversed in many ways. For example, code generation and semantic checking involve traversing parse trees. Code generation may traverse the parse tree inorder or preorder. Iterators make it easy to change the traversal algorithm: Just replace the iterator instance with a different one. You can also define Iterator subclasses to support new traversals.</p>
<p class="indenthangingN">2. <em class="calibre7">Iterators simplify the Aggregate interface.</em> Iterator’s traversal interface obviates the need for a similar interface in Aggregate, thereby simplifying the aggregate’s interface.</p>
<p class="indenthangingN">3. <em class="calibre7">More than one traversal can be pending on an aggregate.</em> An iterator keeps track of its own traversal state. Therefore you can have more than one traversal in progress at once.</p>
<p class="calibre1"><a id="ch05sec2lev43"></a></p>
<h4 class="calibre15">Implementation</h4>
<p class="calibre1">Iterator has many implementation variants and alternatives. Some important ones follow. The trade-offs often depend on the control structures your language provides. Some languages (CLU <a href="part0020.html#bib01_052">[LG86]</a>, for example) even support this pattern directly.</p>
<p class="indenthangingN">1. <em class="calibre7">Who controls the iteration?</em> A fundamental issue is deciding which party controls the iteration, the iterator or the client that uses the iterator. When the client controls the iteration, the iterator is called an <strong class="calibre4">external iterator</strong>, and when the iterator controls it, the iterator is an <strong class="calibre4">internal iterator</strong>.<sup class="calibre8"><a id="ch05fn_02"></a><a href="part0022.html#ch05fn02">2</a></sup> Clients that use an external iterator must advance the traversal and request the next element explicitly from the iterator. In contrast, the client hands an internal iterator an operation to perform, and the iterator applies that operation to every element in the aggregate.</p>
<p class="indentpara">External iterators are more flexible than internal iterators. It’s easy to compare two collections for equality with an external iterator, for example, but it’s practically impossible with internal iterators. Internal iterators are especially weak in a language like C++ that does not provide anonymous functions, closures, or continuations like Smalltalk and CLOS. But on the other hand, <a id="page_261"></a>internal iterators are easier to use, because they define the iteration logic for you.</p>
<p class="indenthangingN">2. <em class="calibre7">Who defines the traversal algorithm?</em> The iterator is not the only place where the traversal algorithm can be defined. The aggregate might define the traversal algorithm and use the iterator to store just the state of the iteration. We call this kind of iterator a <strong class="calibre4">cursor</strong>, since it merely points to the current position in the aggregate. A client will invoke the Next operation on the aggregate with the cursor as an argument, and the Next operation will change the state of the cursor.<sup class="calibre8"><a id="ch05fn_03"></a><a href="part0022.html#ch05fn03">3</a></sup></p>
<p class="indentpara">If the iterator is responsible for the traversal algorithm, then it’s easy to use different iteration algorithms on the same aggregate, and it can also be easier to reuse the same algorithm on different aggregates. On the other hand, the traversal algorithm might need to access the private variables of the aggregate. If so, putting the traversal algorithm in the iterator violates the encapsulation of the aggregate.</p>
<p class="indenthangingN">3. <em class="calibre7">How robust is the iterator?</em> It can be dangerous to modify an aggregate while you’re traversing it. If elements are added or deleted from the aggregate, you might end up accessing an element twice or missing it completely. A simple solution is to copy the aggregate and traverse the copy, but that’s too expensive to do in general.</p>
<p class="indentpara">A <strong class="calibre4">robust iterator</strong> ensures that insertions and removals won’t interfere with traversal, and it does it without copying the aggregate. There are many ways to implement robust iterators. Most rely on registering the iterator with the aggregate. On insertion or removal, the aggregate either adjusts the internal state of iterators it has produced, or it maintains information internally to ensure proper traversal.</p>
<p class="indentpara">Kofler provides a good discussion of how robust iterators are implemented in ET++ <a href="part0020.html#bib01_047">[Kof93]</a>. Murray discusses the implementation of robust iterators for the USL StandardComponents’ List class <a href="part0020.html#bib01_062">[Mur93]</a>.</p>
<p class="indenthangingN">4. <em class="calibre7">Additional Iterator operations.</em> The minimal interface to Iterator consists of the operations First, Next, IsDone, and CurrentItem.<sup class="calibre8"><a id="ch05fn_04"></a><a href="part0022.html#ch05fn04">4</a></sup> Some additional operations might prove useful. For example, ordered aggregates can have a Previous operation that positions the iterator to the previous element. A SkipTo operation is useful for sorted or indexed collections. SkipTo positions the iterator to an object matching specific criteria.</p>
<p class="indenthangingN">5. <em class="calibre7">Using polymorphic iterators in C++.</em> Polymorphic iterators have their cost. They require the iterator object to be allocated dynamically by a factory method. Hence they should be used only when there’s a need for polymorphism. Otherwise use concrete iterators, which can be allocated on the stack.</p>
<p class="indentpara"><a id="page_262"></a>Polymorphic iterators have another drawback: the client is responsible for deleting them. This is error-prone, because it’s easy to forget to free a heap-allocated iterator object when you’re finished with it. That’s especially likely when there are multiple exit points in an operation. And if an exception is triggered, the iterator object will never be freed.</p>
<p class="indentpara">The Proxy (<a href="part0014.html#page_207">207</a>) pattern provides a remedy. We can use a stack-allocated proxy as a stand-in for the real iterator. The proxy deletes the iterator in its destructor. Thus when the proxy goes out of scope, the real iterator will get deallocated along with it. The proxy ensures proper cleanup, even in the face of exceptions. This is an application of the well-known C++ technique “resource allocation is initialization” <a href="part0020.html#bib01_028">[ES90]</a>. The Sample Code gives an example.</p>
<p class="indenthangingN">6. <em class="calibre7">Iterators may have privileged access.</em> An iterator can be viewed as an extension of the aggregate that created it. The iterator and the aggregate are tightly coupled. We can express this close relationship in C++ by making the iterator a <code class="calibre13">friend</code> of its aggregate. Then you don’t need to define aggregate operations whose sole purpose is to let iterators implement traversal efficiently.</p>
<p class="indentpara">However, such privileged access can make defining new traversals difficult, since it’ll require changing the aggregate interface to add another friend. To avoid this problem, the Iterator class can include <code class="calibre13">protected</code> operations for accessing important but publicly unavailable members of the aggregate. Iterator subclasses (and <em class="calibre7">only</em> Iterator subclasses) may use these protected operations to gain privileged access to the aggregate.</p>
<p class="indenthangingN">7. <em class="calibre7">Iterators for composites.</em> External iterators can be difficult to implement over recursive aggregate structures like those in the Composite (<a href="part0014.html#page_163">163</a>) pattern, because a position in the structure may span many levels of nested aggregates. Therefore an external iterator has to store a path through the Composite to keep track of the current object. Sometimes it’s easier just to use an internal iterator. It can record the current position simply by calling itself recursively, thereby storing the path implicitly in the call stack.</p>
<p class="indentpara">If the nodes in a Composite have an interface for moving from a node to its siblings, parents, and children, then a cursor-based iterator may offer a better alternative. The cursor only needs to keep track of the current node; it can rely on the node interface to traverse the Composite.</p>
<p class="indentpara">Composites often need to be traversed in more than one way. Preorder, postorder, inorder, and breadth-first traversals are common. You can support each kind of traversal with a different class of iterator.</p>
<p class="indenthangingN">8. <em class="calibre7">Null iterators.</em> A <strong class="calibre4">NullIterator</strong> is a degenerate iterator that’s helpful for handling boundary conditions. By definition, a NullIterator is <em class="calibre7">always</em> done with traversal; that is, its IsDone operation always evaluates to true.</p>
<p class="indentpara">NullIterator can make traversing tree-structured aggregates (like Composites) easier. At each point in the traversal, we ask the current element for an iterator for its children. Aggregate elements return a concrete iterator <a id="page_263"></a>as usual. But leaf elements return an instance of NullIterator. That lets us implement traversal over the entire structure in a uniform way.</p>
<p class="calibre1"><a id="ch05sec2lev44"></a></p>
<h4 class="calibre15">Sample Code</h4>
<p class="calibre1">We’ll look at the implementation of a simple List class, which is part of our foundation library (<a href="part0019.html#app03">Appendix C</a>). We’ll show two Iterator implementations, one for traversing the List in front-to-back order, and another for traversing back-to-front (the foundation library supports only the first one). Then we show how to use these iterators and how to avoid committing to a particular implementation. After that, we change the design to make sure iterators get deleted properly. The last example illustrates an internal iterator and compares it to its external counterpart.</p>
<p class="indenthangingN">1. <em class="calibre7">List and Iterator interfaces.</em> First let’s look at the part of the List interface that’s relevant to implementing iterators. Refer to <a href="part0019.html#app03">Appendix C</a> for the full interface.</p>
<p class="programlisting"><img src="../images/00296.jpeg" alt="image" class="calibre11"/></p>
<p class="indentpara">The <code class="calibre13">List</code> class provides a reasonably efficient way to support iteration through its public interface. It’s sufficient to implement both traversals. So there’s no need to give iterators privileged access to the underlying data structure; that is, the iterator classes are not friends of <code class="calibre13">List</code>. To enable transparent use of the different traversals we define an abstract <code class="calibre13">Iterator</code> class, which defines the iterator interface.</p>
<p class="programlisting"><img src="../images/00297.jpeg" alt="image" class="calibre11"/></p>
<p class="indenthangingN">2. <em class="calibre7">Iterator subclass implementations.</em> <code class="calibre13">ListIterator</code> is a subclass of <code class="calibre13">Iterator</code>.</p>
<p class="programlisting"><a id="page_264"></a><img src="../images/00298.jpeg" alt="image" class="calibre11"/></p>
<p class="indentpara">The implementation of <code class="calibre13">ListIterator</code> is straightforward. It stores the <code class="calibre13">List</code> along with an index <code class="calibre13">_current</code> into the list:</p>
<p class="programlisting2"><img src="../images/00299.jpeg" alt="image" class="calibre11"/></p>
<p class="indentpara"><code class="calibre13">First</code> positions the iterator to the first element:</p>
<p class="programlisting2"><img src="../images/00300.jpeg" alt="image" class="calibre11"/></p>
<p class="indentpara"><code class="calibre13">Next</code> advances the current element:</p>
<p class="programlisting2"><img src="../images/00301.jpeg" alt="image" class="calibre11"/></p>
<p class="indentpara"><code class="calibre13">IsDone</code> checks whether the index refers to an element within the List:</p>
<p class="programlisting2"><img src="../images/00302.jpeg" alt="image" class="calibre11"/></p>
<p class="indentpara">Finally, <code class="calibre13">CurrentItem</code> returns the item at the current index. If the iteration has already terminated, then we throw an <code class="calibre13">IteratorOutOfBounds</code> exception:</p>
<p class="programlisting2"><img src="../images/00303.jpeg" alt="image" class="calibre11"/></p>
<p class="indentpara"><a id="page_265"></a>The implementation of ReverseListIterator is identical, except its <code class="calibre13">First</code> operation positions <code class="calibre13">_current</code> to the end of the list, and <code class="calibre13">Next</code> decrements <code class="calibre13">_current</code> toward the first item.</p>
<p class="indenthangingN">3. <em class="calibre7">Using the iterators.</em> Let’s assume we have a <code class="calibre13">List</code> of <code class="calibre13">Employee</code> objects, and we would like to print all the contained employees. The <code class="calibre13">Employee</code> class supports this with a <code class="calibre13">Print</code> operation. To print the list, we define a <code class="calibre13">PrintEmployees</code> operation that takes an iterator as an argument. It uses the iterator to traverse and print the list.</p>
<p class="programlisting"><img src="../images/00304.jpeg" alt="image" class="calibre11"/></p>
<p class="indentpara">Since we have iterators for both back-to-front and front-to-back traversals, we can reuse this operation to print the employees in both orders.</p>
<p class="programlisting"><img src="../images/00305.jpeg" alt="image" class="calibre11"/></p>
<p class="indenthangingN">4. <em class="calibre7">Avoiding commitment to a specific list implementation.</em> Let’s consider how a skiplist variation of <code class="calibre13">List</code> would affect our iteration code. A <code class="calibre13">SkipList</code> subclass of <code class="calibre13">List</code> must provide a <code class="calibre13">SkipListIterator</code> that implements the <code class="calibre13">Iterator</code> interface. Internally, the <code class="calibre13">SkipListIterator</code> has to keep more than just an index to do the iteration efficiently. But since <code class="calibre13">SkipListIterator</code> conforms to the <code class="calibre13">Iterator</code> interface, the <code class="calibre13">PrintEmployees</code> operation can also be used when the employees are stored in a <code class="calibre13">SkipList</code> object.</p>
<p class="programlisting"><img src="../images/00306.jpeg" alt="image" class="calibre11"/></p>
<p class="indentpara">Although this approach works, it would be better if we didn’t have to commit to a specific <code class="calibre13">List</code> implementation, namely <code class="calibre13">SkipList</code>. We can introduce an <code class="calibre13">AbstractList</code> class to standardize the list interface for different <code class="calibre13">list</code> implementations. <code class="calibre13">List</code> and <code class="calibre13">SkipList</code> become subclasses of <code class="calibre13">AbstractList</code>.</p>
<p class="indentpara">To enable polymorphic iteration, <code class="calibre13">AbstractList</code> defines a factory method <code class="calibre13">CreateIterator</code>, which subclasses override to return their corresponding iterator:</p>
<p class="programlisting2"><a id="page_266"></a><img src="../images/00307.jpeg" alt="image" class="calibre11"/></p>
<p class="indentpara">An alternative would be to define a general mixin class <code class="calibre13">Traversable</code> that defines the interface for creating an iterator. Aggregate classes can mix in <code class="calibre13">Traversable</code> to support polymorphic iteration.</p>
<p class="indentpara"><code class="calibre13">List</code> overrides <code class="calibre13">CreateIterator</code> to return a <code class="calibre13">ListIterator</code> object:</p>
<p class="programlisting2"><img src="../images/00308.jpeg" alt="image" class="calibre11"/></p>
<p class="indentpara">Now we’re in a position to write the code for printing the employees independent of a concrete representation.</p>
<p class="programlisting"><img src="../images/00309.jpeg" alt="image" class="calibre11"/></p>
<p class="indenthangingN">5. <em class="calibre7">Making sure iterators get deleted.</em> Notice that <code class="calibre13">CreateIterator</code> returns a newly allocated iterator object. We’re responsible for deleting it. If we forget, then we’ve created a storage leak. To make life easier for clients, we’ll provide an <code class="calibre13">IteratorPtr</code> that acts as a proxy for an iterator. It takes care of cleaning up the <code class="calibre13">Iterator</code> object when it goes out of scope.</p>
<p class="indentpara"><code class="calibre13">IteratorPtr</code> is always allocated on the stack.<sup class="calibre8"><a id="ch05fn_05"></a><a href="part0022.html#ch05fn05">5</a></sup> C++ automatically takes care of calling its destructor, which deletes the real iterator. <code class="calibre13">IteratorPtr</code> overloads both <code class="calibre13">operator-&gt;</code> and <code class="calibre13">operator*</code> in such a way that an <code class="calibre13">IteratorPtr</code> can be treated just like a pointer to an iterator. The members of <code class="calibre13">IteratorPtr</code> are all implemented inline; thus they can incur no overhead.</p>
<p class="programlisting"><a id="page_267"></a><img src="../images/00310.jpeg" alt="image" class="calibre11"/></p>
<p class="indentpara"><code class="calibre13">IteratorPtr</code> lets us simplify our printing code:</p>
<p class="programlisting2"><img src="../images/00311.jpeg" alt="image" class="calibre11"/></p>
<p class="indenthangingN">6. <em class="calibre7">An internal ListIterator.</em> As a final example, let’s look at a possible implementation of an internal or passive <code class="calibre13">ListIterator</code> class. Here the iterator controls the iteration, and it applies an operation to each element.</p>
<p class="indentpara">The issue in this case is how to parameterize the iterator with the operation we want to perform on each element. C++ does not support anonymous functions or closures that other languages provide for this task. There are at least two options: (1) Pass in a pointer to a function (global or static), or (2) rely on subclassing. In the first case, the iterator calls the operation passed to it at each point in the iteration. In the second case, the iterator calls an operation that a subclass overrides to enact specific behavior.</p>
<p class="indentpara">Neither option is perfect. Often you want to accumulate state during the iteration, and functions aren’t well-suited to that; we would have to use static variables to remember the state. An <code class="calibre13">Iterator</code> subclass provides us with a convenient place to store the accumulated state, like in an instance variable. But creating a subclass for every different traversal is more work.</p>
<p class="indentpara">Here’s a sketch of the second option, which uses subclassing. We call the internal iterator a <code class="calibre13">ListTraverser</code>.</p>
<p class="programlisting"><img src="../images/00312.jpeg" alt="image" class="calibre11"/></p>
<p class="indentpara"><code class="calibre13">ListTraverser</code> takes a <code class="calibre13">List</code> instance as a parameter. Internally it uses an external <code class="calibre13">ListIterator</code> to do the traversal. <code class="calibre13">Traverse</code> starts the traversal <a id="page_268"></a>and calls <code class="calibre13">ProcessItem</code> for each item. The internal iterator can choose to terminate a traversal by returning <code class="calibre13">false</code> from <code class="calibre13">ProcessItem</code>. <code class="calibre13">Traverse</code> returns whether the traversal terminated prematurely.</p>
<p class="programlisting"><img src="../images/00313.jpeg" alt="image" class="calibre11"/></p>
<p class="indentpara">Let’s use a <code class="calibre13">ListTraverser</code> to print the first 10 employees from our employee list. To do it we have to subclass <code class="calibre13">ListTraverser</code> and override <code class="calibre13">ProcessItem</code>. We count the number of printed employees in a <code class="calibre13">_count</code> instance variable.</p>
<p class="programlisting"><img src="../images/00314.jpeg" alt="image" class="calibre11"/></p>
<p class="indentpara">Here’s how <code class="calibre13">PrintNEmployees</code> prints the first 10 employees on the list:</p>
<p class="programlisting2"><a id="page_269"></a><img src="../images/00315.jpeg" alt="image" class="calibre11"/></p>
<p class="indentpara">Note how the client doesn’t specify the iteration loop. The entire iteration logic can be reused. This is the primary benefit of an internal iterator. It’s a bit more work than an external iterator, though, because we have to define a new class. Contrast this with using an external iterator:</p>
<p class="programlisting2"><img src="../images/00316.jpeg" alt="image" class="calibre11"/></p>
<p class="indentpara">Internal iterators can encapsulate different kinds of iteration. For example, <code class="calibre13">FilteringListTraverser</code> encapsulates an iteration that processes only items that satisfy a test:</p>
<p class="programlisting2"><img src="../images/00317.jpeg" alt="image" class="calibre11"/></p>
<p class="indentpara">This interface is the same as <code class="calibre13">ListTraverser</code>’s except for an added <code class="calibre13">TestItem</code> member function that defines the test. Subclasses override <code class="calibre13">TestItem</code> to specify the test.</p>
<p class="indentpara"><code class="calibre13">Traverse</code> decides to continue the traversal based on the outcome of the test:</p>
<p class="programlisting2"><a id="page_270"></a><img src="../images/00318.jpeg" alt="image" class="calibre11"/></p>
<p class="indentpara">A variant of this class could define Traverse to return if at least one item satisfies the test.<sup class="calibre8"><a id="ch05fn_06"></a><a href="part0022.html#ch05fn06">6</a></sup></p>
<p class="calibre1"><a id="ch05sec2lev45"></a></p>
<h4 class="calibre15">Known Uses</h4>
<p class="calibre1">Iterators are common in object-oriented systems. Most collection class libraries offer iterators in one form or another.</p>
<p class="calibre1">Here’s an example from the Booch components <a href="part0020.html#bib01_010">[Boo94]</a>, a popular collection class library. It provides both a fixed size (bounded) and dynamically growing (unbounded) implementation of a queue. The queue interface is defined by an abstract Queue class. To support polymorphic iteration over the different queue implementations, the queue iterator is implemented in the terms of the abstract Queue class interface. This variation has the advantage that you don’t need a factory method to ask the queue implementations for their appropriate iterator. However, it requires the interface of the abstract Queue class to be powerful enough to implement the iterator efficiently.</p>
<p class="calibre1">Iterators don’t have to be defined as explicitly in Smalltalk. The standard collection classes (Bag, Set, Dictionary, OrderedCollection, String, etc.) define an internal iterator method <code class="calibre13">do</code>:, which takes a block (i.e., closure) as an argument. Each element in the collection is bound to the local variable in the block; then the block is executed. Smalltalk also includes a set of Stream classes that support an iterator-like interface. ReadStream is essentially an Iterator, and it can act as an external iterator for all the sequential collections. There are no standard external iterators for nonsequential collections such as Set and Dictionary.</p>
<p class="calibre1">Polymorphic iterators and the cleanup Proxy described earlier are provided by the ET++ container classes <a href="part0020.html#bib01_089">[WGM88]</a>. The Unidraw graphical editing framework classes use cursor-based iterators <a href="part0020.html#bib01_086">[VL90]</a>.</p>
<p class="calibre1">ObjectWindows 2.0 <a href="part0020.html#bib01_012">[Bor94]</a> provides a class hierarchy of iterators for containers. You can iterate over different container types in the same way. The ObjectWindow iteration syntax relies on overloading the postincrement operator ++ to advance the iteration.</p>
<p class="calibre1"><a id="ch05sec2lev46"></a></p>
<h4 class="calibre15">Related Patterns</h4>
<p class="calibre1">Composite (<a href="part0014.html#page_163">163</a>): Iterators are often applied to recursive structures such as Composites.</p>
<p class="calibre1"><a id="page_271"></a>Factory Method (<a href="part0013.html#page_107">107</a>): Polymorphic iterators rely on factory methods to instantiate the appropriate Iterator subclass.</p>
<p class="calibre1">Memento (<a href="part0015.html#page_283">283</a>) is often used in conjunction with the Iterator pattern. An iterator can use a memento to capture the state of an iteration. The iterator stores the memento internally.</p>
<p class="calibre1"><a id="ch05sec1lev5"></a></p>
<h3 class="calibre2"><a id="page_273" class="calibre3"></a>Object Behavioral: Mediator</h3>
<p class="calibre1"><a id="ch05sec2lev47"></a></p>
<h4 class="calibre15">Intent</h4>
<p class="calibre1">Define an object that encapsulates how a set of objects interact. Mediator promotes loose coupling by keeping objects from referring to each other explicitly, and it lets you vary their interaction independently.</p>
<p class="calibre1"><a id="ch05sec2lev48"></a></p>
<h4 class="calibre15">Motivation</h4>
<p class="calibre1">Object-oriented design encourages the distribution of behavior among objects. Such distribution can result in an object structure with many connections between objects; in the worst case, every object ends up knowing about every other.</p>
<p class="calibre1">Though partitioning a system into many objects generally enhances reusability, proliferating interconnections tend to reduce it again. Lots of interconnections make it less likely that an object can work without the support of others—the system acts as though it were monolithic. Moreover, it can be difficult to change the system’s behavior in any significant way, since behavior is distributed among many objects. As a result, you may be forced to define many subclasses to customize the system’s behavior.</p>
<p class="calibre1">As an example, consider the implementation of dialog boxes in a graphical user interface. A dialog box uses a window to present a collection of widgets such as buttons, menus, and entry fields, as shown here:</p>
<p class="image"><img src="../images/00319.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1"><a id="page_274"></a>Often there are dependencies between the widgets in the dialog. For example, a button gets disabled when a certain entry field is empty. Selecting an entry in a list of choices called a <strong class="calibre4">list box</strong> might change the contents of an entry field. Conversely, typing text into the entry field might automatically select one or more corresponding entries in the list box. Once text appears in the entry field, other buttons may become enabled that let the user do something with the text, such as changing or deleting the thing to which it refers.</p>
<p class="calibre1">Different dialog boxes will have different dependencies between widgets. So even though dialogs display the same kinds of widgets, they can’t simply reuse stock widget classes; they have to be customized to reflect dialog-specific dependencies. Customizing them individually by subclassing will be tedious, since many classes are involved.</p>
<p class="calibre1">You can avoid these problems by encapsulating collective behavior in a separate <strong class="calibre4">mediator</strong> object. A mediator is responsible for controlling and coordinating the interactions of a group of objects. The mediator serves as an intermediary that keeps objects in the group from referring to each other explicitly. The objects only know the mediator, thereby reducing the number of interconnections.</p>
<p class="calibre1">For example, <strong class="calibre4">FontDialogDirector</strong> can be the mediator between the widgets in a dialog box. A FontDialogDirector object knows the widgets in a dialog and coordinates their interaction. It acts as a hub of communication for widgets:</p>
<p class="image"><img src="../images/00320.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">The following interaction diagram illustrates how the objects cooperate to handle a change in a list box’s selection:</p>
<p class="image"><a id="page_275"></a><img src="../images/00321.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">Here’s the succession of events by which a list box’s selection passes to an entry field:</p>
<p class="indenthangingN">1. The list box tells its director that it’s changed.</p>
<p class="indenthangingN">2. The director gets the selection from the list box.</p>
<p class="indenthangingN">3. The director passes the selection to the entry field.</p>
<p class="indenthangingN">4. Now that the entry field contains some text, the director enables button(s) for initiating an action (e.g., “demibold,” “oblique”).</p>
<p class="calibre1">Note how the director mediates between the list box and the entry field. Widgets communicate with each other only indirectly, through the director. They don’t have to know about each other; all they know is the director. Furthermore, because the behavior is localized in one class, it can be changed or replaced by extending or replacing that class.</p>
<p class="calibre1">Here’s how the FontDialogDirector abstraction can be integrated into a class library:</p>
<p class="image"><img src="../images/00322.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1"><a id="page_276"></a>DialogDirector is an abstract class that defines the overall behavior of a dialog. Clients call the ShowDialog operation to display the dialog on the screen. CreateWidgets is an abstract operation for creating the widgets of a dialog. WidgetChanged is another abstract operation; widgets call it to inform their director that they have changed. DialogDirector subclasses override CreateWidgets to create the proper widgets, and they override WidgetChanged to handle the changes.</p>
<p class="calibre1"><a id="ch05sec2lev49"></a></p>
<h4 class="calibre15">Applicability</h4>
<p class="calibre1">Use the Mediator pattern when</p>
<p class="indenthangingB1">• a set of objects communicate in well-defined but complex ways. The resulting interdependencies are unstructured and difficult to understand.</p>
<p class="indenthangingB1">• reusing an object is difficult because it refers to and communicates with many other objects.</p>
<p class="indenthangingB1">• a behavior that’s distributed between several classes should be customizable without a lot of subclassing.</p>
<p class="calibre1"><a id="ch05sec2lev50"></a></p>
<h4 class="calibre15">Structure</h4>
<p class="image"><img src="../images/00323.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">A typical object structure might look like this:</p>
<p class="image"><img src="../images/00324.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1"><a id="ch05sec2lev51"></a></p>
<h4 class="calibre15"><a id="page_277"></a>Participants</h4>
<p class="indenthangingB1">• <strong class="calibre4">Mediator</strong> (DialogDirector)</p>
<p class="indenthangingB2">– defines an interface for communicating with Colleague objects.</p>
<p class="indenthangingB1">• <strong class="calibre4">ConcreteMediator</strong> (FontDialogDirector)</p>
<p class="indenthangingB2">– implements cooperative behavior by coordinating Colleague objects.</p>
<p class="indenthangingB2">– knows and maintains its colleagues.</p>
<p class="indenthangingB1">• <strong class="calibre4">Colleague classes</strong> (ListBox, EntryField)</p>
<p class="indenthangingB2">– each Colleague class knows its Mediator object.</p>
<p class="indenthangingB2">– each colleague communicates with its mediator whenever it would have otherwise communicated with another colleague.</p>
<p class="calibre1"><a id="ch05sec2lev52"></a></p>
<h4 class="calibre15">Collaborations</h4>
<p class="indenthangingB1">• Colleagues send and receive requests from a Mediator object. The mediator implements the cooperative behavior by routing requests between the appropriate colleague(s).</p>
<p class="calibre1"><a id="ch05sec2lev53"></a></p>
<h4 class="calibre15">Consequences</h4>
<p class="calibre1">The Mediator pattern has the following benefits and drawbacks:</p>
<p class="indenthangingN">1. <em class="calibre7">It limits subclassing.</em> A mediator localizes behavior that otherwise would be distributed among several objects. Changing this behavior requires subclassing Mediator only; Colleague classes can be reused as is.</p>
<p class="indenthangingN">2. <em class="calibre7">It decouples colleagues.</em> A mediator promotes loose coupling between colleagues. You can vary and reuse Colleague and Mediator classes independently.</p>
<p class="indenthangingN">3. <em class="calibre7">It simplifies object protocols.</em> A mediator replaces many-to-many interactions with one-to-many interactions between the mediator and its colleagues. One-to-many relationships are easier to understand, maintain, and extend.</p>
<p class="indenthangingN">4. <em class="calibre7">It abstracts how objects cooperate.</em> Making mediation an independent concept and encapsulating it in an object lets you focus on how objects interact apart from their individual behavior. That can help clarify how objects interact in a system.</p>
<p class="indenthangingN">5. <em class="calibre7">It centralizes control.</em> The Mediator pattern trades complexity of interaction for complexity in the mediator. Because a mediator encapsulates protocols, it can become more complex than any individual colleague. This can make the mediator itself a monolith that’s hard to maintain.</p>
<p class="calibre1"><a id="ch05sec2lev54"></a></p>
<h4 class="calibre15"><a id="page_278"></a>Implementation</h4>
<p class="calibre1">The following implementation issues are relevant to the Mediator pattern:</p>
<p class="indenthangingN">1. <em class="calibre7">Omitting the abstract Mediator class.</em> There’s no need to define an abstract Mediator class when colleagues work with only one mediator. The abstract coupling that the Mediator class provides lets colleagues work with different Mediator subclasses, and vice versa.</p>
<p class="indenthangingN">2. <em class="calibre7">Colleague-Mediator communication.</em> Colleagues have to communicate with their mediator when an event of interest occurs. One approach is to implement the Mediator as an Observer using the Observer (<a href="part0015.html#page_293">293</a>) pattern. Colleague classes act as Subjects, sending notifications to the mediator whenever they change state. The mediator responds by propagating the effects of the change to other colleagues.</p>
<p class="indentpara">Another approach defines a specialized notification interface in Mediator that lets colleagues be more direct in their communication. Smalltalk/V for Windows uses a form of delegation: When communicating with the mediator, a colleague passes itself as an argument, allowing the mediator to identify the sender. The Sample Code uses this approach, and the Smalltalk/V implementation is discussed further in the Known Uses.</p>
<p class="calibre1"><a id="ch05sec2lev55"></a></p>
<h4 class="calibre15">Sample Code</h4>
<p class="calibre1">We’ll use a DialogDirector to implement the font dialog box shown in the Motivation. The abstract class <code class="calibre13">DialogDirector</code> defines the interface for directors.</p>
<p class="programlisting"><img src="../images/00325.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1"><code class="calibre13">Widget</code> is the abstract base class for widgets. A widget knows its director.</p>
<p class="programlisting"><img src="../images/00326.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1"><a id="page_279"></a><code class="calibre13">Changed</code> calls the director’s <code class="calibre13">WidgetChanged</code> operation. <code class="calibre13">Widgets</code> call <code class="calibre13">WidgetChanged</code> on their director to inform it of a significant event.</p>
<p class="programlisting"><img src="../images/00327.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">Subclasses of <code class="calibre13">DialogDirector</code> override <code class="calibre13">WidgetChanged</code> to affect the appropriate widgets. The widget passes a reference to itself as an argument to <code class="calibre13">WidgetChanged</code> to let the director identify the widget that changed. <code class="calibre13">DialogDirector</code> subclasses redefine the <code class="calibre13">CreateWidgets</code> pure virtual to construct the widgets in the dialog.</p>
<p class="calibre1">The <code class="calibre13">ListBox</code>, <code class="calibre13">EntryField</code>, and <code class="calibre13">Button</code> are subclasses of <code class="calibre13">Widget</code> for specialized user interface elements. <code class="calibre13">ListBox</code> provides a <code class="calibre13">GetSelection</code> operation to get the current selection, and <code class="calibre13">EntryField</code>’s <code class="calibre13">SetText</code> operation puts new text into the field.</p>
<p class="programlisting"><img src="../images/00328.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1"><code class="calibre13">Button</code> is a simple widget that calls <code class="calibre13">Changed</code> whenever it’s pressed. This gets done in its implementation of <code class="calibre13">HandleMouse</code>:</p>
<p class="programlisting"><a id="page_280"></a><img src="../images/00329.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">The <code class="calibre13">FontDialogDirector</code> class mediates between widgets in the dialog box. <code class="calibre13">FontDialogDirector</code> is a subclass of <code class="calibre13">DialogDirector</code>:</p>
<p class="programlisting"><img src="../images/00330.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1"><code class="calibre13">FontDialogDirector</code> keeps track of the widgets it displays. It redefines <code class="calibre13">CreateWidgets</code> to create the widgets and initialize its references to them:</p>
<p class="programlisting"><img src="../images/00331.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1"><code class="calibre13">WidgetChanged</code> ensures that the widgets work together properly:</p>
<p class="programlisting"><a id="page_281"></a><img src="../images/00332.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">The complexity of <code class="calibre13">WidgetChanged</code> increases proportionally with the complexity of the dialog. Large dialogs are undesirable for other reasons, of course, but mediator complexity might mitigate the pattern’s benefits in other applications.</p>
<p class="calibre1"><a id="ch05sec2lev56"></a></p>
<h4 class="calibre15">Known Uses</h4>
<p class="calibre1">Both ET++ <a href="part0020.html#bib01_089">[WGM88]</a> and the THINK C class library <a href="part0020.html#bib01_082">[Sym93b]</a> use director-like objects in dialogs as mediators between widgets.</p>
<p class="calibre1">The application architecture of Smalltalk/V for Windows is based on a mediator structure <a href="part0020.html#bib01_049">[LaL94]</a>. In that environment, an application consists of a Window containing a set of panes. The library contains several predefined Pane objects; examples include TextPane, ListBox, Button, and so on. These panes can be used without subclassing. An application developer only subclasses from ViewManager, a class that’s responsible for doing inter-pane coordination. ViewManager is the Mediator, and each pane only knows its view manager, which is considered the “owner” of the pane. Panes don’t refer to each other directly.</p>
<p class="calibre1">The following object diagram shows a snapshot of an application at run-time:</p>
<p class="image"><img src="../images/00333.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">Smalltalk/V uses an event mechanism for Pane-ViewManager communication. A pane generates an event when it wants to get information from the mediator or when it wants to inform the mediator that something significant happened. An event defines a symbol (e.g., <code class="calibre13">#select</code>) that identifies the event. To handle the event, the view manager registers a method selector with the pane. This selector is the event’s handler; it will be invoked whenever the event occurs.</p>
<p class="calibre1"><a id="page_282"></a>The following code excerpt shows how a ListPane object gets created inside a ViewManager subclass and how ViewManager registers an event handler for the <code class="calibre13">#select</code> event:</p>
<p class="programlisting"><img src="../images/00334.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">Another application of the Mediator pattern is in coordinating complex updates. An example is the ChangeManager class mentioned in Observer (<a href="part0015.html#page_293">293</a>). Change-Manager mediates between subjects and observers to avoid redundant updates. When an object changes, it notifies the ChangeManager, which in turn coordinates the update by notifying the object’s dependents.</p>
<p class="calibre1">A similar application appears in the Unidraw drawing framework <a href="part0020.html#bib01_086">[VL90]</a> and uses a class called CSolver to enforce connectivity constraints between “connectors.” Objects in graphical editors can appear to stick to one another in different ways. Connectors are useful in applications that maintain connectivity automatically, like diagram editors and circuit design systems. CSolver is a mediator between connectors. It solves the connectivity constraints and updates the connectors’ positions to reflect them.</p>
<p class="calibre1"><a id="ch05sec2lev57"></a></p>
<h4 class="calibre15">Related Patterns</h4>
<p class="calibre1">Facade (<a href="part0014.html#page_185">185</a>) differs from Mediator in that it abstracts a subsystem of objects to provide a more convenient interface. Its protocol is unidirectional; that is, Facade objects make requests of the subsystem classes but not vice versa. In contrast, Mediator enables cooperative behavior that colleague objects don’t or can’t provide, and the protocol is multidirectional.</p>
<p class="calibre1">Colleagues can communicate with the mediator using the Observer (<a href="part0015.html#page_293">293</a>) pattern.</p>
<p class="calibre1"><a id="ch05sec1lev6"></a></p>
<h3 class="calibre2"><a id="page_283" class="calibre3"></a>Object Behavioral: Memento</h3>
<p class="calibre1"><a id="ch05sec2lev58"></a></p>
<h4 class="calibre15">Intent</h4>
<p class="calibre1">Without violating encapsulation, capture and externalize an object’s internal state so that the object can be restored to this state later.</p>
<p class="calibre1"><a id="ch05sec2lev59"></a></p>
<h4 class="calibre15">Also Known As</h4>
<p class="calibre1">Token</p>
<p class="calibre1"><a id="ch05sec2lev60"></a></p>
<h4 class="calibre15">Motivation</h4>
<p class="calibre1">Sometimes it’s necessary to record the internal state of an object. This is required when implementing checkpoints and undo mechanisms that let users back out of tentative operations or recover from errors. You must save state information somewhere so that you can restore objects to their previous states. But objects normally encapsulate some or all of their state, making it inaccessible to other objects and impossible to save externally. Exposing this state would violate encapsulation, which can compromise the application’s reliability and extensibility.</p>
<p class="calibre1">Consider for example a graphical editor that supports connectivity between objects. A user can connect two rectangles with a line, and the rectangles stay connected when the user moves either of them. The editor ensures that the line stretches to maintain the connection.</p>
<p class="image"><img src="../images/00335.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">A well-known way to maintain connectivity relationships between objects is with a constraint-solving system. We can encapsulate this functionality in a <strong class="calibre4">ConstraintSolver</strong> object. ConstraintSolver records connections as they are made and generates mathematical equations that describe them. It solves these equations whenever the user makes a connection or otherwise modifies the diagram. Constraint-Solver uses the results of its calculations to rearrange the graphics so that they maintain the proper connections.</p>
<p class="calibre1">Supporting undo in this application isn’t as easy as it may seem. An obvious way to undo a move operation is to store the original distance moved and move the <a id="page_284"></a>object back an equivalent distance. However, this does not guarantee all objects will appear where they did before. Suppose there is some slack in the connection. In that case, simply moving the rectangle back to its original location won’t necessarily achieve the desired effect.</p>
<p class="image"><img src="../images/00336.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">In general, the ConstraintSolver’s public interface might be insufficient to allow precise reversal of its effects on other objects. The undo mechanism must work more closely with ConstraintSolver to reestablish previous state, but we should also avoid exposing the ConstraintSolver’s internals to the undo mechanism.</p>
<p class="calibre1">We can solve this problem with the Memento pattern. A <strong class="calibre4">memento</strong> is an object that stores a snapshot of the internal state of another object—the memento’s <strong class="calibre4">originator.</strong> The undo mechanism will request a memento from the originator when it needs to checkpoint the originator’s state. The originator initializes the memento with information that characterizes its current state. Only the originator can store and retrieve information from the memento—the memento is “opaque” to other objects.</p>
<p class="calibre1">In the graphical editor example just discussed, the ConstraintSolver can act as an originator. The following sequence of events characterizes the undo process:</p>
<p class="indenthangingN">1. The editor requests a memento from the ConstraintSolver as a side-effect of the move operation.</p>
<p class="indenthangingN">2. The ConstraintSolver creates and returns a memento, an instance of a class SolverState in this case. A SolverState memento contains data structures that describe the current state of the ConstraintSolver’s internal equations and variables.</p>
<p class="indenthangingN">3. Later when the user undoes the move operation, the editor gives the SolverState back to the ConstraintSolver.</p>
<p class="indenthangingN">4. Based on the information in the SolverState, the ConstraintSolver changes its internal structures to return its equations and variables to their exact previous state.</p>
<p class="calibre1">This arrangement lets the ConstraintSolver entrust other objects with the information it needs to revert to a previous state without exposing its internal structure and representations.</p>
<p class="calibre1"><a id="ch05sec2lev61"></a></p>
<h4 class="calibre15"><a id="page_285"></a>Applicability</h4>
<p class="calibre1">Use the Memento pattern when</p>
<p class="indenthangingB1">• a snapshot of (some portion of) an object’s state must be saved so that it can be restored to that state later, <em class="calibre7">and</em></p>
<p class="indenthangingB1">• a direct interface to obtaining the state would expose implementation details and break the object’s encapsulation.</p>
<p class="calibre1"><a id="ch05sec2lev62"></a></p>
<h4 class="calibre15">Structure</h4>
<p class="image"><img src="../images/00337.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1"><a id="ch05sec2lev63"></a></p>
<h4 class="calibre15">Participants</h4>
<p class="indenthangingB1">• <strong class="calibre4">Memento</strong> (SolverState)</p>
<p class="indenthangingB2">– stores internal state of the Originator object. The memento may store as much or as little of the originator’s internal state as necessary at its originator’s discretion.</p>
<p class="indenthangingB2">– protects against access by objects other than the originator. Mementos have effectively two interfaces. Caretaker sees a <em class="calibre7">narrow</em> interface to the Memento—it can only pass the memento to other objects. Originator, in contrast, sees a <em class="calibre7">wide</em> interface, one that lets it access all the data necessary to restore itself to its previous state. Ideally, only the originator that produced the memento would be permitted to access the memento’s internal state.</p>
<p class="indenthangingB1">• <strong class="calibre4">Originator</strong> (ConstraintSolver)</p>
<p class="indenthangingB2">– creates a memento containing a snapshot of its current internal state.</p>
<p class="indenthangingB2">– uses the memento to restore its internal state.</p>
<p class="indenthangingB1">• <strong class="calibre4">Caretaker</strong> (undo mechanism)</p>
<p class="indenthangingB2">– is responsible for the memento’s safekeeping.</p>
<p class="indenthangingB2">– never operates on or examines the contents of a memento.</p>
<p class="calibre1"><a id="ch05sec2lev64"></a></p>
<h4 class="calibre15"><a id="page_286"></a>Collaborations</h4>
<p class="indenthangingB1">• A caretaker requests a memento from an originator, holds it for a time, and passes it back to the originator, as the following interaction diagram illustrates:</p>
<p class="image"><img src="../images/00338.jpeg" alt="image" class="calibre11"/></p>
<p class="indentpara">Sometimes the caretaker won’t pass the memento back to the originator, because the originator might never need to revert to an earlier state.</p>
<p class="indenthangingB1">• Mementos are passive. Only the originator that created a memento will assign or retrieve its state.</p>
<p class="calibre1"><a id="ch05sec2lev65"></a></p>
<h4 class="calibre15">Consequences</h4>
<p class="calibre1">The Memento pattern has several consequences:</p>
<p class="indenthangingN">1. <em class="calibre7">Preserving encapsulation boundaries.</em> Memento avoids exposing information that only an originator should manage but that must be stored nevertheless outside the originator. The pattern shields other objects from potentially complex Originator internals, thereby preserving encapsulation boundaries.</p>
<p class="indenthangingN">2. <em class="calibre7">It simplifies Originator.</em> In other encapsulation-preserving designs, Originator keeps the versions of internal state that clients have requested. That puts all the storage management burden on Originator. Having clients manage the state they ask for simplifies Originator and keeps clients from having to notify originators when they’re done.</p>
<p class="indenthangingN">3. <em class="calibre7">Using mementos might be expensive.</em> Mementos might incur considerable overhead if Originator must copy large amounts of information to store in the memento or if clients create and return mementos to the originator often enough. Unless encapsulating and restoring Originator state is cheap, the pattern might not be appropriate. See the discussion of incrementality in the Implementation section.</p>
<p class="indenthangingN">4. <em class="calibre7">Defining narrow and wide interfaces.</em> It may be difficult in some languages to ensure that only the originator can access the memento’s state.</p>
<p class="indenthangingN">5. <em class="calibre7">Hidden costs in caring for mementos.</em> A caretaker is responsible for deleting the mementos it cares for. However, the caretaker has no idea how much state is <a id="page_287"></a>in the memento. Hence an otherwise lightweight caretaker might incur large storage costs when it stores mementos.</p>
<p class="calibre1"><a id="ch05sec2lev66"></a></p>
<h4 class="calibre15">Implementation</h4>
<p class="calibre1">Here are two issues to consider when implementing the Memento pattern:</p>
<p class="indenthangingN">1. <em class="calibre7">Language support.</em> Mementos have two interfaces: a wide one for originators and a narrow one for other objects. Ideally the implementation language will support two levels of static protection. C++ lets you do this by making the Originator a friend of Memento and making Memento’s wide interface private. Only the narrow interface should be declared public. For example:</p>
<p class="programlisting"><img src="../images/00339.jpeg" alt="image" class="calibre11"/></p>
<p class="indenthangingN">2. <em class="calibre7">Storing incremental changes.</em> When mementos get created and passed back to their originator in a predictable sequence, then Memento can save just the <em class="calibre7">incremental change</em> to the originator’s internal state.</p>
<p class="indentpara">For example, undoable commands in a history list can use mementos to ensure that commands are restored to their exact state when they’re undone (see <a href="part0015.html#ch05sec1lev2">Command</a> (<a href="part0015.html#ch05sec1lev2">233</a>)). The history list defines a specific order in which commands can be undone and redone. That means mementos can store just the incremental change that a command makes rather than the full state of every object they affect. In the Motivation example given earlier, the constraint solver can store only those internal structures that change to keep the line <a id="page_288"></a>connecting the rectangles, as opposed to storing the absolute positions of these objects.</p>
<p class="calibre1"><a id="ch05sec2lev67"></a></p>
<h4 class="calibre15">Sample Code</h4>
<p class="calibre1">The C++ code given here illustrates the ConstraintSolver example discussed earlier. We use MoveCommand objects (see <a href="part0015.html#ch05sec1lev2">Command</a> (<a href="part0015.html#ch05sec1lev2">233</a>)) to (un)do the translation of a graphical object from one position to another. The graphical editor calls the command’s <code class="calibre13">Execute</code> operation to move a graphical object and <code class="calibre13">Unexecute</code> to undo the move. The command stores its target, the distance moved, and an instance of <code class="calibre13">ConstraintSolverMemento</code>, a memento containing state from the constraint solver.</p>
<p class="programlisting"><img src="../images/00340.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">The connection constraints are established by the class <code class="calibre13">ConstraintSolver.</code> Its key member function is <code class="calibre13">Solve</code>, which solves the constraints registered with the <code class="calibre13">AddConstraint</code> operation. To support undo, <code class="calibre13">ConstraintSolver</code>’s state can be externalized with <code class="calibre13">CreateMemento</code> into a <code class="calibre13">ConstraintSolverMemento</code> instance. The constraint solver can be returned to a previous state by calling <code class="calibre13">SetMemento</code>. <code class="calibre13">ConstraintSolver</code> is a Singleton (<a href="part0013.html#page_127">127</a>).</p>
<p class="programlisting"><img src="../images/00341.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1"><a id="page_289"></a>Given these interfaces, we can implement <code class="calibre13">MoveCommand</code> members <code class="calibre13">Execute</code> and <code class="calibre13">Unexecute</code> as follows:</p>
<p class="programlisting2"><img src="../images/00342.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1"><code class="calibre13">Execute</code> acquires a <code class="calibre13">ConstraintSolverMemento</code> memento before it moves the graphic. <code class="calibre13">Unexecute</code> moves the graphic back, sets the constraint solver’s state to the previous state, and finally tells the constraint solver to solve the constraints.</p>
<p class="calibre1"><a id="ch05sec2lev68"></a></p>
<h4 class="calibre15">Known Uses</h4>
<p class="calibre1">The preceding sample code is based on Unidraw’s support for connectivity through its CSolver class <a href="part0020.html#bib01_086">[VL90]</a>.</p>
<p class="calibre1">Collections in Dylan <a href="part0020.html#bib01_005">[App92]</a> provide an iteration interface that reflects the Memento pattern. Dylan’s collections have the notion of a “state” object, which is a memento that represents the state of the iteration. Each collection can represent the current state of the iteration in any way it chooses; the representation is completely hidden from clients. The Dylan iteration approach might be translated to C++ as follows:</p>
<p class="programlisting"><a id="page_290"></a><img src="../images/00343.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1"><code class="calibre13">CreatelnitialState</code> returns an initialized <code class="calibre13">IterationState</code> object for the collection. <code class="calibre13">Next</code> advances the state object to the next position in the iteration; it effectively increments the iteration index. <code class="calibre13">IsDone</code> returns <code class="calibre13">true</code> if <code class="calibre13">Next</code> has advanced beyond the last element in the collection. <code class="calibre13">CurrentItem</code> dereferences the state object and returns the element in the collection to which it refers. <code class="calibre13">Copy</code> returns a copy of the given state object. This is useful for marking a point in an iteration.</p>
<p class="calibre1">Given a class <code class="calibre13">ItemType</code>, we can iterate over a collection of its instances as follows<sup class="calibre8"><a id="ch05fn_07"></a><a href="part0022.html#ch05fn07">7</a></sup>:</p>
<p class="programlisting"><img src="../images/00344.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">The memento-based iteration interface has two interesting benefits:</p>
<p class="indenthangingN">1. More than one state can work on the same collection. (The same is true of the Iterator (<a href="part0015.html#page_257">257</a>) pattern.)</p>
<p class="indenthangingN"><a id="page_291"></a>2. It doesn’t require breaking a collection’s encapsulation to support iteration. The memento is only interpreted by the collection itself; no one else has access to it. Other approaches to iteration require breaking encapsulation by making iterator classes friends of their collection classes (see <a href="part0015.html#ch05sec1lev4">Iterator</a> (<a href="part0015.html#ch05sec1lev4">257</a>)). The situation is reversed in the memento-based implementation: <code class="calibre13">Collection</code> is a friend of the <code class="calibre13">iteratorState</code>.</p>
<p class="calibre1">The QOCA constraint-solving toolkit stores incremental information in mementos <a href="part0020.html#bib01_036">[HHMV92]</a>. Clients can obtain a memento that characterizes the current solution to a system of constraints. The memento contains only those constraint variables that have changed since the last solution. Usually only a small subset of the solver’s variables changes for each new solution. This subset is enough to return the solver to the preceding solution; reverting to earlier solutions requires restoring mementos from the intervening solutions. Hence you can’t set mementos in any order; QOCA relies on a history mechanism to revert to earlier solutions.</p>
<p class="calibre1"><a id="ch05sec2lev69"></a></p>
<h4 class="calibre15">Related Patterns</h4>
<p class="calibre1">Command (<a href="part0015.html#page_233">233</a>): Commands can use mementos to maintain state for undoable operations.</p>
<p class="calibre1">Iterator (<a href="part0015.html#page_257">257</a>): Mementos can be used for iteration as described earlier.</p>
<p class="calibre1"><a id="ch05sec1lev7"></a></p>
<h3 class="calibre2"><a id="page_293" class="calibre3"></a>Object Behavioral: Observer</h3>
<p class="calibre1"><a id="ch05sec2lev70"></a></p>
<h4 class="calibre15">Intent</h4>
<p class="calibre1">Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.</p>
<p class="calibre1"><a id="ch05sec2lev71"></a></p>
<h4 class="calibre15">Also Known As</h4>
<p class="calibre1">Dependents, Publish-Subscribe</p>
<p class="calibre1"><a id="ch05sec2lev72"></a></p>
<h4 class="calibre15">Motivation</h4>
<p class="calibre1">A common side-effect of partitioning a system into a collection of cooperating classes is the need to maintain consistency between related objects. You don’t want to achieve consistency by making the classes tightly coupled, because that reduces their reusability.</p>
<p class="calibre1">For example, many graphical user interface toolkits separate the presentational aspects of the user interface from the underlying application data [<a href="part0020.html#bib01_048">KP88</a>, <a href="part0020.html#bib01_058">LVC89</a>, <a href="part0020.html#bib01_065">P<sup class="calibre8">+</sup>88</a>, <a href="part0020.html#bib01_089">WGM88</a>]. Classes defining application data and presentations can be reused independently. They can work together, too. Both a spreadsheet object and bar chart object can depict information in the same application data object using different presentations. The spreadsheet and the bar chart don’t know about each other, thereby letting you reuse only the one you need. But they <em class="calibre7">behave</em> as though they do. When the user changes the information in the spreadsheet, the bar chart reflects the changes immediately, and vice versa.</p>
<p class="image"><img src="../images/00345.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1"><a id="page_294"></a>This behavior implies that the spreadsheet and bar chart are dependent on the data object and therefore should be notified of any change in its state. And there’s no reason to limit the number of dependent objects to two; there may be any number of different user interfaces to the same data.</p>
<p class="calibre1">The Observer pattern describes how to establish these relationships. The key objects in this pattern are <strong class="calibre4">subject</strong> and <strong class="calibre4">observer</strong>. A subject may have any number of dependent observers. All observers are notified whenever the subject undergoes a change in state. In response, each observer will query the subject to synchronize its state with the subject’s state.</p>
<p class="calibre1">This kind of interaction is also known as <strong class="calibre4">publish-subscribe</strong>. The subject is the publisher of notifications. It sends out these notifications without having to know who its observers are. Any number of observers can subscribe to receive notifications.</p>
<p class="calibre1"><a id="ch05sec2lev73"></a></p>
<h4 class="calibre15">Applicability</h4>
<p class="calibre1">Use the Observer pattern in any of the following situations:</p>
<p class="indenthangingB1">• When an abstraction has two aspects, one dependent on the other. Encapsulating these aspects in separate objects lets you vary and reuse them independently.</p>
<p class="indenthangingB1">• When a change to one object requires changing others, and you don’t know how many objects need to be changed.</p>
<p class="indenthangingB1">• When an object should be able to notify other objects without making assumptions about who these objects are. In other words, you don’t want these objects tightly coupled.</p>
<p class="calibre1"><a id="ch05sec2lev74"></a></p>
<h4 class="calibre15">Structure</h4>
<p class="image"><img src="../images/00346.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1"><a id="ch05sec2lev75"></a></p>
<h4 class="calibre15"><a id="page_295"></a>Participants</h4>
<p class="indenthangingB1">• <strong class="calibre4">Subject</strong></p>
<p class="indenthangingB2">– knows its observers. Any number of Observer objects may observe a subject.</p>
<p class="indenthangingB2">– provides an interface for attaching and detaching Observer objects.</p>
<p class="indenthangingB1">• <strong class="calibre4">Observer</strong></p>
<p class="indenthangingB2">– defines an updating interface for objects that should be notified of changes in a subject.</p>
<p class="indenthangingB1">• <strong class="calibre4">ConcreteSubject</strong></p>
<p class="indenthangingB2">– stores state of interest to ConcreteObserver objects.</p>
<p class="indenthangingB2">– sends a notification to its observers when its state changes.</p>
<p class="indenthangingB1">• <strong class="calibre4">ConcreteObserver</strong></p>
<p class="indenthangingB2">– maintains a reference to a ConcreteSubject object.</p>
<p class="indenthangingB2">– stores state that should stay consistent with the subject’s.</p>
<p class="indenthangingB2">– implements the Observer updating interface to keep its state consistent with the subject’s.</p>
<p class="calibre1"><a id="ch05sec2lev76"></a></p>
<h4 class="calibre15">Collaborations</h4>
<p class="indenthangingB1">• ConcreteSubject notifies its observers whenever a change occurs that could make its observers’ state inconsistent with its own.</p>
<p class="indenthangingB1">• After being informed of a change in the concrete subject, a ConcreteObserver object may query the subject for information. ConcreteObserver uses this information to reconcile its state with that of the subject.</p>
<p class="indentpara">The following interaction diagram illustrates the collaborations between a subject and two observers:</p>
<p class="image"><img src="../images/00347.jpeg" alt="image" class="calibre11"/></p>
<p class="indentpara"><a id="page_296"></a>Note how the Observer object that initiates the change request postpones its update until it gets a notification from the subject. Notify is not always called by the subject. It can be called by an observer or by another kind of object entirely. The Implementation section discusses some common variations.</p>
<p class="calibre1"><a id="ch05sec2lev77"></a></p>
<h4 class="calibre15">Consequences</h4>
<p class="calibre1">The Observer pattern lets you vary subjects and observers independently. You can reuse subjects without reusing their observers, and vice versa. It lets you add observers without modifying the subject or other observers.</p>
<p class="calibre1">Further benefits and liabilities of the Observer pattern include the following:</p>
<p class="indenthangingN">1. <em class="calibre7">Abstract coupling between Subject and Observer.</em> All a subject knows is that it has a list of observers, each conforming to the simple interface of the abstract Observer class. The subject doesn’t know the concrete class of any observer. Thus the coupling between subjects and observers is abstract and minimal.</p>
<p class="indentpara">Because Subject and Observer aren’t tightly coupled, they can belong to different layers of abstraction in a system. A lower-level subject can communicate and inform a higher-level observer, thereby keeping the system’s layering intact. If Subject and Observer are lumped together, then the resulting object must either span two layers (and violate the layering), or it must be forced to live in one layer or the other (which might compromise the layering abstraction).</p>
<p class="indenthangingN">2. <em class="calibre7">Support for broadcast communication.</em> Unlike an ordinary request, the notification that a subject sends needn’t specify its receiver. The notification is broadcast automatically to all interested objects that subscribed to it. The subject doesn’t care how many interested objects exist; its only responsibility is to notify its observers. This gives you the freedom to add and remove observers at any time. It’s up to the observer to handle or ignore a notification.</p>
<p class="indenthangingN">3. <em class="calibre7">Unexpected updates.</em> Because observers have no knowledge of each other’s presence, they can be blind to the ultimate cost of changing the subject. A seemingly innocuous operation on the subject may cause a cascade of updates to observers and their dependent objects. Moreover, dependency criteria that aren’t well-defined or maintained usually lead to spurious updates, which can be hard to track down.</p>
<p class="indentpara">This problem is aggravated by the fact that the simple update protocol provides no details on <em class="calibre7">what</em> changed in the subject. Without additional protocol to help observers discover what changed, they may be forced to work hard to deduce the changes.</p>
<p class="calibre1"><a id="ch05sec2lev78"></a></p>
<h4 class="calibre15">Implementation</h4>
<p class="calibre1">Several issues related to the implementation of the dependency mechanism are discussed in this section.</p>
<p class="indenthangingN"><a id="page_297"></a>1. <em class="calibre7">Mapping subjects to their observers.</em> The simplest way for a subject to keep track of the observers it should notify is to store references to them explicitly in the subject. However, such storage may be too expensive when there are many subjects and few observers. One solution is to trade space for time by using an associative look-up (e.g., a hash table) to maintain the subject-to-observer mapping. Thus a subject with no observers does not incur storage overhead. On the other hand, this approach increases the cost of accessing the observers.</p>
<p class="indenthangingN">2. <em class="calibre7">Observing more than one subject.</em> It might make sense in some situations for an observer to depend on more than one subject. For example, a spreadsheet may depend on more than one data source. It’s necessary to extend the Update interface in such cases to let the observer know <em class="calibre7">which</em> subject is sending the notification. The subject can simply pass itself as a parameter in the Update operation, thereby letting the observer know which subject to examine.</p>
<p class="indenthangingN">3. <em class="calibre7">Who triggers the update?</em> The subject and its observers rely on the notification mechanism to stay consistent. But what object actually calls Notify to trigger the update? Here are two options:</p>
<p class="indenthangingN1">(a) Have state-setting operations on Subject call Notify after they change the subject’s state. The advantage of this approach is that clients don’t have to remember to call Notify on the subject. The disadvantage is that several consecutive operations will cause several consecutive updates, which may be inefficient.</p>
<p class="indenthangingN1">(b) Make clients responsible for calling Notify at the right time. The advantage here is that the client can wait to trigger the update until after a series of state changes has been made, thereby avoiding needless intermediate updates. The disadvantage is that clients have an added responsibility to trigger the update. That makes errors more likely, since clients might forget to call Notify.</p>
<p class="indenthangingN">4. <em class="calibre7">Dangling references to deleted subjects.</em> Deleting a subject should not produce dangling references in its observers. One way to avoid dangling references is to make the subject notify its observers as it is deleted so that they can reset their reference to it. In general, simply deleting the observers is not an option, because other objects may reference them, or they may be observing other subjects as well.</p>
<p class="indenthangingN">5. <em class="calibre7">Making sure Subject state is self-consistent before notification.</em> It’s important to make sure Subject state is self-consistent before calling Notify, because observers query the subject for its current state in the course of updating their own state.</p>
<p class="indentpara">This self-consistency rule is easy to violate unintentionally when Subject subclass operations call inherited operations. For example, the notification in <a id="page_298"></a>the following code sequence is trigged when the subject is in an inconsistent state:</p>
<p class="programlisting2"><img src="../images/00348.jpeg" alt="image" class="calibre11"/></p>
<p class="indentpara">You can avoid this pitfall by sending notifications from template methods (Template Method (<a href="part0015.html#page_325">325</a>)) in abstract Subject classes. Define a primitive operation for subclasses to override, and make Notify the last operation in the template method, which will ensure that the object is self-consistent when subclasses override Subject operations.</p>
<p class="programlisting2"><img src="../images/00349.jpeg" alt="image" class="calibre11"/></p>
<p class="indentpara">By the way, it’s always a good idea to document which Subject operations trigger notifications.</p>
<p class="indenthangingN">6. <em class="calibre7">Avoiding observer-specific update protocols: the push and pull models.</em> Implementations of the Observer pattern often have the subject broadcast additional information about the change. The subject passes this information as an argument to Update. The amount of information may vary widely.</p>
<p class="indentpara">At one extreme, which we call the <strong class="calibre4">push model,</strong> the subject sends observers detailed information about the change, whether they want it or not. At the other extreme is the <strong class="calibre4">pull model;</strong> the subject sends nothing but the most minimal notification, and observers ask for details explicitly thereafter.</p>
<p class="indentpara">The pull model emphasizes the subject’s ignorance of its observers, whereas the push model assumes subjects know something about their observers’ needs. The push model might make observers less reusable, because Subject classes make assumptions about Observer classes that might not always be true. On the other hand, the pull model may be inefficient, because Observer classes must ascertain what changed without help from the Subject.</p>
<p class="indenthangingN">7. <em class="calibre7">Specifying modifications of interest explicitly.</em> You can improve update efficiency by extending the subject’s registration interface to allow registering observers only for specific events of interest. When such an event occurs, the subject informs only those observers that have registered interest in that event. One way to support this uses the notion of <strong class="calibre4">aspects</strong> for Subject objects. To register interest in particular events, observers are attached to their subjects using</p>
<p class="programlisting2"><img src="../images/00350.jpeg" alt="image" class="calibre11"/></p>
<p class="indentpara"><a id="page_299"></a>where <code class="calibre13">interest</code> specifies the event of interest. At notification time, the subject supplies the changed aspect to its observers as a parameter to the Update operation. For example:</p>
<p class="programlisting2"><img src="../images/00351.jpeg" alt="image" class="calibre11"/></p>
<p class="indenthangingN">8. <em class="calibre7">Encapsulating complex update semantics.</em> When the dependency relationship between subjects and observers is particularly complex, an object that maintains these relationships might be required. We call such an object a <strong class="calibre4">Change-Manager.</strong> Its purpose is to minimize the work required to make observers reflect a change in their subject. For example, if an operation involves changes to several interdependent subjects, you might have to ensure that their observers are notified only after <em class="calibre7">all</em> the subjects have been modified to avoid notifying observers more than once.</p>
<p class="indentpara">ChangeManager has three responsibilities:</p>
<p class="indenthangingN1">(a) It maps a subject to its observers and provides an interface to maintain this mapping. This eliminates the need for subjects to maintain references to their observers and vice versa.</p>
<p class="indenthangingN1">(b) It defines a particular update strategy.</p>
<p class="indenthangingN1">(c) It updates all dependent observers at the request of a subject.</p>
<p class="indentpara">The following diagram depicts a simple ChangeManager-based implementation of the Observer pattern. There are two specialized ChangeManagers. SimpleChangeManager is naive in that it always updates all observers of each subject. In contrast, DAGChangeManager handles directed-acyclic graphs of dependencies between subjects and their observers. A DAGChangeManager is preferable to a SimpleChangeManager when an observer observes more than one subject. In that case, a change in two or more subjects might cause redundant updates. The DAGChangeManager ensures the observer receives just one update. SimpleChangeManager is fine when multiple updates aren’t an issue.</p>
<p class="image"><a id="page_300"></a><img src="../images/00352.jpeg" alt="image" class="calibre11"/></p>
<p class="indentpara">ChangeManager is an instance of the Mediator (<a href="part0015.html#page_273">273</a>) pattern. In general there is only one ChangeManager, and it is known globally. The Singleton (<a href="part0013.html#page_127">127</a>) pattern would be useful here.</p>
<p class="indenthangingN">9. <em class="calibre7">Combining the Subject and Observer classes.</em> Class libraries written in languages that lack multiple inheritance (like Smalltalk) generally don’t define separate Subject and Observer classes but combine their interfaces in one class. That lets you define an object that acts as both a subject and an observer without multiple inheritance. In Smalltalk, for example, the Subject and Observer interfaces are defined in the root class Object, making them available to all classes.</p>
<p class="calibre1"><a id="ch05sec2lev79"></a></p>
<h4 class="calibre15">Sample Code</h4>
<p class="calibre1">An abstract class defines the Observer interface:</p>
<p class="programlisting"><img src="../images/00353.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">This implementation supports multiple subjects for each observer. The subject passed to the Update operation lets the observer determine which subject changed when it observes more than one.</p>
<p class="calibre1">Similarly, an abstract class defines the Subject interface:</p>
<p class="programlisting"><a id="page_301"></a><img src="../images/00354.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1"><code class="calibre13">ClockTimer</code> is a concrete subject for storing and maintaining the time of day. It notifies its observers every second. <code class="calibre13">ClockTimer</code> provides the interface for retrieving individual time units such as the hour, minute, and second.</p>
<p class="programlisting"><img src="../images/00355.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">The <code class="calibre13">Tick</code> operation gets called by an internal timer at regular intervals to provide an accurate time base. <code class="calibre13">Tick</code> updates the <code class="calibre13">ClockTimer</code>’s internal state and calls <code class="calibre13">Notify</code> to inform observers of the change:</p>
<p class="programlisting"><img src="../images/00356.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1"><a id="page_302"></a>Now we can define a class <code class="calibre13">DigitalClock</code> that displays the time. It inherits its graphical functionality from a <code class="calibre13">Widget</code> class provided by a user interface toolkit. The Observer interface is mixed into the <code class="calibre13">DigitalClock</code> interface by inheriting from <code class="calibre13">Observer</code>.</p>
<p class="programlisting"><img src="../images/00357.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">Before the <code class="calibre13">Update</code> operation draws the clock face, it checks to make sure the notifying subject is the clock’s subject:</p>
<p class="programlisting"><img src="../images/00358.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">An <code class="calibre13">AnalogClock</code> class can be defined in the same way.</p>
<p class="programlisting"><a id="page_303"></a><img src="../images/00359.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">The following code creates an <code class="calibre13">AnalogClock</code> and a <code class="calibre13">DigitalClock</code> that always show the same time:</p>
<p class="programlisting"><img src="../images/00360.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">Whenever the <code class="calibre13">timer</code> ticks, the two clocks will be updated and will redisplay themselves appropriately.</p>
<p class="calibre1"><a id="ch05sec2lev80"></a></p>
<h4 class="calibre15">Known Uses</h4>
<p class="calibre1">The first and perhaps best-known example of the Observer pattern appears in Smalltalk Model/View/Controller (MVC), the user interface framework in the Smalltalk environment <a href="part0020.html#bib01_048">[KP88]</a>. MVC’s Model class plays the role of Subject, while View is the base class for observers. Smalltalk, ET++ <a href="part0020.html#bib01_089">[WGM88]</a>, and the THINK class library <a href="part0020.html#bib01_082">[Sym93b]</a> provide a general dependency mechanism by putting Subject and Observer interfaces in the parent class for all other classes in the system.</p>
<p class="calibre1">Other user interface toolkits that employ this pattern are Interviews <a href="part0020.html#bib01_058">[LVC89]</a>, the Andrew Toolkit <a href="part0020.html#bib01_065">[P+88]</a>, and Unidraw <a href="part0020.html#bib01_086">[VL90]</a>. Interviews defines Observer and Observable (for subjects) classes explicitly. Andrew calls them “view” and “data object,” respectively. Unidraw splits graphical editor objects into View (for observers) and Subject parts.</p>
<p class="calibre1"><a id="ch05sec2lev81"></a></p>
<h4 class="calibre15">Related Patterns</h4>
<p class="calibre1">Mediator (<a href="part0015.html#page_273">273</a>): By encapsulating complex update semantics, the ChangeManager acts as mediator between subjects and observers.</p>
<p class="calibre1">Singleton (<a href="part0013.html#page_127">127</a>): The ChangeManager may use the Singleton pattern to make it unique and globally accessible.</p>
<p class="calibre1"><a id="ch05sec1lev8"></a></p>
<h3 class="calibre2"><a id="page_305" class="calibre3"></a>Object Behavioral: State</h3>
<p class="calibre1"><a id="ch05sec2lev82"></a></p>
<h4 class="calibre15">Intent</h4>
<p class="calibre1">Allow an object to alter its behavior when its internal state changes. The object will appear to change its class.</p>
<p class="calibre1"><a id="ch05sec2lev83"></a></p>
<h4 class="calibre15">Also Known As</h4>
<p class="calibre1">Objects for States</p>
<p class="calibre1"><a id="ch05sec2lev84"></a></p>
<h4 class="calibre15">Motivation</h4>
<p class="calibre1">Consider a class TCPConnection that represents a network connection. A TCP-Connection object can be in one of several different states: Established, Listening, Closed. When a TCPConnection object receives requests from other objects, it responds differently depending on its current state. For example, the effect of an Open request depends on whether the connection is in its Closed state or its Established state. The State pattern describes how TCPConnection can exhibit different behavior in each state.</p>
<p class="calibre1">The key idea in this pattern is to introduce an abstract class called TCPState to represent the states of the network connection. The TCPState class declares an interface common to all classes that represent different operational states. Subclasses of TCPState implement state-specific behavior. For example, the classes TCPEstablished and TCPClosed implement behavior particular to the Established and Closed states of TCPConnection.</p>
<p class="image"><img src="../images/00361.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">The class TCPConnection maintains a state object (an instance of a subclass of TCPState) that represents the current state of the TCP connection. The class TCP-Connection <a id="page_306"></a>delegates all state-specific requests to this state object. TCPConnection uses its TCPState subclass instance to perform operations particular to the state of the connection.</p>
<p class="calibre1">Whenever the connection changes state, the TCPConnection object changes the state object it uses. When the connection goes from established to closed, for example, TCPConnection will replace its TCPEstablished instance with a TCPClosed instance.</p>
<p class="calibre1"><a id="ch05sec2lev85"></a></p>
<h4 class="calibre15">Applicability</h4>
<p class="calibre1">Use the State pattern in either of the following cases:</p>
<p class="indenthangingB1">• An object’s behavior depends on its state, and it must change its behavior at run-time depending on that state.</p>
<p class="indenthangingB1">• Operations have large, multipart conditional statements that depend on the object’s state. This state is usually represented by one or more enumerated constants. Often, several operations will contain this same conditional structure. The State pattern puts each branch of the conditional in a separate class. This lets you treat the object’s state as an object in its own right that can vary independently from other objects.</p>
<p class="calibre1"><a id="ch05sec2lev86"></a></p>
<h4 class="calibre15">Structure</h4>
<p class="image"><img src="../images/00362.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1"><a id="ch05sec2lev87"></a></p>
<h4 class="calibre15">Participants</h4>
<p class="indenthangingB1">• <strong class="calibre4">Context (TCPConnection)</strong></p>
<p class="indenthangingB2">– defines the interface of interest to clients.</p>
<p class="indenthangingB2">– maintains an instance of a ConcreteState subclass that defines the current state.</p>
<p class="indenthangingB1">• <strong class="calibre4">State (TCPState)</strong></p>
<p class="indenthangingB2">– defines an interface for encapsulating the behavior associated with a particular state of the Context.</p>
<p class="indenthangingB1"><a id="page_307"></a>• <strong class="calibre4">ConcreteState subclasses</strong> (TCPEstablished, TCPListen, TCPClosed)</p>
<p class="indenthangingB2">– each subclass implements a behavior associated with a state of the Context.</p>
<p class="calibre1"><a id="ch05sec2lev88"></a></p>
<h4 class="calibre15">Collaborations</h4>
<p class="indenthangingB1">• Context delegates state-specific requests to the current ConcreteState object.</p>
<p class="indenthangingB1">• A context may pass itself as an argument to the State object handling the request. This lets the State object access the context if necessary.</p>
<p class="indenthangingB1">• Context is the primary interface for clients. Clients can configure a context with State objects. Once a context is configured, its clients don’t have to deal with the State objects directly.</p>
<p class="indenthangingB1">• Either Context or the ConcreteState subclasses can decide which state succeeds another and under what circumstances.</p>
<p class="calibre1"><a id="ch05sec2lev89"></a></p>
<h4 class="calibre15">Consequences</h4>
<p class="calibre1">The State pattern has the following consequences:</p>
<p class="indenthangingN">1. <em class="calibre7">It localizes state-specific behavior and partitions behavior for different states.</em> The State pattern puts all behavior associated with a particular state into one object. Because all state-specific code lives in a State subclass, new states and transitions can be added easily by defining new subclasses.</p>
<p class="indentpara">An alternative is to use data values to define internal states and have Context operations check the data explicitly. But then we’d have look-alike conditional or case statements scattered throughout Context’s implementation. Adding a new state could require changing several operations, which complicates maintenance.</p>
<p class="indentpara">The State pattern avoids this problem but might introduce another, because the pattern distributes behavior for different states across several State subclasses. This increases the number of classes and is less compact than a single class. But such distribution is actually good if there are many states, which would otherwise necessitate large conditional statements.</p>
<p class="indentpara">Like long procedures, large conditional statements are undesirable. They’re monolithic and tend to make the code less explicit, which in turn makes them difficult to modify and extend. The State pattern offers a better way to structure state-specific code. The logic that determines the state transitions doesn’t reside in monolithic <code class="calibre13">if</code> or <code class="calibre13">switch</code> statements but instead is partitioned between the State subclasses. Encapsulating each state transition and action in a class elevates the idea of an execution state to full object status. That imposes structure on the code and makes its intent clearer.</p>
<p class="indenthangingN">2. <em class="calibre7">It makes state transitions explicit.</em> When an object defines its current state solely in terms of internal data values, its state transitions have no explicit representation; they only show up as assignments to some variables. Introducing separate objects for different states makes the transitions more explicit.</p>
<p class="indentpara"><a id="page_308"></a>Also, State objects can protect the Context from inconsistent internal states, because state transitions are atomic from the Context’s perspective—they happen by rebinding <em class="calibre7">one</em> variable (the Context’s State object variable), not several <a href="part0020.html#bib01_024">[dCLF93]</a>.</p>
<p class="indenthangingN">3. <em class="calibre7">State objects can be shared.</em> If State objects have no instance variables—that is, the state they represent is encoded entirely in their type—then contexts can share a State object. When states are shared in this way, they are essentially flyweights (see <a href="part0014.html#ch04sec1lev6">Flyweight</a> (<a href="part0014.html#ch04sec1lev6">195</a>)) with no intrinsic state, only behavior.</p>
<p class="calibre1"><a id="ch05sec2lev90"></a></p>
<h4 class="calibre15">Implementation</h4>
<p class="calibre1">The State pattern raises a variety of implementation issues:</p>
<p class="indenthangingN">1. <em class="calibre7">Who defines the state transitions?</em> The State pattern does not specify which participant defines the criteria for state transitions. If the criteria are fixed, then they can be implemented entirely in the Context. It is generally more flexible and appropriate, however, to let the State subclasses themselves specify their successor state and when to make the transition. This requires adding an interface to the Context that lets State objects set the Context’s current state explicitly.</p>
<p class="indentpara">Decentralizing the transition logic in this way makes it easy to modify or extend the logic by defining new State subclasses. A disadvantage of decentralization is that one State subclass will have knowledge of at least one other, which introduces implementation dependencies between subclasses.</p>
<p class="indenthangingN">2. <em class="calibre7">A table-based alternative.</em> In C++ <em class="calibre7">Programming Style</em> <a href="part0020.html#bib01_016">[Car92]</a>, Cargill describes another way to impose structure on state-driven code: He uses tables to map inputs to state transitions. For each state, a table maps every possible input to a succeeding state. In effect, this approach converts conditional code (and virtual functions, in the case of the State pattern) into a table look-up.</p>
<p class="indentpara">The main advantage of tables is their regularity: You can change the transition criteria by modifying data instead of changing program code. There are some disadvantages, however:</p>
<p class="indenthangingB2">• A table look-up is often less efficient than a (virtual) function call.</p>
<p class="indenthangingB2">• Putting transition logic into a uniform, tabular format makes the transition criteria less explicit and therefore harder to understand.</p>
<p class="indenthangingB2">• It’s usually difficult to add actions to accompany the state transitions. The table-driven approach captures the states and their transitions, but it must be augmented to perform arbitrary computation on each transition.</p>
<p class="indentpara">The key difference between table-driven state machines and the State pattern can be summed up like this: The State pattern models state-specific behavior, whereas the table-driven approach focuses on defining state transitions.</p>
<p class="indenthangingN"><a id="page_309"></a>3. <em class="calibre7">Creating and destroying State objects.</em> A common implementation trade-off worth considering is whether (1) to create State objects only when they are needed and destroy them thereafter versus (2) creating them ahead of time and never destroying them.</p>
<p class="indentpara">The first choice is preferable when the states that will be entered aren’t known at run-time, <em class="calibre7">and</em> contexts change state infrequently. This approach avoids creating objects that won’t be used, which is important if the State objects store a lot of information. The second approach is better when state changes occur rapidly, in which case you want to avoid destroying states, because they may be needed again shortly. Instantiation costs are paid once up-front, and there are no destruction costs at all. This approach might be inconvenient, though, because the Context must keep references to all states that might be entered.</p>
<p class="indenthangingN">4. <em class="calibre7">Using dynamic inheritance.</em> Changing the behavior for a particular request could be accomplished by changing the object’s class at run-time, but this is not possible in most object-oriented programming languages. Exceptions include Self <a href="part0020.html#bib01_084">[US87]</a> and other delegation-based languages that provide such a mechanism and hence support the State pattern directly. Objects in Self can delegate operations to other objects to achieve a form of dynamic inheritance. Changing the delegation target at run-time effectively changes the inheritance structure. This mechanism lets objects change their behavior and amounts to changing their class.</p>
<p class="calibre1"><a id="ch05sec2lev91"></a></p>
<h4 class="calibre15">Sample Code</h4>
<p class="calibre1">The following example gives the C++ code for the TCP connection example described in the Motivation section. This example is a simplified version of the TCP protocol; it doesn’t describe the complete protocol or all the states of TCP connections.<sup class="calibre8"><a id="ch05fn_08"></a><a href="part0022.html#ch05fn08">8</a></sup></p>
<p class="calibre1">First, we define the class <code class="calibre13">TCPConnection</code>, which provides an interface for transmitting data and handles requests to change state.</p>
<p class="programlisting"><img src="../images/00363.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1"><a id="page_310"></a><code class="calibre13">TCPConnection</code> keeps an instance of the <code class="calibre13">TCPState</code> class in the <code class="calibre13">_state</code> member variable. The class <code class="calibre13">TCPState</code> duplicates the state-changing interface of <code class="calibre13">TCPConnection</code>. Each <code class="calibre13">TCPState</code> operation takes a <code class="calibre13">TCPConnection</code> instance as a parameter, letting <code class="calibre13">TCPState</code> access data from <code class="calibre13">TCPConnection</code> and change the connection’s state.</p>
<p class="programlisting"><img src="../images/00364.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1"><code class="calibre13">TCPConnection</code> delegates all state-specific requests to its <code class="calibre13">TCPState</code> instance <code class="calibre13">_state. TCPConnection</code> also provides an operation for changing this variable to a new <code class="calibre13">TCPState</code>. The constructor for <code class="calibre13">TCPConnection</code> initializes the object to the <code class="calibre13">TCPClosed</code> state (defined later).</p>
<p class="programlisting"><img src="../images/00365.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1"><a id="page_311"></a><code class="calibre13">TCPState</code> implements default behavior for all requests delegated to it. It can also change the state of a <code class="calibre13">TCPConnection</code> with the <code class="calibre13">ChangeState</code> operation. <code class="calibre13">TCPState</code> is declared a friend of <code class="calibre13">TCPConnection</code> to give it privileged access to this operation.</p>
<p class="programlisting"><img src="../images/00366.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">Subclasses of <code class="calibre13">TCPState</code> implement state-specific behavior. A TCP connection can be in many states: Established, Listening, Closed, etc., and there’s a subclass of <code class="calibre13">TCPState</code> for each state. We’ll discuss three subclasses in detail: <code class="calibre13">TCPEstablished</code>, <code class="calibre13">TCPListen</code>, and <code class="calibre13">TCPClosed</code>.</p>
<p class="programlisting"><img src="../images/00367.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1"><a id="page_312"></a><code class="calibre13">TCPState</code> subclasses maintain no local state, so they can be shared, and only one instance of each is required. The unique instance of each <code class="calibre13">TCPState</code> subclass is obtained by the static <code class="calibre13">Instance</code> operation.<sup class="calibre8"><a id="ch05fn_09"></a><a href="part0022.html#ch05fn09">9</a></sup></p>
<p class="calibre1">Each <code class="calibre13">TCPState</code> subclass implements state-specific behavior for valid requests in the state:</p>
<p class="programlisting"><img src="../images/00368.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">After performing state-specific work, these operations call the <code class="calibre13">ChangeState</code> operation to change the state of the <code class="calibre13">TCPConnection</code>. <code class="calibre13">TCPConnection</code> itself doesn’t know a thing about the TCP connection protocol; it’s the <code class="calibre13">TCPState</code> subclasses that define each state transition and action in TCP.</p>
<p class="calibre1"><a id="ch05sec2lev92"></a></p>
<h4 class="calibre15"><a id="page_313"></a>Known Uses</h4>
<p class="calibre1">Johnson and Zweig <a href="part0020.html#bib01_043">[JZ91]</a> characterize the State pattern and its application to TCP connection protocols.</p>
<p class="calibre1">Most popular interactive drawing programs provide “tools” for performing operations by direct manipulation. For example, a line-drawing tool lets a user click and drag to create a new line. A selection tool lets the user select shapes. There’s usually a palette of such tools to choose from. The user thinks of this activity as picking up a tool and wielding it, but in reality the editor’s behavior changes with the current tool: When a drawing tool is active we create shapes; when the selection tool is active we select shapes; and so forth. We can use the State pattern to change the editor’s behavior depending on the current tool.</p>
<p class="calibre1">We can define an abstract Tool class from which to define subclasses that implement tool-specific behavior. The drawing editor maintains a current Tool object and delegates requests to it. It replaces this object when the user chooses a new tool, causing the behavior of the drawing editor to change accordingly.</p>
<p class="calibre1">This technique is used in both the HotDraw <a href="part0020.html#bib01_042">[Joh92]</a> and Unidraw <a href="part0020.html#bib01_086">[VL90]</a> drawing editor frameworks. It allows clients to define new kinds of tools easily. In HotDraw, the DrawingController class forwards the requests to the current Tool object. In Unidraw, the corresponding classes are Viewer and Tool. The following class diagram sketches the Tool and DrawingController interfaces:</p>
<p class="image"><img src="../images/00369.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">Coplien’s Envelope-Letter idiom <a href="part0020.html#bib01_022">[Cop92]</a> is related to State. Envelope-Letter is a technique for changing an object’s class at run-time. The State pattern is more specific, focusing on how to deal with an object whose behavior depends on its state.</p>
<p class="calibre1"><a id="ch05sec2lev93"></a></p>
<h4 class="calibre15">Related Patterns</h4>
<p class="calibre1">The Flyweight (<a href="part0014.html#page_195">195</a>) pattern explains when and how State objects can be shared.</p>
<p class="calibre1">State objects are often Singletons (<a href="part0013.html#page_127">127</a>).</p>
<p class="calibre1"><a id="ch05sec1lev9"></a></p>
<h3 class="calibre2"><a id="page_315" class="calibre3"></a>Object Behavioral: Strategy</h3>
<p class="calibre1"><a id="ch05sec2lev94"></a></p>
<h4 class="calibre15">Intent</h4>
<p class="calibre1">Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it.</p>
<p class="calibre1"><a id="ch05sec2lev95"></a></p>
<h4 class="calibre15">Also Known As</h4>
<p class="calibre1">Policy</p>
<p class="calibre1"><a id="ch05sec2lev96"></a></p>
<h4 class="calibre15">Motivation</h4>
<p class="calibre1">Many algorithms exist for breaking a stream of text into lines. Hard-wiring all such algorithms into the classes that require them isn’t desirable for several reasons:</p>
<p class="indenthangingB1">• Clients that need linebreaking get more complex if they include the line-breaking code. That makes clients bigger and harder to maintain, especially if they support multiple linebreaking algorithms.</p>
<p class="indenthangingB1">• Different algorithms will be appropriate at different times. We don’t want to support multiple linebreaking algorithms if we don’t use them all.</p>
<p class="indenthangingB1">• It’s difficult to add new algorithms and vary existing ones when linebreaking is an integral part of a client.</p>
<p class="calibre1">We can avoid these problems by defining classes that encapsulate different line-breaking algorithms. An algorithm that’s encapsulated in this way is called a <strong class="calibre4">strategy</strong>.</p>
<p class="image"><img src="../images/00370.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">Suppose a Composition class is responsible for maintaining and updating the linebreaks of text displayed in a text viewer. Linebreaking strategies aren’t implemented by the class Composition. Instead, they are implemented separately by subclasses of the abstract Compositor class. Compositor subclasses implement different strategies:</p>
<p class="indenthangingB1"><a id="page_316"></a>• <strong class="calibre4">SimpleCompositor</strong> implements a simple strategy that determines linebreaks one at a time.</p>
<p class="indenthangingB1">• <strong class="calibre4">TeXCompositor</strong> implements the T<sub class="calibre17">E</sub>X algorithm for finding linebreaks. This strategy tries to optimize linebreaks globally, that is, one paragraph at a time.</p>
<p class="indenthangingB1">• <strong class="calibre4">ArrayCompositor</strong> implements a strategy that selects breaks so that each row has a fixed number of items. It’s useful for breaking a collection of icons into rows, for example.</p>
<p class="calibre1">A Composition maintains a reference to a Compositor object. Whenever a Composition reformats its text, it forwards this responsibility to its Compositor object. The client of Composition specifies which Compositor should be used by installing the Compositor it desires into the Composition.</p>
<p class="calibre1"><a id="ch05sec2lev97"></a></p>
<h4 class="calibre15">Applicability</h4>
<p class="calibre1">Use the Strategy pattern when</p>
<p class="indenthangingB1">• many related classes differ only in their behavior. Strategies provide a way to configure a class with one of many behaviors.</p>
<p class="indenthangingB1">• you need different variants of an algorithm. For example, you might define algorithms reflecting different space/time trade-offs. Strategies can be used when these variants are implemented as a class hierarchy of algorithms <a href="part0020.html#bib01_037">[HO87]</a>.</p>
<p class="indenthangingB1">• an algorithm uses data that clients shouldn’t know about. Use the Strategy pattern to avoid exposing complex, algorithm-specific data structures.</p>
<p class="indenthangingB1">• a class defines many behaviors, and these appear as multiple conditional statements in its operations. Instead of many conditionals, move related conditional branches into their own Strategy class.</p>
<p class="calibre1"><a id="ch05sec2lev98"></a></p>
<h4 class="calibre15">Structure</h4>
<p class="image"><img src="../images/00371.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1"><a id="ch05sec2lev99"></a></p>
<h4 class="calibre15"><a id="page_317"></a>Participants</h4>
<p class="indenthangingB1">• <strong class="calibre4">Strategy</strong> (Compositor)</p>
<p class="indenthangingB2">– declares an interface common to all supported algorithms. Context uses this interface to call the algorithm defined by a ConcreteStrategy.</p>
<p class="indenthangingB1">• <strong class="calibre4">ConcreteStrategy</strong> (SimpleCompositor, TeXCompositor, ArrayCompositor)</p>
<p class="indenthangingB2">– implements the algorithm using the Strategy interface.</p>
<p class="indenthangingB1">• <strong class="calibre4">Context</strong> (Composition)</p>
<p class="indenthangingB2">– is configured with a ConcreteStrategy object.</p>
<p class="indenthangingB2">– maintains a reference to a Strategy object.</p>
<p class="indenthangingB2">– may define an interface that lets Strategy access its data.</p>
<p class="calibre1"><a id="ch05sec2lev100"></a></p>
<h4 class="calibre15">Collaborations</h4>
<p class="indenthangingB1">• Strategy and Context interact to implement the chosen algorithm. A context may pass all data required by the algorithm to the strategy when the algorithm is called. Alternatively, the context can pass itself as an argument to Strategy operations. That lets the strategy call back on the context as required.</p>
<p class="indenthangingB1">• A context forwards requests from its clients to its strategy. Clients usually create and pass a ConcreteStrategy object to the context; thereafter, clients interact with the context exclusively. There is often a family of ConcreteStrategy classes for a client to choose from.</p>
<p class="calibre1"><a id="ch05sec2lev101"></a></p>
<h4 class="calibre15">Consequences</h4>
<p class="calibre1">The Strategy pattern has the following benefits and drawbacks:</p>
<p class="indenthangingN">1. <em class="calibre7">Families of related algorithms.</em> Hierarchies of Strategy classes define a family of algorithms or behaviors for contexts to reuse. Inheritance can help factor out common functionality of the algorithms.</p>
<p class="indenthangingN">2. <em class="calibre7">An alternative to subclassing.</em> Inheritance offers another way to support a variety of algorithms or behaviors. You can subclass a Context class directly to give it different behaviors. But this hard-wires the behavior into Context. It mixes the algorithm implementation with Context’s, making Context harder to understand, maintain, and extend. And you can’t vary the algorithm dynamically. You wind up with many related classes whose only difference is the algorithm or behavior they employ. Encapsulating the algorithm in separate Strategy classes lets you vary the algorithm independently of its context, making it easier to switch, understand, and extend.</p>
<p class="indenthangingN">3. <em class="calibre7">Strategies eliminate conditional statements.</em> The Strategy pattern offers an alternative to conditional statements for selecting desired behavior. When different behaviors are lumped into one class, it’s hard to avoid using conditional <a id="page_318"></a>statements to select the right behavior. Encapsulating the behavior in separate Strategy classes eliminates these conditional statements.</p>
<p class="indentpara">For example, without strategies, the code for breaking text into lines could look like</p>
<p class="programlisting2"><img src="../images/00372.jpeg" alt="image" class="calibre11"/></p>
<p class="indentpara">The Strategy pattern eliminates this case statement by delegating the line-breaking task to a Strategy object:</p>
<p class="programlisting2"><img src="../images/00373.jpeg" alt="image" class="calibre11"/></p>
<p class="indentpara">Code containing many conditional statements often indicates the need to apply the Strategy pattern.</p>
<p class="indenthangingN">4. <em class="calibre7">A choice of implementations.</em> Strategies can provide different implementations of the <em class="calibre7">same</em> behavior. The client can choose among strategies with different time and space trade-offs.</p>
<p class="indenthangingN">5. <em class="calibre7">Clients must be aware of different Strategies.</em> The pattern has a potential drawback in that a client must understand how Strategies differ before it can select the appropriate one. Clients might be exposed to implementation issues. Therefore you should use the Strategy pattern only when the variation in behavior is relevant to clients.</p>
<p class="indenthangingN">6. <em class="calibre7">Communication overhead between Strategy and Context.</em> The Strategy interface is shared by all ConcreteStrategy classes whether the algorithms they implement are trivial or complex. Hence it’s likely that some ConcreteStrategies won’t use all the information passed to them through this interface; simple ConcreteStrategies may use none of it! That means there will be times when the context creates and initializes parameters that never get used. If this is an issue, then you’ll need tighter coupling between Strategy and Context.</p>
<p class="indenthangingN">7. <em class="calibre7">Increased number of objects.</em> Strategies increase the number of objects in an application. Sometimes you can reduce this overhead by implementing strategies as stateless objects that contexts can share. Any residual state is maintained by the context, which passes it in each request to the Strategy <a id="page_319"></a>object. Shared strategies should not maintain state across invocations. The Flyweight (<a href="part0014.html#page_195">195</a>) pattern describes this approach in more detail.</p>
<p class="calibre1"><a id="ch05sec2lev102"></a></p>
<h4 class="calibre15">Implementation</h4>
<p class="calibre1">Consider the following implementation issues:</p>
<p class="indenthangingN">1. <em class="calibre7">Defining the Strategy and Context interfaces.</em> The Strategy and Context interfaces must give a ConcreteStrategy efficient access to any data it needs from a context, and vice versa.</p>
<p class="indentpara">One approach is to have Context pass data in parameters to Strategy operations—in other words, take the data to the strategy. This keeps Strategy and Context decoupled. On the other hand, Context might pass data the Strategy doesn’t need.</p>
<p class="indentpara">Another technique has a context pass <em class="calibre7">itself</em> as an argument, and the strategy requests data from the context explicitly. Alternatively, the strategy can store a reference to its context, eliminating the need to pass anything at all. Either way, the strategy can request exactly what it needs. But now Context must define a more elaborate interface to its data, which couples Strategy and Context more closely.</p>
<p class="indentpara">The needs of the particular algorithm and its data requirements will determine the best technique.</p>
<p class="indenthangingN">2. <em class="calibre7">Strategies as template parameters.</em> In C++ templates can be used to configure a class with a strategy. This technique is only applicable if (1) the Strategy can be selected at compile-time, and (2) it does not have to be changed at run-time. In this case, the class to be configured (e.g., <code class="calibre13">Context</code>) is defined as a template class that has a <code class="calibre13">Strategy</code> class as a parameter:</p>
<p class="programlisting2"><img src="../images/00374.jpeg" alt="image" class="calibre11"/></p>
<p class="indentpara">The class is then configured with a <code class="calibre13">Strategy</code> class when it’s instantiated:</p>
<p class="programlisting2"><img src="../images/00375.jpeg" alt="image" class="calibre11"/></p>
<p class="indentpara">With templates, there’s no need to define an abstract class that defines the interface to the <code class="calibre13">Strategy</code>. Using <code class="calibre13">Strategy</code> as a template parameter also lets you bind a <code class="calibre13">Strategy</code> to its <code class="calibre13">Context</code> statically, which can increase efficiency.</p>
<p class="indenthangingN"><a id="page_320"></a>3. <em class="calibre7">Making Strategy objects optional.</em> The Context class may be simplified if it’s meaningful <em class="calibre7">not</em> to have a Strategy object. Context checks to see if it has a Strategy object before accessing it. If there is one, then Context uses it normally. If there isn’t a strategy, then Context carries out default behavior. The benefit of this approach is that clients don’t have to deal with Strategy objects at all <em class="calibre7">unless</em> they don’t like the default behavior.</p>
<p class="calibre1"><a id="ch05sec2lev103"></a></p>
<h4 class="calibre15">Sample Code</h4>
<p class="calibre1">We’ll give the high-level code for the Motivation example, which is based on the implementation of Composition and Compositor classes in Interviews <a href="part0020.html#bib01_050">[LCI+92]</a>.</p>
<p class="calibre1">The <code class="calibre13">Composition</code> class maintains a collection of <code class="calibre13">Component</code> instances, which represent text and graphical elements in a document. A composition arranges component objects into lines using an instance of a <code class="calibre13">Compositor</code> subclass, which encapsulates a linebreaking strategy. Each component has an associated natural size, stretchability, and shrinkability. The stretchability defines how much the component can grow beyond its natural size; shrinkability is how much it can shrink. The composition passes these values to a compositor, which uses them to determine the best location for linebreaks.</p>
<p class="programlisting"><img src="../images/00376.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">When a new layout is required, the composition asks its compositor to determine where to place linebreaks. The composition passes the compositor three arrays that define natural sizes, stretchabilities, and shrinkabilities of the components. It also passes the number of components, how wide the line is, and an array that the compositor fills with the position of each linebreak. The compositor returns the number of calculated breaks.</p>
<p class="calibre1">The <code class="calibre13">Compositor</code> interface lets the composition pass the compositor all the information it needs. This is an example of “taking the data to the strategy”:</p>
<p class="programlisting"><a id="page_321"></a><img src="../images/00377.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">Note that <code class="calibre13">Compositor</code> is an abstract class. Concrete subclasses define specific linebreaking strategies.</p>
<p class="calibre1">The composition calls its compositor in its <code class="calibre13">Repair</code> operation. <code class="calibre13">Repair</code> first initializes arrays with the natural size, stretchability, and shrinkability of each component (the details of which we omit for brevity). Then it calls on the compositor to obtain the linebreaks and finally lays out the components according to the breaks (also omitted):</p>
<p class="programlisting"><img src="../images/00378.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">Now let’s look at the <code class="calibre13">Compositor</code> subclasses. <code class="calibre13">SimpleCompositor</code> examines components a line at a time to determine where breaks should go:</p>
<p class="programlisting"><img src="../images/00379.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1"><a id="page_322"></a><code class="calibre13">TeXCompositor</code> uses a more global strategy. It examines a <em class="calibre7">paragraph</em> at a time, taking into account the components’ size and stretchability. It also tries to give an even “color” to the paragraph by minimizing the whitespace between components.</p>
<p class="programlisting"><img src="../images/00380.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1"><code class="calibre13">ArrayCompositor</code> breaks the components into lines at regular intervals.</p>
<p class="programlisting"><img src="../images/00381.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">These classes don’t use all the information passed in <code class="calibre13">Compose</code>. <code class="calibre13">SimpleCompositor</code> ignores the stretchability of the components, taking only their natural widths into account. <code class="calibre13">TeXCompositor</code> uses all the information passed to it, whereas <code class="calibre13">ArrayCompositor</code> ignores everything.</p>
<p class="calibre1">To instantiate <code class="calibre13">Composition</code>, you pass it the compositor you want to use:</p>
<p class="programlisting"><img src="../images/00382.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1"><code class="calibre13">Compositor</code>’s interface is carefully designed to support all layout algorithms that subclasses might implement. You don’t want to have to change this interface with every new subclass, because that will require changing existing subclasses. In general, the Strategy and Context interfaces determine how well the pattern achieves its intent.</p>
<p class="calibre1"><a id="ch05sec2lev104"></a></p>
<h4 class="calibre15">Known Uses</h4>
<p class="calibre1">Both ET++ <a href="part0020.html#bib01_089">[WGM88]</a> and Interviews use strategies to encapsulate different line-breaking algorithms as we’ve described.</p>
<p class="calibre1"><a id="page_323"></a>In the RTL System for compiler code optimization <a href="part0020.html#bib01_041">[JML92]</a>, strategies define different register allocation schemes (RegisterAllocator) and instruction set scheduling policies (RISCscheduler, CISCscheduler). This provides flexibility in targeting the optimizer for different machine architectures.</p>
<p class="calibre1">The ET++SwapsManager calculation engine framework computes prices for different financial instruments <a href="part0020.html#bib01_027">[EG92]</a>. Its key abstractions are Instrument and Yield-Curve. Different instruments are implemented as subclasses of Instrument. Yield-Curve calculates discount factors, which determine the present value of future cash flows. Both of these classes delegate some behavior to Strategy objects. The framework provides a family of ConcreteStrategy classes for generating cash flows, valuing swaps, and calculating discount factors. You can create new calculation engines by configuring Instrument and YieldCurve with the different ConcreteStrategy objects. This approach supports mixing and matching existing Strategy implementations as well as defining new ones.</p>
<p class="calibre1">The Booch components <a href="part0020.html#bib01_013">[BV90]</a> use strategies as template arguments. The Booch collection classes support three different kinds of memory allocation strategies: managed (allocation out of a pool), controlled (allocations/deallocations are protected by locks), and unmanaged (the normal memory allocator). These strategies are passed as template arguments to a collection class when it’s instantiated. For example, an UnboundedCollection that uses the unmanaged strategy is instantiated as <code class="calibre13">UnboundedCollection&lt;MyItemType*, Unmanaged&gt;</code>.</p>
<p class="calibre1">RApp is a system for integrated circuit layout [<a href="part0020.html#bib01_030">GA89</a>, <a href="part0020.html#bib01_002">AG90</a>]. RApp must lay out and route wires that connect subsystems on the circuit. Routing algorithms in RApp are defined as subclasses of an abstract Router class. Router is a Strategy class.</p>
<p class="calibre1">Borland’s ObjectWindows <a href="part0020.html#bib01_012">[Bor94]</a> uses strategies in dialogs boxes to ensure that the user enters valid data. For example, numbers might have to be in a certain range, and a numeric entry field should accept only digits. Validating that a string is correct can require a table look-up.</p>
<p class="calibre1">ObjectWindows uses Validator objects to encapsulate validation strategies. Validators are examples of Strategy objects. Data entry fields delegate the validation strategy to an optional Validator object. The client attaches a validator to a field if validation is required (an example of an optional strategy). When the dialog is closed, the entry fields ask their validators to validate the data. The class library provides validators for common cases, such as a Range Validator for numbers. New client-specific validation strategies can be defined easily by subclassing the Validator class.</p>
<p class="calibre1"><a id="ch05sec2lev105"></a></p>
<h4 class="calibre15">Related Patterns</h4>
<p class="calibre1">Flyweight (<a href="part0014.html#page_195">195</a>): Strategy objects often make good flyweights.</p>
<p class="calibre1"><a id="ch05sec1lev10"></a></p>
<h3 class="calibre2"><a id="page_325" class="calibre3"></a>Class Behavioral: Template Method</h3>
<p class="calibre1"><a id="ch05sec2lev106"></a></p>
<h4 class="calibre15">Intent</h4>
<p class="calibre1">Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure.</p>
<p class="calibre1"><a id="ch05sec2lev107"></a></p>
<h4 class="calibre15">Motivation</h4>
<p class="calibre1">Consider an application framework that provides Application and Document classes. The Application class is responsible for opening existing documents stored in an external format, such as a file. A Document object represents the information in a document once it’s read from the file.</p>
<p class="calibre1">Applications built with the framework can subclass Application and Document to suit specific needs. For example, a drawing application defines Draw Application and DrawDocument subclasses; a spreadsheet application defines Spreadsheet-Application and SpreadsheetDocument subclasses.</p>
<p class="image"><img src="../images/00383.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">The abstract Application class defines the algorithm for opening and reading a document in its OpenDocument operation:</p>
<p class="programlisting"><a id="page_326"></a><img src="../images/00384.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">OpenDocument defines each step for opening a document. It checks if the document can be opened, creates the application-specific Document object, adds it to its set of documents, and reads the Document from a file.</p>
<p class="calibre1">We call OpenDocument a template method. A <strong class="calibre4">template method</strong> defines an algorithm in terms of abstract operations that subclasses override to provide concrete behavior. Application subclasses define the steps of the algorithm that check if the document can be opened (CanOpenDocument) and that create the Document (DoCreateDocument). Document classes define the step that reads the document (DoRead). The template method also defines an operation that lets Application subclasses know when the document is about to be opened (AboutToOpenDocument), in case they care.</p>
<p class="calibre1">By defining some of the steps of an algorithm using abstract operations, the template method fixes their ordering, but it lets Application and Document subclasses vary those steps to suit their needs.</p>
<p class="calibre1"><a id="ch05sec2lev108"></a></p>
<h4 class="calibre15">Applicability</h4>
<p class="calibre1">The Template Method pattern should be used</p>
<p class="indenthangingB1">• to implement the invariant parts of an algorithm once and leave it up to subclasses to implement the behavior that can vary.</p>
<p class="indenthangingB1">• when common behavior among subclasses should be factored and localized in a common class to avoid code duplication. This is a good example of “refactoring to generalize” as described by Opdyke and Johnson <a href="part0020.html#bib01_064">[OJ93]</a>. You first identify the differences in the existing code and then separate the differences into new operations. Finally, you replace the differing code with a template method that calls one of these new operations.</p>
<p class="indenthangingB1">• to control subclasses extensions. You can define a template method that calls “hook” operations (see <a href="part0015.html#ch05sec2lev7">Consequences</a>) at specific points, thereby permitting extensions only at those points.</p>
<p class="calibre1"><a id="ch05sec2lev109"></a></p>
<h4 class="calibre15"><a id="page_327"></a>Structure</h4>
<p class="image"><img src="../images/00385.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1"><a id="ch05sec2lev110"></a></p>
<h4 class="calibre15">Participants</h4>
<p class="indenthangingB1">• <strong class="calibre4">AbstractClass</strong> (Application)</p>
<p class="indenthangingB2">– defines abstract <strong class="calibre4">primitive operations</strong> that concrete subclasses define to implement steps of an algorithm.</p>
<p class="indenthangingB2">– implements a template method defining the skeleton of an algorithm. The template method calls primitive operations as well as operations defined in AbstractClass or those of other objects.</p>
<p class="indenthangingB1">• <strong class="calibre4">ConcreteClass</strong> (MyApplication)</p>
<p class="indenthangingB2">– implements the primitive operations to carry out subclass-specific steps of the algorithm.</p>
<p class="calibre1"><a id="ch05sec2lev111"></a></p>
<h4 class="calibre15">Collaborations</h4>
<p class="indenthangingB1">• ConcreteClass relies on AbstractClass to implement the invariant steps of the algorithm.</p>
<p class="calibre1"><a id="ch05sec2lev112"></a></p>
<h4 class="calibre15">Consequences</h4>
<p class="calibre1">Template methods are a fundamental technique for code reuse. They are particularly important in class libraries, because they are the means for factoring out common behavior in library classes.</p>
<p class="calibre1">Template methods lead to an inverted control structure that’s sometimes referred to as “the Hollywood principle,” that is, “Don’t call us, we’ll call you” <a href="part0020.html#bib01_080">[Swe85]</a>. This refers to how a parent class calls the operations of a subclass and not the other way around.</p>
<p class="calibre1">Template methods call the following kinds of operations:</p>
<p class="indenthangingB1">• concrete operations (either on the ConcreteClass or on client classes);</p>
<p class="indenthangingB1"><a id="page_328"></a>• concrete AbstractClass operations (i.e., operations that are generally useful to subclasses);</p>
<p class="indenthangingB1">• primitive operations (i.e., abstract operations);</p>
<p class="indenthangingB1">• factory methods (see <a href="part0013.html#ch03sec1lev3">Factory Method</a> (<a href="part0013.html#ch03sec1lev3">107</a>)); and</p>
<p class="indenthangingB1">• <strong class="calibre4">hook operations,</strong> which provide default behavior that subclasses can extend if necessary. A hook operation often does nothing by default.</p>
<p class="calibre1">It’s important for template methods to specify which operations are hooks <em class="calibre7">(may</em> be overridden) and which are abstract operations <em class="calibre7">(must</em> be overridden). To reuse an abstract class effectively, subclass writers must understand which operations are designed for overriding.</p>
<p class="calibre1">A subclass can <em class="calibre7">extend</em> a parent class operation’s behavior by overriding the operation and calling the parent operation explicitly:</p>
<p class="programlisting"><img src="../images/00386.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">Unfortunately, it’s easy to forget to call the inherited operation. We can transform such an operation into a template method to give the parent control over how subclasses extend it. The idea is to call a hook operation from a template method in the parent class. Then subclasses can then override this hook operation:</p>
<p class="programlisting"><img src="../images/00387.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1"><code class="calibre13">HookOperation</code> does nothing in <code class="calibre13">ParentClass:</code></p>
<p class="programlisting"><img src="../images/00388.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">Subclasses override <code class="calibre13">HookOperation</code> to extend its behavior:</p>
<p class="programlisting"><img src="../images/00389.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1"><a id="ch05sec2lev113"></a></p>
<h4 class="calibre15">Implementation</h4>
<p class="calibre1">Three implementation issues are worth noting:</p>
<p class="indenthangingN">1. <em class="calibre7">Using C++ access control.</em> In C++, the primitive operations that a template method calls can be declared protected members. This ensures that they are only called by the template method. Primitive operations that <em class="calibre7">must</em> be <a id="page_329"></a>overridden are declared pure virtual. The template method itself should not be overridden; therefore you can make the template method a nonvirtual member function.</p>
<p class="indenthangingN">2. <em class="calibre7">Minimizing primitive operations.</em> An important goal in designing template methods is to minimize the number of primitive operations that a subclass must override to flesh out the algorithm. The more operations that need overriding, the more tedious things get for clients.</p>
<p class="indenthangingN">3. <em class="calibre7">Naming conventions.</em> You can identify the operations that should be overridden by adding a prefix to their names. For example, the MacApp framework for Macintosh applications <a href="part0020.html#bib01_004">[App89]</a> prefixes template method names with “Do-”: “DoCreateDocument”, “DoRead”, and so forth.</p>
<p class="calibre1"><a id="ch05sec2lev114"></a></p>
<h4 class="calibre15">Sample Code</h4>
<p class="calibre1">The following C++ example shows how a parent class can enforce an invariant for its subclasses. The example comes from NeXT’s AppKit <a href="part0020.html#bib01_001">[Add94]</a>. Consider a class <code class="calibre13">View</code> that supports drawing on the screen. <code class="calibre13">View</code> enforces the invariant that its subclasses can draw into a view only after it becomes the “focus,” which requires certain drawing state (for example, colors and fonts) to be set up properly.</p>
<p class="calibre1">We can use a <code class="calibre13">Display</code> template method to set up this state. <code class="calibre13">View</code> defines two concrete operations, <code class="calibre13">SetFocus</code> and <code class="calibre13">ResetFocus</code>, that set up and clean up the drawing state, respectively. <code class="calibre13">View</code>’s <code class="calibre13">DoDisplay</code> hook operation performs the actual drawing. <code class="calibre13">Display</code> calls <code class="calibre13">SetFocus</code> before <code class="calibre13">DoDisplay</code> to setup the drawing state; <code class="calibre13">Display</code> calls <code class="calibre13">ResetFocus</code> afterwards to release the drawing state.</p>
<p class="programlisting"><img src="../images/00390.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">To maintain the invariant, the <code class="calibre13">View</code>’s clients always call <code class="calibre13">Display</code>, and <code class="calibre13">View</code> subclasses always override <code class="calibre13">DoDisplay</code>.</p>
<p class="calibre1"><code class="calibre13">DoDisplay</code> does nothing in <code class="calibre13">View</code>:</p>
<p class="programlisting">void View::DoDisplay () { }</p>
<p class="calibre1">Subclasses override it to add their specific drawing behavior:</p>
<p class="programlisting"><img src="../images/00391.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1"><a id="ch05sec2lev115"></a></p>
<h4 class="calibre15">Known Uses</h4>
<p class="calibre1">Template methods are so fundamental that they can be found in almost every <a id="page_330"></a>abstract class. Wirfs-Brock et al. [<a href="part0020.html#bib01_088">WBWW90</a>, <a href="part0020.html#bib01_087">WBJ90</a>] provide a good overview and discussion of template methods.</p>
<p class="calibre1"><a id="ch05sec2lev116"></a></p>
<h4 class="calibre15">Related Patterns</h4>
<p class="calibre1">Factory Methods (<a href="part0013.html#page_107">107</a>) are often called by template methods. In the Motivation example, the factory method DoCreateDocument is called by the template method OpenDocument.</p>
<p class="calibre1">Strategy (<a href="part0015.html#page_315">315</a>): Template methods use inheritance to vary part of an algorithm. Strategies use delegation to vary the entire algorithm.</p>
<p class="calibre1"><a id="ch05sec1lev11"></a></p>
<h3 class="calibre2"><a id="page_331" class="calibre3"></a>Object Behavioral: Visitor</h3>
<p class="calibre1"><a id="ch05sec2lev117"></a></p>
<h4 class="calibre15">Intent</h4>
<p class="calibre1">Represent an operation to be performed on the elements of an object structure. Visitor lets you define a new operation without changing the classes of the elements on which it operates.</p>
<p class="calibre1"><a id="ch05sec2lev118"></a></p>
<h4 class="calibre15">Motivation</h4>
<p class="calibre1">Consider a compiler that represents programs as abstract syntax trees. It will need to perform operations on abstract syntax trees for “static semantic” analyses like checking that all variables are defined. It will also need to generate code. So it might define operations for type-checking, code optimization, flow analysis, checking for variables being assigned values before they’re used, and so on. Moreover, we could use the abstract syntax trees for pretty-printing, program restructuring, code instrumentation, and computing various metrics of a program.</p>
<p class="calibre1">Most of these operations will need to treat nodes that represent assignment statements differently from nodes that represent variables or arithmetic expressions. Hence there will be one class for assignment statements, another for variable accesses, another for arithmetic expressions, and so on. The set of node classes depends on the language being compiled, of course, but it doesn’t change much for a given language.</p>
<p class="image"><img src="../images/00392.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">This diagram shows part of the Node class hierarchy. The problem here is that distributing all these operations across the various node classes leads to a system that’s hard to understand, maintain, and change. It will be confusing to have type-checking code mixed with pretty-printing code or flow analysis code. Moreover, adding a new operation usually requires recompiling all of these classes. It would <a id="page_332"></a>be better if each new operation could be added separately, and the node classes were independent of the operations that apply to them.</p>
<p class="calibre1">We can have both by packaging related operations from each class in a separate object, called a <strong class="calibre4">visitor,</strong> and passing it to elements of the abstract syntax tree as it’s traversed. When an element “accepts” the visitor, it sends a request to the visitor that encodes the element’s class. It also includes the element as an argument. The visitor will then execute the operation for that element—the operation that used to be in the class of the element.</p>
<p class="calibre1">For example, a compiler that didn’t use visitors might type-check a procedure by calling the TypeCheck operation on its abstract syntax tree. Each of the nodes would implement TypeCheck by calling TypeCheck on its components (see the preceding class diagram). If the compiler type-checked a procedure using visitors, then it would create a TypeCheckingVisitor object and call the Accept operation on the abstract syntax tree with that object as an argument. Each of the nodes would implement Accept by calling back on the visitor: an assignment node calls VisitAssignment operation on the visitor, while a variable reference calls VisitVariableReference. What used to be the TypeCheck operation in class AssignmentNode is now the VisitAssignment operation on TypeCheckingVisitor.</p>
<p class="calibre1">To make visitors work for more than just type-checking, we need an abstract parent class NodeVisitor for all visitors of an abstract syntax tree. NodeVisitor must declare an operation for each node class. An application that needs to compute program metrics will define new subclasses of NodeVisitor and will no longer need to add application-specific code to the node classes. The Visitor pattern encapsulates the operations for each compilation phase in a Visitor associated with that phase.</p>
<p class="image"><img src="../images/00393.jpeg" alt="image" class="calibre11"/></p>
<p class="image"><a id="page_333"></a><img src="../images/00394.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">With the Visitor pattern, you define two class hierarchies: one for the elements being operated on (the Node hierarchy) and one for the visitors that define operations on the elements (the NodeVisitor hierarchy). You create a new operation by adding a new subclass to the visitor class hierarchy. As long as the grammar that the compiler accepts doesn’t change (that is, we don’t have to add new Node subclasses), we can add new functionality simply by defining new NodeVisitor subclasses.</p>
<p class="calibre1"><a id="ch05sec2lev119"></a></p>
<h4 class="calibre15">Applicability</h4>
<p class="calibre1">Use the Visitor pattern when</p>
<p class="indenthangingB1">• an object structure contains many classes of objects with differing interfaces, and you want to perform operations on these objects that depend on their concrete classes.</p>
<p class="indenthangingB1">• many distinct and unrelated operations need to be performed on objects in an object structure, and you want to avoid “polluting” their classes with these operations. Visitor lets you keep related operations together by defining them in one class. When the object structure is shared by many applications, use Visitor to put operations in just those applications that need them.</p>
<p class="indenthangingB1">• the classes defining the object structure rarely change, but you often want to define new operations over the structure. Changing the object structure classes requires redefining the interface to all visitors, which is potentially costly. If the object structure classes change often, then it’s probably better to define the operations in those classes.</p>
<p class="calibre1"><a id="ch05sec2lev120"></a></p>
<h4 class="calibre15"><a id="page_334"></a>Structure</h4>
<p class="image"><img src="../images/00395.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1"><a id="ch05sec2lev121"></a></p>
<h4 class="calibre15">Participants</h4>
<p class="indenthangingB1">• <strong class="calibre4">Visitor</strong> (NodeVisitor)</p>
<p class="indenthangingB2">– declares a Visit operation for each class of ConcreteElement in the object structure. The operation’s name and signature identifies the class that sends the Visit request to the visitor. That lets the visitor determine the concrete class of the element being visited. Then the visitor can access the element directly through its particular interface.</p>
<p class="indenthangingB1">• <strong class="calibre4">Concrete Visitor</strong> (TypeCheckingVisitor)</p>
<p class="indenthangingB2">– implements each operation declared by Visitor. Each operation implements a fragment of the algorithm defined for the corresponding class of object in the structure. ConcreteVisitor provides the context for the algorithm and stores its local state. This state often accumulates results during the traversal of the structure.</p>
<p class="indenthangingB1">• <strong class="calibre4">Element</strong> (Node)</p>
<p class="indenthangingB2">– defines an Accept operation that takes a visitor as an argument.</p>
<p class="indenthangingB1"><a id="page_335"></a>• <strong class="calibre4">ConcreteElement</strong> (AssignmentNode, VariableRefNode)</p>
<p class="indenthangingB2">– implements an Accept operation that takes a visitor as an argument.</p>
<p class="indenthangingB1">• <strong class="calibre4">ObjectStructure</strong> (Program)</p>
<p class="indenthangingB2">– can enumerate its elements.</p>
<p class="indenthangingB2">– may provide a high-level interface to allow the visitor to visit its elements.</p>
<p class="indenthangingB2">– may either be a composite (see <a href="part0014.html#ch04sec1lev3">Composite</a> (<a href="part0014.html#ch04sec1lev3">163</a>)) or a collection such as a list or a set.</p>
<p class="calibre1"><a id="ch05sec2lev122"></a></p>
<h4 class="calibre15">Collaborations</h4>
<p class="indenthangingB1">• A client that uses the Visitor pattern must create a ConcreteVisitor object and then traverse the object structure, visiting each element with the visitor.</p>
<p class="indenthangingB1">• When an element is visited, it calls the Visitor operation that corresponds to its class. The element supplies itself as an argument to this operation to let the visitor access its state, if necessary.</p>
<p class="indentpara">The following interaction diagram illustrates the collaborations between an object structure, a visitor, and two elements:</p>
<p class="image"><img src="../images/00396.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1"><a id="ch05sec2lev123"></a></p>
<h4 class="calibre15">Consequences</h4>
<p class="calibre1">Some of the benefits and liabilities of the Visitor pattern are as follows:</p>
<p class="indenthangingN">1. <em class="calibre7">Visitor makes adding new operations easy.</em> Visitors make it easy to add operations that depend on the components of complex objects. You can define a new operation over an object structure simply by adding a new visitor. In contrast, if you spread functionality over many classes, then you must change each class to define a new operation.</p>
<p class="indenthangingN">2. <em class="calibre7">A visitor gathers related operations and separates unrelated ones.</em> Related behavior isn’t spread over the classes defining the object structure; it’s localized in a visitor. Unrelated sets of behavior are partitioned in their own visitor <a id="page_336"></a>subclasses. That simplifies both the classes defining the elements and the algorithms defined in the visitors. Any algorithm-specific data structures can be hidden in the visitor.</p>
<p class="indenthangingN">3. <em class="calibre7">Adding new ConcreteElement classes is hard.</em> The Visitor pattern makes it hard to add new subclasses of Element. Each new ConcreteElement gives rise to a new abstract operation on Visitor and a corresponding implementation in every ConcreteVisitor class. Sometimes a default implementation can be provided in Visitor that can be inherited by most of the ConcreteVisitors, but this is the exception rather than the rule.</p>
<p class="indentpara">So the key consideration in applying the Visitor pattern is whether you are mostly likely to change the algorithm applied over an object structure or the classes of objects that make up the structure. The Visitor class hierarchy can be difficult to maintain when new ConcreteElement classes are added frequently. In such cases, it’s probably easier just to define operations on the classes that make up the structure. If the Element class hierarchy is stable, but you are continually adding operations or changing algorithms, then the Visitor pattern will help you manage the changes.</p>
<p class="indenthangingN">4. <em class="calibre7">Visiting across class hierarchies.</em> An iterator (see <a href="part0015.html#ch05sec1lev4">Iterator</a> (<a href="part0015.html#ch05sec1lev4">257</a>)) can visit the objects in a structure as it traverses them by calling their operations. But an iterator can’t work across object structures with different types of elements. For example, the Iterator interface defined on page <a href="part0015.html#ch05sec2lev44">263</a> can access only objects of type <code class="calibre13">Item</code>:</p>
<p class="programlisting2"><img src="../images/00397.jpeg" alt="image" class="calibre11"/></p>
<p class="indentpara">This implies that all elements the iterator can visit have a common parent class <code class="calibre13">Item</code>.</p>
<p class="indentpara">Visitor does not have this restriction. It can visit objects that don’t have a common parent class. You can add any type of object to a Visitor interface. For example, in</p>
<p class="programlisting"><img src="../images/00398.jpeg" alt="image" class="calibre11"/></p>
<p class="indentpara"><code class="calibre13">MyType</code> and <code class="calibre13">YourType</code> do not have to be related through inheritance at all.</p>
<p class="indenthangingN">5. <em class="calibre7">Accumulating state.</em> Visitors can accumulate state as they visit each element in the object structure. Without a visitor, this state would be passed as extra arguments to the operations that perform the traversal, or they might appear as global variables.</p>
<p class="indenthangingN"><a id="page_337"></a>6. <em class="calibre7">Breaking encapsulation.</em> Visitor’s approach assumes that the ConcreteElement interface is powerful enough to let visitors do their job. As a result, the pattern often forces you to provide public operations that access an element’s internal state, which may compromise its encapsulation.</p>
<p class="calibre1"><a id="ch05sec2lev124"></a></p>
<h4 class="calibre15">Implementation</h4>
<p class="calibre1">Each object structure will have an associated Visitor class. This abstract visitor class declares a VisitConcreteElement operation for each class of ConcreteElement defining the object structure. Each Visit operation on the Visitor declares its argument to be a particular ConcreteElement, allowing the Visitor to access the interface of the ConcreteElement directly. Concrete Visitor classes override each Visit operation to implement visitor-specific behavior for the corresponding ConcreteElement class.</p>
<p class="calibre1">The Visitor class would be declared like this in C++:</p>
<p class="programlisting"><img src="../images/00399.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">Each class of ConcreteElement implements an <code class="calibre13">Accept</code> operation that calls the matching <code class="calibre13">Visit</code>. . . operation on the visitor for that ConcreteElement. Thus the operation that ends up getting called depends on both the class of the element and the class of the visitor.<sup class="calibre8"><a id="ch05fn_10"></a><a href="part0022.html#ch05fn10">10</a></sup></p>
<p class="calibre1">The concrete elements are declared as</p>
<p class="programlisting"><img src="../images/00400.jpeg" alt="image" class="calibre11"/></p>
<p class="programlisting"><a id="page_338"></a><img src="../images/00401.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">A <code class="calibre13">CompositeElement</code> class might implement <code class="calibre13">Accept</code> like this:</p>
<p class="programlisting"><img src="../images/00402.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">Here are two other implementation issues that arise when you apply the Visitor pattern:</p>
<p class="indenthangingN">1. <em class="calibre7">Double dispatch.</em> Effectively, the Visitor pattern lets you add operations to classes without changing them. Visitor achieves this by using a technique called <strong class="calibre4">double-dispatch</strong>. It’s a well-known technique. In fact, some programming languages support it directly (CLOS, for example). Languages like C++ and Smalltalk support <strong class="calibre4">single-dispatch</strong>.</p>
<p class="indentpara">In single-dispatch languages, two criteria determine which operation will fulfill a request: the name of the request and the type of receiver. For example, the operation that a GenerateCode request will call depends on the type of node object you ask. In C++, calling <code class="calibre13">GenerateCode</code> on an instance of <code class="calibre13">VariableRefNode</code> will call <code class="calibre13">VariableRefNode</code>::<code class="calibre13">GenerateCode</code> (which generates code for a variable reference). Calling <code class="calibre13">GenerateCode</code> on an <code class="calibre13">AssignmentNode</code> will call <code class="calibre13">AssignmentNode</code>::<code class="calibre13">GenerateCode</code> (which will generate code for an assignment). The operation that gets executed depends both on the kind of request and the type of the receiver.</p>
<p class="indentpara">“Double-dispatch” simply means the operation that gets executed depends on the kind of request and the types of <em class="calibre7">two</em> receivers. <code class="calibre13">Accept</code> is a double-dispatch operation. Its meaning depends on two types: the Visitor’s and the <a id="page_339"></a>Element’s. Double-dispatching lets visitors request different operations on each class of element.<sup class="calibre8"><a id="ch05fn_11"></a><a href="part0022.html#ch05fn11">11</a></sup></p>
<p class="indentpara">This is the key to the Visitor pattern: The operation that gets executed depends on both the type of Visitor and the type of Element it visits. Instead of binding operations statically into the Element interface, you can consolidate the operations in a Visitor and use <code class="calibre13">Accept</code> to do the binding at run-time. Extending the Element interface amounts to defining one new Visitor subclass rather than many new Element subclasses.</p>
<p class="indenthangingN">2. <em class="calibre7">Who is responsible for traversing the object structure?</em> A visitor must visit each element of the object structure. The question is, how does it get there? We can put responsibility for traversal in any of three places: in the object structure, in the visitor, or in a separate iterator object (see <a href="part0015.html#ch05sec1lev4">Iterator</a> (<a href="part0015.html#ch05sec1lev4">257</a>)).</p>
<p class="indentpara">Often the object structure is responsible for iteration. A collection will simply iterate over its elements, calling the Accept operation on each. A composite will commonly traverse itself by having each Accept operation traverse the element’s children and call Accept on each of them recursively.</p>
<p class="indentpara">Another solution is to use an iterator to visit the elements. In C++, you could use either an internal or external iterator, depending on what is available and what is most efficient. In Smalltalk, you usually use an internal iterator using <code class="calibre13">do</code>: and a block. Since internal iterators are implemented by the object structure, using an internal iterator is a lot like making the object structure responsible for iteration. The main difference is that an internal iterator will not cause double-dispatching—it will call an operation on the <em class="calibre7">visitor</em> with an <em class="calibre7">element</em> as an argument as opposed to calling an operation on the <em class="calibre7">element</em> with the <em class="calibre7">visitor</em> as an argument. But it’s easy to use the Visitor pattern with an internal iterator if the operation on the visitor simply calls the operation on the element without recursing.</p>
<p class="indentpara">You could even put the traversal algorithm in the visitor, although you’ll end up duplicating the traversal code in each ConcreteVisitor for each aggregate ConcreteElement. The main reason to put the traversal strategy in the visitor is to implement a particularly complex traversal, one that depends on the results of the operations on the object structure. We’ll give an example of such a case in the Sample Code.</p>
<p class="calibre1"><a id="ch05sec2lev125"></a></p>
<h4 class="calibre15">Sample Code</h4>
<p class="calibre1">Because visitors are usually associated with composites, we’ll use the <code class="calibre13">Equipment</code> classes defined in the Sample Code of Composite (<a href="part0014.html#page_163">163</a>) to illustrate the Visitor pattern. We will use Visitor to define operations for computing the inventory of materials and the total cost for a piece of equipment. The <code class="calibre13">Equipment</code> classes are <a id="page_340"></a>so simple that using Visitor isn’t really necessary, but they make it easy to see what’s involved in implementing the pattern.</p>
<p class="calibre1">Here again is the <code class="calibre13">Equipment</code> class from Composite (<a href="part0014.html#page_163">163</a>). We’ve augmented it with an <code class="calibre13">Accept</code> operation to let it work with a visitor.</p>
<p class="programlisting"><img src="../images/00403.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">The <code class="calibre13">Equipment</code> operations return the attributes of a piece of equipment, such as its power consumption and cost. Subclasses redefine these operations appropriately for specific types of equipment (e.g., a chassis, drives, and planar boards).</p>
<p class="calibre1">The abstract class for all visitors of equipment has a virtual function for each subclass of equipment, as shown next. All of the virtual functions do nothing by default.</p>
<p class="programlisting"><img src="../images/00404.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1"><code class="calibre13">Equipment</code> subclasses define <code class="calibre13">Accept</code> in basically the same way: It calls the <code class="calibre13">EquipmentVisitor</code> operation that corresponds to the class that received the <code class="calibre13">Accept</code> request, like this:</p>
<p class="programlisting"><img src="../images/00405.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1"><a id="page_341"></a>Equipment that contains other equipment (in particular, subclasses of <code class="calibre13">CompositeEquipment</code> in the Composite pattern) implements <code class="calibre13">Accept</code> by iterating over its children and calling <code class="calibre13">Accept</code> on each of them. Then it calls the <code class="calibre13">Visit</code> operation as usual. For example, <code class="calibre13">Chassis</code>::<code class="calibre13">Accept</code> could traverse all the parts in the chassis as follows:</p>
<p class="programlisting"><img src="../images/00406.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">Subclasses of <code class="calibre13">EquipmentVisitor</code> define particular algorithms over the equipment structure. The <code class="calibre13">PricingVisitor</code> computes the cost of the equipment structure. It computes the net price of all simple equipment (e.g., floppies) and the discount price of all composite equipment (e.g., chassis and buses).</p>
<p class="programlisting"><img src="../images/00407.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1"><code class="calibre13">PricingVisitor</code> will compute the total cost of all nodes in the equipment structure. Note that <code class="calibre13">PricingVisitor</code> chooses the appropriate pricing policy for a class of equipment by dispatching to the corresponding member function. What’s more, we can change the pricing policy of an equipment structure just by changing the <code class="calibre13">PricingVisitor</code> class.</p>
<p class="calibre1"><a id="page_342"></a>We can define a visitor for computing inventory like this:</p>
<p class="programlisting"><img src="../images/00408.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">The <code class="calibre13">InventoryVisitor</code> accumulates the totals for each type of equipment in the object structure. <code class="calibre13">InventoryVisitor</code> uses an <code class="calibre13">Inventory</code> class that defines an interface for adding equipment (which we won’t bother defining here).</p>
<p class="programlisting"><img src="../images/00409.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">Here’s how we can use an <code class="calibre13">InventoryVisitor</code> on an equipment structure:</p>
<p class="programlisting"><img src="../images/00410.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">Now we’ll show how to implement the Smalltalk example from the Interpreter pattern (see page <a href="part0015.html#ch05sec2lev32">248</a>) with the Visitor pattern. Like the previous example, this one is so small that Visitor probably won’t buy us much, but it provides a good illustration of how to use the pattern. Further, it illustrates a situation in which iteration is the visitor’s responsibility.</p>
<p class="calibre1">The object structure (regular expressions) is made of four classes, and all of them have an <code class="calibre13">accept</code>: method that takes the visitor as an argument. In class <code class="calibre13">SequenceExpression</code>, the <code class="calibre13">accept</code>: method is</p>
<p class="programlisting"><a id="page_343"></a><img src="../images/00411.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">In class <code class="calibre13">RepeatExpression</code>, the <code class="calibre13">accept</code>: method sends the <code class="calibre13">visitRepeat</code>: message. In class <code class="calibre13">AlternationExpression</code>, it sends the <code class="calibre13">visitAlternation</code>: message. In class <code class="calibre13">LiteralExpression</code>, it sends the <code class="calibre13">visitLiteral</code>: message.</p>
<p class="calibre1">The four classes also must have accessing functions that the visitor can use. For <code class="calibre13">SequenceExpression</code> these are <code class="calibre13">expressionl</code> and <code class="calibre13">expression2</code>; for <code class="calibre13">AlternationExpression</code> these are <code class="calibre13">alternativel</code> and <code class="calibre13">alternative2</code>; for <code class="calibre13">RepeatExpression</code> it is <code class="calibre13">repetition</code>; and for <code class="calibre13">LiteralExpression</code> these are <code class="calibre13">components</code>.</p>
<p class="calibre1">The ConcreteVisitor class is <code class="calibre13">REMatchingVisitor</code>. It is responsible for the traversal because its traversal algorithm is irregular. The biggest irregularity is that a <code class="calibre13">RepeatExpression</code> will repeatedly traverse its component. The class <code class="calibre13">REMatchingVisitor</code> has an instance variable <code class="calibre13">inputState</code>. Its methods are essentially the same as the <code class="calibre13">match</code>: methods of the expression classes in the Interpreter pattern except they replace the argument named <code class="calibre13">inputState</code> with the expression node being matched. However, they still return the set of streams that the expression would match to identify the current state.</p>
<p class="programlisting"><img src="../images/00412.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1"><a id="ch05sec2lev126"></a></p>
<h4 class="calibre15"><a id="page_344"></a>Known Uses</h4>
<p class="calibre1">The Smalltalk-80 compiler has a Visitor class called ProgramNodeEnumerator. It’s used primarily for algorithms that analyze source code. It isn’t used for code generation or pretty-printing, although it could be.</p>
<p class="calibre1">IRIS Inventor [<a href="part0020.html#bib01_077">Str93</a>] is a toolkit for developing 3-D graphics applications. Inventor represents a three-dimensional scene as a hierarchy of nodes, each representing either a geometric object or an attribute of one. Operations like rendering a scene or mapping an input event require traversing this hierarchy in different ways. Inventor does this using visitors called “actions.” There are different visitors for rendering, event handling, searching, filing, and determining bounding boxes.</p>
<p class="calibre1">To make adding new nodes easier, Inventor implements a double-dispatch scheme for C++. The scheme relies on run-time type information and a two-dimensional table in which rows represent visitors and columns represent node classes. The cells store a pointer to the function bound to the visitor and node class.</p>
<p class="calibre1">Mark Linton coined the term “Visitor” in the X Consortium’s Fresco Application Toolkit specification <a href="part0020.html#bib01_056">[LP93]</a>.</p>
<p class="calibre1"><a id="ch05sec2lev127"></a></p>
<h4 class="calibre15">Related Patterns</h4>
<p class="calibre1">Composite (<a href="part0014.html#page_163">163</a>): Visitors can be used to apply an operation over an object structure defined by the Composite pattern.</p>
<p class="calibre1">Interpreter (<a href="part0015.html#page_243">243</a>): Visitor may be applied to do the interpretation.</p>
<p class="calibre1"><a id="ch05sec1lev12"></a></p>
<h3 class="calibre2"><a id="page_345" class="calibre3"></a>Discussion of Behavioral Patterns</h3>
<p class="calibre1"><a id="ch05sec2lev128"></a></p>
<h4 class="calibre15">Encapsulating Variation</h4>
<p class="calibre1">Encapsulating variation is a theme of many behavioral patterns. When an aspect of a program changes frequently, these patterns define an object that encapsulates that aspect. Then other parts of the program can collaborate with the object whenever they depend on that aspect. The patterns usually define an abstract class that describes the encapsulating object, and the pattern derives its name from that object.<sup class="calibre8"><a id="ch05fn_12"></a><a href="part0022.html#ch05fn12">12</a></sup> For example,</p>
<p class="indenthangingB1">• a Strategy object encapsulates an algorithm (Strategy (<a href="part0015.html#page_315">315</a>)),</p>
<p class="indenthangingB1">• a State object encapsulates a state-dependent behavior (State (<a href="part0015.html#page_305">305</a>)),</p>
<p class="indenthangingB1">• a Mediator object encapsulates the protocol between objects (Mediator (<a href="part0015.html#page_273">273</a>)), and</p>
<p class="indenthangingB1">• an Iterator object encapsulates the way you access and traverse the components of an aggregate object (Iterator (<a href="part0015.html#page_257">257</a>)).</p>
<p class="calibre1">These patterns describe aspects of a program that are likely to change. Most patterns have two kinds of objects: the new object(s) that encapsulate the aspect, and the existing object(s) that use the new ones. Usually the functionality of new objects would be an integral part of the existing objects were it not for the pattern. For example, code for a Strategy would probably be wired into the strategy’s Context, and code for a State would be implemented directly in the state’s Context.</p>
<p class="calibre1">But not all object behavioral patterns partition functionality like this. For example, Chain of Responsibility (<a href="part0015.html#page_223">223</a>) deals with an arbitrary number of objects (i.e., a chain), all of which may already exist in the system.</p>
<p class="calibre1">Chain of Responsibility illustrates another difference in behavioral patterns: Not all define static communication relationships between classes. Chain of Responsibility prescribes communication between an open-ended number of objects. Other patterns involve objects that are passed around as arguments.</p>
<p class="calibre1"><a id="ch05sec2lev129"></a></p>
<h4 class="calibre15">Objects as Arguments</h4>
<p class="calibre1">Several patterns introduce an object that’s <em class="calibre7">always</em> used as an argument. One of these is Visitor (<a href="part0015.html#page_331">331</a>). A Visitor object is the argument to a polymorphic Accept operation on the objects it visits. The visitor is never considered a part of those objects, even though the conventional alternative to the pattern is to distribute Visitor code across the object structure classes.</p>
<p class="calibre1"><a id="page_346"></a>Other patterns define objects that act as magic tokens to be passed around and invoked at a later time. Both Command (<a href="part0015.html#page_233">233</a>) and Memento (<a href="part0015.html#page_283">283</a>) fall into this category. In Command, the token represents a request; in Memento, it represents the internal state of an object at a particular time. In both cases, the token can have a complex internal representation, but the client is never aware of it. But even here there are differences. Polymorphism is important in the Command pattern, because executing the Command object is a polymorphic operation. In contrast, the Memento interface is so narrow that a memento can only be passed as a value. So it’s likely to present no polymorphic operations at all to its clients.</p>
<p class="calibre1"><a id="ch05sec2lev130"></a></p>
<h4 class="calibre15">Should Communication be Encapsulated or Distributed?</h4>
<p class="calibre1">Mediator (<a href="part0015.html#page_273">273</a>) and Observer (<a href="part0015.html#page_293">293</a>) are competing patterns. The difference between them is that Observer distributes communication by introducing Observer and Subject objects, whereas a Mediator object encapsulates the communication between other objects.</p>
<p class="calibre1">In the Observer pattern, there is no single object that encapsulates a constraint. Instead, the Observer and the Subject must cooperate to maintain the constraint. Communication patterns are determined by the way observers and subjects are interconnected: a single subject usually has many observers, and sometimes the observer of one subject is a subject of another observer. The Mediator pattern centralizes rather than distributes. It places the responsibility for maintaining a constraint squarely in the mediator.</p>
<p class="calibre1">We’ve found it easier to make reusable Observers and Subjects than to make reusable Mediators. The Observer pattern promotes partitioning and loose coupling between Observer and Subject, and that leads to finer-grained classes that are more apt to be reused.</p>
<p class="calibre1">On the other hand, it’s easier to understand the flow of communication in Mediator than in Observer. Observers and subjects are usually connected shortly after they’re created, and it’s hard to see how they are connected later in the program. If you know the Observer pattern, then you understand that the way observers and subjects are connected is important, and you also know what connections to look for. However, the indirection that Observer introduces will still make a system harder to understand.</p>
<p class="calibre1">Observers in Smalltalk can be parameterized with messages to access the Subject state, and so they are even more reusable than they are in C++. This makes Observer more attractive than Mediator in Smalltalk. Thus a Smalltalk programmer will often use Observer where a C++ programmer would use Mediator.</p>
<p class="calibre1"><a id="ch05sec2lev131"></a></p>
<h4 class="calibre15">Decoupling Senders and Receivers</h4>
<p class="calibre1">When collaborating objects refer to each other directly, they become dependent on each other, and that can have an adverse impact on the layering and reusability of a <a id="page_347"></a>system. Command, Observer, Mediator, and Chain of Responsibility address how you can decouple senders and receivers, but with different trade-offs.</p>
<p class="calibre1">The Command pattern supports decoupling by using a Command object to define the binding between a sender and receiver:</p>
<p class="image"><img src="../images/00413.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">The Command object provides a simple interface for issuing the request (that is, the Execute operation). Defining the sender-receiver connection in a separate object lets the sender work with different receivers. It keeps the sender decoupled from the receivers, making senders easy to reuse. Moreover, you can reuse the Command object to parameterize a receiver with different senders. The Command pattern nominally requires a subclass for each sender-receiver connection, although the pattern describes implementation techniques that avoid subclassing.</p>
<p class="calibre1">The Observer pattern decouples senders (subjects) from receivers (observers) by defining an interface for signaling changes in subjects. Observer defines a looser sender-receiver binding than Command, since a subject may have multiple observers, and their number can vary at run-time.</p>
<p class="image"><img src="../images/00414.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">The Subject and Observer interfaces in the Observer pattern are designed for communicating changes. Therefore the Observer pattern is best for decoupling objects when there are data dependencies between them.</p>
<p class="calibre1">The Mediator pattern decouples objects by having them refer to each other indirectly through a Mediator object.</p>
<p class="image"><a id="page_348"></a><img src="../images/00415.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">A Mediator object routes requests between Colleague objects and centralizes their communication. Consequently, colleagues can only talk to each other through the Mediator interface. Because this interface is fixed, the Mediator might have to implement its own dispatching scheme for added flexibility. Requests can be encoded and arguments packed in such a way that colleagues can request an open-ended set of operations.</p>
<p class="calibre1">The Mediator pattern can reduce subclassing in a system, because it centralizes communication behavior in one class instead of distributing it among subclasses. However, <em class="calibre7">ad hoc</em> dispatching schemes often decrease type safety.</p>
<p class="calibre1">Finally, the Chain of Responsibility pattern decouples the sender from the receiver by passing the request along a chain of potential receivers:</p>
<p class="image"><img src="../images/00416.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">Since the interface between senders and receivers is fixed, Chain of Responsibility may also require a custom dispatching scheme. Hence it has the same type-safety drawbacks as Mediator. Chain of Responsibility is a good way to decouple the sender and the receiver if the chain is already part of the system’s structure, and one of several objects may be in a position to handle the request. Moreover, the pattern offers added flexibility in that the chain can be changed or extended easily.</p>
<p class="calibre1"><a id="ch05sec2lev132"></a></p>
<h4 class="calibre15"><a id="page_349"></a>Summary</h4>
<p class="calibre1">With few exceptions, behavioral design patterns complement and reinforce each other. A class in a chain of responsibility, for example, will probably include at least one application of Template Method (<a href="part0015.html#page_325">325</a>). The template method can use primitive operations to determine whether the object should handle the request and to choose the object to forward to. The chain can use the Command pattern to represent requests as objects. Interpreter (<a href="part0015.html#page_243">243</a>) can use the State pattern to define parsing contexts. An iterator can traverse an aggregate, and a visitor can apply an operation to each element in the aggregate.</p>
<p class="calibre1">Behavioral patterns work well with other patterns, too. For example, a system that uses the Composite (<a href="part0014.html#page_163">163</a>) pattern might use a visitor to perform operations on components of the composition. It could use Chain of Responsibility to let components access global properties through their parent. It could also use Decorator (<a href="part0014.html#page_175">175</a>) to override these properties on parts of the composition. It could use the Observer pattern to tie one object structure to another and the State pattern to let a component change its behavior as its state changes. The composition itself might be created using the approach in Builder (<a href="part0013.html#page_97">97</a>), and it might be treated as a Prototype (<a href="part0013.html#page_117">117</a>) by some other part of the system.</p>
<p class="calibre1">Well-designed object-oriented systems are just like this—they have multiple patterns embedded in them—but not because their designers necessarily thought in these terms. Composition at the <em class="calibre7">pattern</em> level rather than the class or object levels lets us achieve the same synergy with greater ease.</p>
</body></html>
