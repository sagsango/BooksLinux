<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Appendix B. Guide to Notation</title>
    <link href="page-template.xpgt" type="application/vnd.adobe-page-template+xml" rel="stylesheet"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="../page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<p class="calibre1"><a id="app02"></a></p>
<div class="calibre5"></div><h2 class="calibre6" id="calibre_pb_0"><a id="page_363" class="calibre3"></a>Appendix B. Guide to Notation</h2>
<p class="calibre1">We use diagrams throughout the book to illustrate important ideas. Some diagrams are informal, like a screen shot of a dialog box or a schematic showing a tree of objects. But the design patterns in particular use more formal notations to denote relationships and interactions between classes and objects. This appendix describes these notations in detail.</p>
<p class="calibre1">We use three different diagrammatic notations:</p>
<p class="indenthangingN">1. A <strong class="calibre4">class diagram</strong> depicts classes, their structure, and the static relationships between them.</p>
<p class="indenthangingN">2. An <strong class="calibre4">object diagram</strong> depicts a particular object structure at run-time.</p>
<p class="indenthangingN">3. An <strong class="calibre4">interaction diagram</strong> shows the flow of requests between objects.</p>
<p class="calibre1">Each design pattern includes at least one class diagram. The other notations are used as needed to supplement the discussion. The class and object diagrams are based on OMT (Object Modeling Technique) [<a href="part0020.html#bib01_069">RBP<sup class="calibre8">+</sup>91</a>, <a href="part0020.html#bib01_070">Rum94</a>].<sup class="calibre8"><a id="app02fn_01"></a><a href="part0022.html#app02fn01">1</a></sup> The interaction diagrams are taken from Objectory [JCJO92] and the Booch method [Boo94]. These notations are summarized on the inside back cover of the book.</p>
<p class="calibre1"><a id="app02sec1lev1"></a></p>
<h3 class="calibre2">B.1 Class Diagram</h3>
<p class="calibre1"><a href="part0018.html#app02fig01">Figure B.1a</a> shows the OMT notation for abstract and concrete classes. A class is denoted by a box with the class name in bold type at the top. The key operations of the class appear below the class name. Any instance variables appear below the operations.</p>
<p class="caption"><a id="page_365"></a><a id="app02fig01"></a>Figure B.1: Class diagram notation</p>
<p class="image"><img src="../images/00418.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1"><a id="page_364"></a>Type information is optional; we use the C++ convention, which puts the type name before the name of the operation (to signify the return type), instance variable, or actual parameter. Slanted type indicates that the class or operation is abstract.</p>
<p class="calibre1">In some design patterns it’s helpful to see where client classes reference Participant classes. When a pattern includes a Client class as one of its participants (meaning the client has a responsibility in the pattern), the Client appears as an ordinary class. This is true in Flyweight (<a href="part0014.html#page_195">195</a>), for example. When the pattern does not include a Client participant (i.e., clients have no responsibilities in the pattern), but including it nevertheless clarifies which pattern participants interact with clients, then the Client class is shown in gray, as shown in <a href="part0018.html#app02fig01">Figure B.1b</a>. An example is Proxy (<a href="part0014.html#page_207">207</a>). A gray Client also makes it clear that we haven’t accidentally omitted the Client from the Participants discussion.</p>
<p class="calibre1"><a href="part0018.html#app02fig01">Figure B.1c</a> shows various relationships between classes. The OMT notation for class inheritance is a triangle connecting a subclass (LineShape in the figure) to its parent class (Shape). An object reference representing a part-of or aggregation relationship is indicated by an arrowheaded line with a diamond at the base. The arrow points to the class that is aggregated (e.g., Shape). An arrowheaded line without the diamond denotes acquaintance (e.g., a LineShape keeps a reference to a Color object, which other shapes may share). A name for the reference may appear near the base to distinguish it from other references.<sup class="calibre8"><a id="app02fn_02"></a><a href="part0022.html#app02fn02">2</a></sup></p>
<p class="calibre1">Another useful thing to show is which classes instantiate which others. We use a dashed arrowheaded line to indicate this, since OMT doesn’t support it. We call this the “creates” relationship. The arrow points to the class that’s instantiated. In <a href="part0018.html#app02fig01">Figure B.1c</a>, CreationTool creates LineShape objects.</p>
<p class="calibre1">OMT also defines a filled circle to mean “more than one.” When the circle appears at the head of a reference, it means multiple objects are being referenced or aggregated. <a href="part0018.html#app02fig01">Figure B.1c</a> shows that Drawing aggregates multiple objects of type Shape.</p>
<p class="calibre1">Finally, we’ve augmented OMT with pseudocode annotations to let us sketch the implementations of operations. <a href="part0018.html#app02fig01">Figure B.1d</a> shows the pseudocode annotation for the Draw operation on the Drawing class.</p>
<p class="calibre1"><a id="app02sec1lev2"></a></p>
<h3 class="calibre2">B.2 Object Diagram</h3>
<p class="calibre1">An object diagram shows instances exclusively. It provides a snapshot of the objects in a design pattern. The objects are named <em class="calibre7">“aSomething”</em>, where <em class="calibre7">Something</em> is the class of the object. Our symbol for an object (modified slightly from standard OMT) is a rounded <a id="page_366"></a>box with a line separating the object name from any object references. Arrows indicate the object referenced. <a href="part0018.html#app02fig02">Figure B.2</a> shows an example.</p>
<p class="caption"><a id="app02fig02"></a>Figure B.2: Object diagram notation</p>
<p class="image"><img src="../images/00419.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1"><a id="app02sec1lev3"></a></p>
<h3 class="calibre2">B.3 Interaction Diagram</h3>
<p class="calibre1">An interaction diagram shows the order in which requests between objects get executed. <a href="part0018.html#app02fig03">Figure B.3</a> is an interaction diagram that shows how a shape gets added to a drawing.</p>
<p class="caption"><a id="app02fig03"></a>Figure B.3: Interaction diagram notation</p>
<p class="image"><img src="../images/00420.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">Time flows from top to bottom in an interaction diagram. A solid vertical line indicates the lifetime of a particular object. The naming convention for objects is the same as for object diagrams—the class name prefixed by the letter “a” (e.g., aShape). If the object doesn’t get instantiated until after the beginning of time as recorded in the diagram, then its vertical line appears dashed until the point of creation.</p>
<p class="calibre1">A vertical rectangle shows that an object is active; that is, it is handling a request. The operation can send requests to other objects; these are indicated with a horizontal arrow pointing to the receiving object. The name of the request is shown above the arrow. A request to create an object is shown with a dashed arrowheaded line. A request to the sending object itself points back to the sender.</p>
<p class="calibre1"><a id="page_367"></a><a href="part0018.html#app02fig03">Figure B.3</a> shows that the first request is from aCreationTool to create aLineShape. Later, aLineShape is Added to aDrawing, which prompts aDrawing to send a Refresh request to itself. Note that aDrawing sends a Draw request to aLineShape as part of the Refresh operation.</p>
</body></html>
