<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Chapter 2. A Case Study: Designing a Document Editor</title>
    <link href="page-template.xpgt" type="application/vnd.adobe-page-template+xml" rel="stylesheet"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="../page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<p class="calibre1"><a id="ch02"></a></p>
<div class="calibre5"></div><div class="calibre14" id="calibre_pb_0"></div><h2 class="calibre6" id="calibre_pb_1"><a id="page_33" class="calibre3"></a>Chapter 2. A Case Study: Designing a Document Editor</h2>
<p class="calibre1">This chapter presents a case study in the design of a “What-You-See-Is-What-You-Get” (or “WYSIWYG”) document editor called <strong class="calibre4">Lexi.</strong><sup class="calibre8"><a id="ch02fn_01"></a><a href="part0022.html#ch02fn01">1</a></sup> We’ll see how design patterns capture solutions to design problems in Lexi and applications like it. By the end of this chapter you will have gained experience with eight patterns, learning them by example.</p>
<p class="calibre1"><a href="part0011.html#ch02fig01">Figure 2.1</a> depicts Lexi’s user interface. A WYSIWYG representation of the document occupies the large rectangular area in the center. The document can mix text and graphics freely in a variety of formatting styles. Surrounding the document are the usual pull-down menus and scroll bars, plus a collection of page icons for jumping to a particular page in the document.</p>
<p class="caption"><a id="page_34"></a><a id="ch02fig01"></a>Figure 2.1: Lexi’s user interface</p>
<p class="image"><img src="../images/00013.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1"><a id="ch02sec1lev1"></a></p>
<h3 class="calibre2">2.1 Design Problems</h3>
<p class="calibre1">We will examine seven problems in Lexi’s design:</p>
<p class="indenthangingN">1. <em class="calibre7">Document structure.</em> The choice of internal representation for the document affects nearly every aspect of Lexi’s design. All editing, formatting, displaying, and textual analysis will require traversing the representation. The way we organize this information will impact the design of the rest of the application.</p>
<p class="indenthangingN">2. <em class="calibre7">Formatting.</em> How does Lexi actually arrange text and graphics into lines and columns? What objects are responsible for carrying out different formatting policies? How do these policies interact with the document’s internal representation?</p>
<p class="indenthangingN"><a id="page_35"></a>3. <em class="calibre7">Embellishing the user interface.</em> Lexi’s user interface includes scroll bars, borders, and drop shadows that embellish the WYSIWYG document interface. Such embellishments are likely to change as Lexi’s user interface evolves. Hence it’s important to be able to add and remove embellishments easily without affecting the rest of the application.</p>
<p class="indenthangingN">4. <em class="calibre7">Supporting multiple look-and-feel standards.</em> Lexi should adapt easily to different look-and-feel standards such as Motif and Presentation Manager (PM) without major modification.</p>
<p class="indenthangingN">5. <em class="calibre7">Supporting multiple window systems.</em> Different look-and-feel standards are usually implemented on different window systems. Lexi’s design should be as independent of the window system as possible.</p>
<p class="indenthangingN">6. <em class="calibre7">User operations.</em> Users control Lexi through various user interfaces, including buttons and pull-down menus. The functionality behind these interfaces is scattered throughout the objects in the application. The challenge here is to provide a uniform mechanism both for accessing this scattered functionality and for undoing its effects.</p>
<p class="indenthangingN">7. <em class="calibre7">Spelling checking and hyphenation.</em> How does Lexi support analytical operations such as checking for misspelled words and determining hyphenation points? How can we minimize the number of classes we have to modify to add a new analytical operation?</p>
<p class="calibre1">We discuss these design problems in the sections that follow. Each problem has an associated set of goals plus constraints on how we achieve those goals. We explain the goals and constraints in detail before proposing a specific solution. The problem and its solution will illustrate one or more design patterns. The discussion for each problem will culminate in a brief introduction to the relevant patterns.</p>
<p class="calibre1"><a id="ch02sec1lev2"></a></p>
<h3 class="calibre2">2.2 Document Structure</h3>
<p class="calibre1">A document is ultimately just an arrangement of basic graphical elements such as characters, lines, polygons, and other shapes. These elements capture the total information content of the document. Yet an author often views these elements not in graphical terms but in terms of the document’s physical structure—lines, columns, figures, tables, and other substructures.<sup class="calibre8"><a id="ch02fn_02"></a><a href="part0022.html#ch02fn02">2</a></sup> In turn, these substructures have substructures of their own, and so on.</p>
<p class="calibre1">Lexi’s user interface should let users manipulate these substructures directly. For example, a user should be able to treat a diagram as a unit rather than as a collection of <a id="page_36"></a>individual graphical primitives. The user should be able to refer to a table as a whole, not as an unstructured mass of text and graphics. That helps make the interface simple and intuitive. To give Lexi’s implementation similar qualities, we’ll choose an internal representation that matches the document’s physical structure.</p>
<p class="calibre1">In particular, the internal representation should support the following:</p>
<p class="indenthangingB1">• Maintaining the document’s physical structure, that is, the arrangement of text and graphics into lines, columns, tables, etc.</p>
<p class="indenthangingB1">• Generating and presenting the document visually.</p>
<p class="indenthangingB1">• Mapping positions on the display to elements in the internal representation. This lets Lexi determine what the user is referring to when he points to something in the visual representation.</p>
<p class="calibre1">In addition to these goals are some constraints. First, we should treat text and graphics uniformly. The application’s interface lets the user embed text within graphics freely and vice versa. We should avoid treating graphics as a special case of text or text as a special case of graphics; otherwise we’ll end up with redundant formatting and manipulation mechanisms. One set of mechanisms should suffice for both text and graphics.</p>
<p class="calibre1">Second, our implementation shouldn’t have to distinguish between single elements and groups of elements in the internal representation. Lexi should be able to treat simple and complex elements uniformly, thereby allowing arbitrarily complex documents. The tenth element in line five of column two, for instance, could be a single character or an intricate diagram with many subelements. As long as we know this element can draw itself and specify its dimensions, its complexity has no bearing on how and where it should appear on the page.</p>
<p class="calibre1">Opposing the second constraint, however, is the need to analyze the text for such things as spelling errors and potential hyphenation points. Often we don’t care whether the element of a line is a simple or complex object. But sometimes an analysis depends on the objects being analyzed. It makes little sense, for example, to check the spelling of a polygon or to hyphenate it. The internal representation’s design should take this and other potentially conflicting constraints into account.</p>
<p class="calibre1"><a id="ch02sec2lev1"></a></p>
<h4 class="calibre15">Recursive Composition</h4>
<p class="calibre1">A common way to represent hierarchically structured information is through a technique called <strong class="calibre4">recursive composition</strong>, which entails building increasingly complex elements out of simpler ones. Recursive composition gives us a way to compose a document out of simple graphical elements. As a first step, we can tile a set of characters and graphics from left to right to form a line in the document. Then multiple lines can be arranged to form a column, multiple columns can form a page, and so on (see <a href="part0011.html#ch02fig02">Figure 2.2</a>).</p>
<p class="caption"><a id="page_37"></a><a id="ch02fig02"></a>Figure 2.2: Recursive composition of text and graphics</p>
<p class="image"><img src="../images/00014.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1"><a id="page_38"></a>We can represent this physical structure by devoting an object to each important element. That includes not just the visible elements like the characters and graphics but the invisible, structural elements as well—the lines and the column. The result is the object structure shown in <a href="part0011.html#ch02fig03">Figure 2.3</a>.</p>
<p class="caption"><a id="ch02fig03"></a>Figure 2.3: Object structure for recursive composition of text and graphics</p>
<p class="image"><img src="../images/00015.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">By using an object for each character and graphical element in the document, we promote flexibility at the finest levels of Lexi’s design. We can treat text and graphics uniformly with respect to how they are drawn, formatted, and embedded within each other. We can extend Lexi to support new character sets without disturbing other functionality. Lexi’s object structure mimics the document’s physical structure.</p>
<p class="calibre1">This approach has two important implications. The first is obvious: The objects need corresponding classes. The second implication, which maybe less obvious, is that these classes must have compatible interfaces, because we want to treat the objects uniformly. The way to make interfaces compatible in a language like C++ is to relate the classes through inheritance.</p>
<p class="calibre1"><a id="ch02sec2lev2"></a></p>
<h4 class="calibre15">Glyphs</h4>
<p class="calibre1">We’ll define a <strong class="calibre4">Glyph</strong> abstract class for all objects that can appear in a document structure.<sup class="calibre8"><a id="ch02fn_03"></a><a href="part0022.html#ch02fn03">3</a></sup> Its subclasses define both primitive graphical elements (like characters and <a id="page_39"></a>images) and structural elements (like rows and columns). <a href="part0011.html#ch02fig04">Figure 2.4</a> depicts a representative part of the Glyph class hierarchy, and <a href="part0011.html#ch02tab01">Table 2.1</a> presents the basic glyph interface in more detail using C++ notation.<sup class="calibre8"><a id="ch02fn_04"></a><a href="part0022.html#ch02fn04">4</a></sup></p>
<p class="caption"><a id="ch02fig04"></a>Figure 2.4: Partial Glyph class hierarchy</p>
<p class="image"><img src="../images/00016.jpeg" alt="image" class="calibre11"/></p>
<p class="caption"><a id="ch02tab01"></a>Table 2.1: Basic glyph interface</p>
<p class="image"><img src="../images/00017.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">Glyphs have three basic responsibilities. They know (1) how to draw themselves, (2) what space they occupy, and (3) their children and parent.</p>
<p class="calibre1">Glyph subclasses redefine the <code class="calibre13">Draw</code> operation to render themselves onto a window. They are passed a reference to a <code class="calibre13">Window</code> object in the call to <code class="calibre13">Draw</code>. The <strong class="calibre4">Window</strong> class defines graphics operations for rendering text and basic shapes in a window on the screen. A <strong class="calibre4">Rectangle</strong> subclass of Glyph might redefine <code class="calibre13">Draw</code> as follows:</p>
<p class="programlisting"><img src="../images/00018.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">where <code class="calibre13">_x0</code>, <code class="calibre13">_y0</code>, <code class="calibre13">_x1</code>, and <code class="calibre13">_y1</code> are data members of <code class="calibre13">Rectangle</code> that define two opposing corners of the rectangle. <code class="calibre13">DrawRect</code> is the Window operation that makes the rectangle appear on the screen.</p>
<p class="calibre1">A parent glyph often needs to know how much space a child glyph occupies, for example, to arrange it and other glyphs in a line so that none overlaps (as shown in <a href="part0011.html#ch02fig02">Figure 2.2</a>). The <code class="calibre13">Bounds</code> operation returns the rectangular area that the glyph occupies. It returns the opposite corners of the smallest rectangle that contains the glyph. Glyph subclasses redefine this operation to return the rectangular area in which they draw.</p>
<p class="calibre1">The <code class="calibre13">Intersects</code> operation returns whether a specified point intersects the glyph. Whenever the user clicks somewhere in the document, Lexi calls this operation to determine which glyph or glyph structure is under the mouse. The Rectangle class redefines this operation to compute the intersection of the rectangle and the given point.</p>
<p class="calibre1"><a id="page_40"></a>Because glyphs can have children, we need a common interface to add, remove, and access those children. For example, a Row’s children are the glyphs it arranges into a row. The <code class="calibre13">Insert</code> operation inserts a glyph at a position specified by an integer index.<sup class="calibre8"><a id="ch02fn_05"></a><a href="part0022.html#ch02fn05">5</a></sup> The <code class="calibre13">Remove</code> operation removes a specified glyph if it is indeed a child.</p>
<p class="calibre1">The <code class="calibre13">Child</code> operation returns the child (if any) at the given index. Glyphs like Row that can have children should use <code class="calibre13">Child</code> internally instead of accessing the child data structure directly. That way you won’t have to modify operations like <code class="calibre13">Draw</code> that iterate through the children when you change the data structure from, say, an array to a linked list. Similarly, <code class="calibre13">Parent</code> provides a standard interface to the glyph’s parent, if any. Glyphs in Lexi store a reference to their parent, and their <code class="calibre13">Parent</code> operation simply returns this reference.</p>
<p class="calibre1"><a id="ch02sec2lev3"></a></p>
<h4 class="calibre15">Composite Pattern</h4>
<p class="calibre1">Recursive composition is good for more than just documents. We can use it to represent any potentially complex, hierarchical structure. The Composite (<a href="part0014.html#page_163">163</a>) pattern captures the essence of recursive composition in object-oriented terms. Now would be a good time to turn to that pattern and study it, referring back to this scenario as needed.</p>
<p class="calibre1"><a id="ch02sec1lev3"></a></p>
<h3 class="calibre2">2.3 Formatting</h3>
<p class="calibre1">We’ve settled on a way to <em class="calibre7">represent</em> the document’s physical structure. Next, we need to figure out how to construct a <em class="calibre7">particular</em> physical structure, one that corresponds to a properly formatted document. Representation and formatting are distinct: The ability to capture the document’s physical structure doesn’t tell us how to arrive at a particular structure. This responsibility rests mostly on Lexi. It must break text into lines, lines into columns, and so on, taking into account the user’s higher-level desires. For example, the user might want to vary margin widths, indentation, and tabulation; single or double space; and probably many other formatting constraints.<sup class="calibre8"><a id="ch02fn_06"></a><a href="part0022.html#ch02fn06">6</a></sup> Lexi’s formatting algorithm must take all of these into account.</p>
<p class="calibre1">By the way, we’ll restrict “formatting” to mean breaking a collection of glyphs into lines. In fact, we’ll use the terms “formatting” and “linebreaking” interchangeably. The techniques we’ll discuss apply equally well to breaking lines into columns and to breaking columns into pages.</p>
<p class="calibre1"><a id="ch02sec2lev4"></a></p>
<h4 class="calibre15"><a id="page_41"></a>Encapsulating the Formatting Algorithm</h4>
<p class="calibre1">The formatting process, with all its constraints and details, isn’t easy to automate. There are many approaches to the problem, and people have come up with a variety of formatting algorithms with different strengths and weaknesses. Because Lexi is a WYSIWYG editor, an important trade-off to consider is the balance between formatting quality and formatting speed. We want generally good response from the editor without sacrificing how good the document looks. This trade-off is subject to many factors, not all of which can be ascertained at compile-time. For example, the user might tolerate slightly slower response in exchange for better formatting. That trade-off might make an entirely different formatting algorithm more appropriate than the current one. Another, more implementation-driven trade-off balances formatting speed and storage requirements: It may be possible to decrease formatting time by caching more information.</p>
<p class="calibre1">Because formatting algorithms tend to be complex, it’s also desirable to keep them well-contained or—better yet—completely independent of the document structure. Ideally we could add a new kind of Glyph subclass without regard to the formatting algorithm. Conversely, adding a new formatting algorithm shouldn’t require modifying existing glyphs.</p>
<p class="calibre1">These characteristics suggest we should design Lexi so that it’s easy to change the formatting algorithm at least at compile-time, if not at run-time as well. We can isolate the algorithm and make it easily replaceable at the same time by encapsulating it in an object. More specifically, we’ll define a separate class hierarchy for objects that encapsulate formatting algorithms. The root of the hierarchy will define an interface that supports a wide range of formatting algorithms, and each subclass will implement the interface to carry out a particular algorithm. Then we can introduce a Glyph subclass that will structure its children automatically using a given algorithm object.</p>
<p class="calibre1"><a id="ch02sec2lev5"></a></p>
<h4 class="calibre15">Compositor and Composition</h4>
<p class="calibre1">We’ll define a <strong class="calibre4">Compositor</strong> class for objects that can encapsulate a formatting algorithm. The interface (<a href="part0011.html#ch02tab02">Table 2.2</a>) lets the compositor know <em class="calibre7">what</em> glyphs to format and <em class="calibre7">when</em> to do the formatting. The glyphs it formats are the children of a special Glyph subclass called <strong class="calibre4">Composition.</strong> A composition gets an instance of a Compositor subclass (specialized for a particular linebreaking algorithm) when it is created, and it tells the compositor to <code class="calibre13">Compose</code> its glyphs when necessary, for example, when the user changes a document. <a href="part0011.html#ch02fig05">Figure 2.5</a> depicts the relationships between the Composition and Compositor classes.</p>
<p class="caption"><a id="ch02tab02"></a>Table 2.2: Basic compositor interface</p>
<p class="image"><img src="../images/00019.jpeg" alt="image" class="calibre11"/></p>
<p class="caption"><a id="page_42"></a><a id="ch02fig05"></a>Figure 2.5: Composition and Compositor class relationships</p>
<p class="image"><img src="../images/00020.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">An unformatted Composition object contains only the visible glyphs that make up the document’s basic content. It doesn’t contain glyphs that determine the document’s physical structure, such as Row and Column. The composition is in this state just after it’s created and initialized with the glyphs it should format. When the composition needs formatting, it calls its compositor’s <code class="calibre13">Compose</code> operation. The compositor in turn iterates through the composition’s children and inserts new Row and Column glyphs according to its linebreaking algorithm.<sup class="calibre8"><a id="ch02fn_07"></a><a href="part0022.html#ch02fn07">7</a></sup> <a href="part0011.html#ch02fig06">Figure 2.6</a> shows the resulting object structure. Glyphs that the compositor created and inserted into the object structure appear with gray backgrounds in the figure.</p>
<p class="caption"><a id="ch02fig06"></a>Figure 2.6: Object structure reflecting compositor-directed linebreaking</p>
<p class="image"><img src="../images/00021.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">Each Compositor subclass can implement a different linebreaking algorithm. For example, a SimpleCompositor might do a quick pass without regard for such esoterica as the document’s “color.” Good color means having an even distribution of text and whitespace. A TeXCompositor would implement the full T<sub class="calibre17">E</sub>X algorithm <a href="part0020.html#bib01_046">[Knu84]</a>, which takes things like color into account in exchange for longer formatting times.</p>
<p class="calibre1">The Compositor-Composition class split ensures a strong separation between code that supports the document’s physical structure and the code for different formatting algorithms. We can add new Compositor subclasses without touching the glyph classes, and vice versa. In fact, we can change the linebreaking algorithm at run-time by adding a single <code class="calibre13">SetCompositor</code> operation to Composition’s basic glyph interface.</p>
<p class="calibre1"><a id="ch02sec2lev6"></a></p>
<h4 class="calibre15">Strategy Pattern</h4>
<p class="calibre1">Encapsulating an algorithm in an object is the intent of the Strategy (<a href="part0015.html#page_315">315</a>) pattern. The key participants in the pattern are Strategy objects (which encapsulate different algorithms) and the context in which they operate. Compositors are strategies; they encapsulate <a id="page_43"></a>different formatting algorithms. A composition is the context for a compositor strategy.</p>
<p class="calibre1">The key to applying the Strategy pattern is designing interfaces for the strategy and its context that are general enough to support a range of algorithms. You shouldn’t have to change the strategy or context interface to support a new algorithm. In our example, the basic Glyph interface’s support for child access, insertion, and removal is general enough to let Compositor subclasses change the document’s physical structure, regardless of the algorithm they use to do it. Likewise, the Compositor interface gives compositions whatever they need to initiate formatting.</p>
<p class="calibre1"><a id="ch02sec1lev4"></a></p>
<h3 class="calibre2">2.4 Embellishing the User Interface</h3>
<p class="calibre1">We consider two embellishments in Lexi’s user interface. The first adds a border around the text editing area to demarcate the page of text. The second adds scroll bars that let the user view different parts of the page. To make it easy to add and remove these embellishments (especially at run-time), we shouldn’t use inheritance to add them to the user interface. We achieve the most flexibility if other user interface objects don’t even know the embellishments are there. That will let us add and remove the embellishments without changing other classes.</p>
<p class="calibre1"><a id="ch02sec2lev7"></a></p>
<h4 class="calibre15">Transparent Enclosure</h4>
<p class="calibre1">From a programming point of view, embellishing the user interface involves extending existing code. Using inheritance to do such extension precludes rearranging embellishments <a id="page_44"></a>at run-time, but an equally serious problem is the explosion of classes that can result from an inheritance-based approach.</p>
<p class="calibre1">We could add a border to Composition by subclassing it to yield a BorderedComposition class. Or we could add a scrolling interface in the same way to yield a Scrollable-Composition. If we want both scroll bars and a border, we might produce a Bordered-ScrollableComposition, and so forth. In the extreme, we end up with a class for every possible combination of embellishments, a solution that quickly becomes unworkable as the variety of embellishments grows.</p>
<p class="calibre1">Object composition offers a potentially more workable and flexible extension mechanism. But what objects do we compose? Since we know we’re embellishing an existing glyph, we could make the embellishment itself an object (say, an instance of class Border). That gives us two candidates for composition, the glyph and the border. The next step is to decide who composes whom. We could have the border contain the glyph, which makes sense given that the border will surround the glyph on the screen. Or we could do the opposite—put the border into the glyph—but then we must make modifications to the corresponding Glyph subclass to make it aware of the border. Our first choice, composing the glyph in the border, keeps the border-drawing code entirely in the Border class, leaving other classes alone.</p>
<p class="calibre1">What does the Border class look like? The fact that borders have an appearance suggests they should actually be glyphs; that is, Border should be a subclass of Glyph. But there’s a more compelling reason for doing this: Clients shouldn’t care whether glyphs have borders or not. They should treat glyphs uniformly. When clients tell a plain, unbordered glyph to draw itself, it should do so without embellishment. If that glyph is composed in a border, clients shouldn’t have to treat the border containing the glyph any differently; they just tell it to draw itself as they told the plain glyph before. This implies that the Border interface matches the Glyph interface. We subclass Border from Glyph to guarantee this relationship.</p>
<p class="calibre1">All this leads us to the concept of <strong class="calibre4">transparent enclosure</strong>, which combines the notions of (1) single-child (or single-<strong class="calibre4">component</strong>) composition and (2) compatible interfaces. Clients generally can’t tell whether they’re dealing with the component or its <strong class="calibre4">enclosure</strong> (i.e., the child’s parent), especially if the enclosure simply delegates all its operations to its component. But the enclosure can also <em class="calibre7">augment</em> the component’s behavior by doing work of its own before and/or after delegating an operation. The enclosure can also effectively add state to the component. We’ll see how next.</p>
<p class="calibre1"><a id="ch02sec2lev8"></a></p>
<h4 class="calibre15">Monoglyph</h4>
<p class="calibre1">We can apply the concept of transparent enclosure to all glyphs that embellish other glyphs. To make this concept concrete, we’ll define a subclass of Glyph called <strong class="calibre4">MonoGlyph</strong> to serve as an abstract class for “embellishment glyphs,” like Border (see <a href="part0011.html#ch02fig07">Figure 2.7</a>). MonoGlyph stores a reference to a component and forwards all requests to it.</p>
<p class="caption"><a id="page_45"></a><a id="ch02fig07"></a>Figure 2.7: MonoGlyph class relationships</p>
<p class="image"><img src="../images/00022.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">That makes MonoGlyph totally transparent to clients by default. For example, MonoGlyph implements the <code class="calibre13">Draw</code> operation like this:</p>
<p class="programlisting"><img src="../images/00023.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">MonoGlyph subclasses reimplement at least one of these forwarding operations. <code class="calibre13">Border::Draw</code>, for instance, first invokes the parent class operation <code class="calibre13">MonoGlyph::Draw</code> on the component to let the component do its part—that is, draw everything but the border. Then <code class="calibre13">Border::Draw</code> draws the border by calling a private operation called <code class="calibre13">DrawBorder</code>, the details of which we’ll omit:</p>
<p class="programlisting"><img src="../images/00024.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">Notice how <code class="calibre13">Border::Draw</code> effectively <em class="calibre7">extends</em> the parent class operation to draw the border. This is in contrast to merely <em class="calibre7">replacing</em> the parent class operation, which would omit the call to <code class="calibre13">MonoGlyph::Draw</code>.</p>
<p class="calibre1">Another MonoGlyph subclass appears in <a href="part0011.html#ch02fig07">Figure 2.7</a>. <strong class="calibre4">Scroller</strong> is a MonoGlyph that draws its component in different locations based on the positions of two scroll bars, which it adds as embellishments. When Scroller draws its component, it tells the graphics system to clip to its bounds. Clipping parts of the component that are scrolled out of view keeps them from appearing on the screen.</p>
<p class="calibre1">Now we have all the pieces we need to add a border and a scrolling interface to Lexi’s text editing area. We compose the existing Composition instance in a Scroller instance to add the scrolling interface, and we compose that in a Border instance. The resulting object structure appears in <a href="part0011.html#ch02fig08">Figure 2.8</a>.</p>
<p class="caption"><a id="page_46"></a><a id="ch02fig08"></a>Figure 2.8: Embellished object structure</p>
<p class="image"><img src="../images/00025.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1"><a id="page_47"></a>Note that we can reverse the order of composition, putting the bordered composition into the Scroller instance. In that case the border would be scrolled along with the text, which may or may not be desirable. The point is, transparent enclosure makes it easy to experiment with different alternatives, and it keeps clients free of embellishment code.</p>
<p class="calibre1">Note also how the border composes one glyph, not two or more. This is unlike compositions we’ve defined so far, in which parent objects were allowed to have arbitrarily many children. Here, putting a border around something implies that “something” is singular. We could assign a meaning to embellishing more than one object at a time, but then we’d have to mix many kinds of composition in with the notion of embellishment: row embellishment, column embellishment, and so forth. That won’t help us, since we already have classes to do those kinds of compositions. So it’s better to use existing classes for composition and add new classes to embellish the result. Keeping embellishment independent of other kinds of composition both simplifies the embellishment classes and reduces their number. It also keeps us from replicating existing composition functionality.</p>
<p class="calibre1"><a id="ch02sec2lev9"></a></p>
<h4 class="calibre15">Decorator Pattern</h4>
<p class="calibre1">The Decorator (<a href="part0014.html#page_175">175</a>) pattern captures class and object relationships that support embellishment by transparent enclosure. The term “embellishment” actually has broader meaning than what we’ve considered here. In the Decorator pattern, embellishment refers to anything that adds responsibilities to an object. We can think for example of embellishing an abstract syntax tree with semantic actions, a finite state automaton with new transitions, or a network of persistent objects with attribute tags. Decorator generalizes the approach we’ve used in Lexi to make it more widely applicable.</p>
<p class="calibre1"><a id="ch02sec1lev5"></a></p>
<h3 class="calibre2">2.5 Supporting Multiple Look-and-Feel Standards</h3>
<p class="calibre1">Achieving portability across hardware and software platforms is a major problem in system design. Retargeting Lexi to a new platform shouldn’t require a major overhaul, or it wouldn’t be worth retargeting. We should make porting as easy as possible.</p>
<p class="calibre1">One obstacle to portability is the diversity of look-and-feel standards, which are intended to enforce uniformity between applications. These standards define guidelines for how applications appear and react to the user. While existing standards aren’t that different from each other, people certainly won’t confuse one for the other—Motif applications don’t look and feel exactly like their counterparts on other platforms, and vice versa. An application that runs on more than one platform must conform to the user interface style guide on each platform.</p>
<p class="calibre1">Our design goals are to make Lexi conform to multiple existing look-and-feel standards and to make it easy to add support for new standards as they (invariably) emerge. We <a id="page_48"></a>also want our design to support the ultimate in flexibility: changing Lexi’s look and feel at run-time.</p>
<p class="calibre1"><a id="ch02sec2lev10"></a></p>
<h4 class="calibre15">Abstracting Object Creation</h4>
<p class="calibre1">Everything we see and interact with in Lexi’s user interface is a glyph composed in other, invisible glyphs like Row and Column. The invisible glyphs compose visible ones like Button and Character and lay them out properly. Style guides have much to say about the look and feel of so-called “widgets,” another term for visible glyphs like buttons, scroll bars, and menus that act as controlling elements in a user interface. Widgets might use simpler glyphs such as characters, circles, rectangles, and polygons to present data.</p>
<p class="calibre1">We’ll assume we have two sets of widget glyph classes with which to implement multiple look-and-feel standards:</p>
<p class="indenthangingN">1. A set of abstract Glyph subclasses for each category of widget glyph. For example, an abstract class ScrollBar will augment the basic glyph interface to add general scrolling operations; Button is an abstract class that adds button-oriented operations; and so on.</p>
<p class="indenthangingN">2. A set of concrete subclasses for each abstract subclass that implement different look-and-feel standards. For example, ScrollBar might have Motif ScrollBar and PMScrollBar subclasses that implement Motif and Presentation Manager-style scroll bars, respectively.</p>
<p class="calibre1">Lexi must distinguish between widget glyphs for different look-and-feel styles. For example, when Lexi needs to put a button in its interface, it must instantiate a Glyph subclass for the right style of button (MotifButton, PMButton, MacButton, etc.).</p>
<p class="calibre1">It’s clear that Lexi’s implementation can’t do this directly, say, using a constructor call in C++. That would hard-code the button of a particular style, making it impossible to select the style at run-time. We’d also have to track down and change every such constructor call to port Lexi to another platform. And buttons are only one of a variety of widgets in Lexi’s user interface. Littering our code with constructor calls to specific look-and-feel classes yields a maintenance nightmare—miss just one, and you could end up with a Motif menu in the middle of your Mac application.</p>
<p class="calibre1">Lexi needs a way to determine the look-and-feel standard that’s being targeted in order to create the appropriate widgets. Not only must we avoid making explicit constructor calls; we must also be able to replace an entire widget set easily. We can achieve both by <em class="calibre7">abstracting the process of object creation.</em> An example will illustrate what we mean.</p>
<p class="calibre1"><a id="ch02sec2lev11"></a></p>
<h4 class="calibre15"><a id="page_49"></a>Factories and Product Classes</h4>
<p class="calibre1">Normally we might create an instance of a Motif scroll bar glyph with the following C++ code:</p>
<p class="programlisting">ScrollBar* sb = new MotifScrollBar;</p>
<p class="calibre1">This is the kind of code to avoid if you want to minimize Lexi’s look-and-feel dependencies. But suppose we initialize sb as follows:</p>
<p class="programlisting">ScrollBar* sb = guiFactory-&gt;CreateScrollBar();</p>
<p class="calibre1">where <code class="calibre13">guiFactory</code> is an instance of a <strong class="calibre4">MotifFactory</strong> class. <code class="calibre13">CreateScrollBar</code> returns a new instance of the proper ScrollBar subclass for the look and feel desired, Motif in this case. As far as clients are concerned, the effect is the same as calling the MotifScrollBar constructor directly. But there’s a crucial difference: There’s no longer anything in the code that mentions Motif by name. The <code class="calibre13">guiFactory</code> object abstracts the process of creating not just Motif scroll bars but scroll bars for <em class="calibre7">any</em> look-and-feel standard. And <code class="calibre13">guiFactory</code> isn’t limited to producing scroll bars. It can manufacture a full range of widget glyphs, including scroll bars, buttons, entry fields, menus, and so forth.</p>
<p class="calibre1">All this is possible because MotifFactory is a subclass of <strong class="calibre4">GUIFactory</strong>, an abstract class that defines a general interface for creating widget glyphs. It includes operations like <code class="calibre13">CreateScrollBar</code> and <code class="calibre13">CreateButton</code> for instantiating different kinds of widget glyphs. Subclasses of GUIFactory implement these operations to return glyphs such as MotifScrollBar and PMButton that implement a particular look and feel. <a href="part0011.html#ch02fig09">Figure 2.9</a> shows the resulting class hierarchy for <code class="calibre13">guiFactory</code> objects.</p>
<p class="caption"><a id="ch02fig09"></a>Figure 2.9: GUIFactory class hierarchy</p>
<p class="image"><img src="../images/00026.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">We say that factories create <strong class="calibre4">product</strong> objects. Moreover, the products that a factory produces are related to one another; in this case, the products are all widgets for the same look and feel. <a href="part0011.html#ch02fig10">Figure 2.10</a> shows some of the product classes needed to make factories work for widget glyphs.</p>
<p class="caption"><a id="page_50"></a><a id="ch02fig10"></a>Figure 2.10: Abstract product classes and concrete subclasses</p>
<p class="image"><img src="../images/00027.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">The last question we have to answer is, Where does the <code class="calibre13">GUIFactory</code> instance come from? The answer is, Anywhere that’s convenient. The variable <code class="calibre13">guiFactory</code> could be a global, a static member of a well-known class, or even a local variable if the entire user interface is created within one class or function. There’s even a design pattern, Singleton (<a href="part0013.html#page_127">127</a>), for managing well-known, one-of-a-kind objects like this. The important thing, though, is to initialize <code class="calibre13">guiFactory</code> at a point in the program <em class="calibre7">before</em> it’s ever used to create widgets but <em class="calibre7">after</em> it’s clear which look and feel is desired.</p>
<p class="calibre1">If the look and feel is known at compile-time, then <code class="calibre13">guiFactory</code> can be initialized with a simple assignment of a new factory instance at the beginning of the program:</p>
<p class="programlisting">GUIFactory* guiFactory = new MotifFactory;</p>
<p class="calibre1">If the user can specify the look and feel with a string name at startup time, then the code to create the factory might be</p>
<p class="programlisting"><a id="page_51"></a><img src="../images/00028.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">There are more sophisticated ways to select the factory at run-time. For example, you could maintain a registry that maps strings to factory objects. That lets you register instances of new factory subclasses without modifying existing code, as the preceding approach requires. And you don’t have to link all platform-specific factories into the application. That’s important, because it might not be possible to link a MotifFactory on a platform that doesn’t support Motif.</p>
<p class="calibre1">But the point is that once we’ve configured the application with the right factory object, its look and feel is set from then on. If we change our minds, we can reinitialize <code class="calibre13">guiFactory</code> with a factory for a different look and feel and then reconstruct the interface. Regardless of how and when we decide to initialize <code class="calibre13">guiFactory</code>, we know that once we do, the application can create the appropriate look and feel without modification.</p>
<p class="calibre1"><a id="ch02sec2lev12"></a></p>
<h4 class="calibre15">Abstract Factory Pattern</h4>
<p class="calibre1">Factories and products are the key participants in the Abstract Factory (<a href="part0013.html#page_87">87</a>) pattern. This pattern captures how to create families of related product objects without instantiating classes directly. It’s most appropriate when the number and general kinds of product objects stay constant, and there are differences in specific product families. We choose between families by instantiating a particular concrete factory and using it consistently to create products thereafter. We can also swap entire families of products by replacing the concrete factory with an instance of a different one. The Abstract Factory pattern’s emphasis on <em class="calibre7">families</em> of products distinguishes it from other creational patterns, which involve only one kind of product object.</p>
<p class="calibre1"><a id="ch02sec1lev6"></a></p>
<h3 class="calibre2">2.6 Supporting Multiple Window Systems</h3>
<p class="calibre1">Look and feel is just one of many portability issues. Another is the windowing environment in which Lexi runs. A platform’s window system creates the illusion of multiple overlapping windows on a bitmapped display. It manages screen space for <a id="page_52"></a>windows and routes input to them from the keyboard and mouse. Several important and largely incompatible window systems exist today (e.g., Macintosh, Presentation Manager, Windows, X). We’d like Lexi to run on as many of them as possible for exactly the same reasons we support multiple look-and-feel standards.</p>
<p class="calibre1"><a id="ch02sec2lev13"></a></p>
<h4 class="calibre15">Can We Use an Abstract Factory?</h4>
<p class="calibre1">At first glance this may look like another opportunity to apply the Abstract Factory pattern. But the constraints for window system portability differ significantly from those for look-and-feel independence.</p>
<p class="calibre1">In applying the Abstract Factory pattern, we assumed we would define the concrete widget glyph classes for each look-and-feel standard. That meant we could derive each concrete product for a particular standard (e.g., MotifScrollBar and MacScrollBar) from an abstract product class (e.g., ScrollBar). But suppose we already have several class hierarchies from different vendors, one for each look-and-feel standard. Of course, it’s highly unlikely these hierarchies are compatible in any way. Hence we won’t have a common abstract product class for each kind of widget (ScrollBar, Button, Menu, etc.)—and the Abstract Factory pattern won’t work without those crucial classes. We have to make the different widget hierarchies adhere to a common set of abstract product interfaces. Only then could we declare the <code class="calibre13">Create</code>. . . operations properly in our abstract factory’s interface.</p>
<p class="calibre1">We solved this problem for widgets by developing our own abstract and concrete product classes. Now we’re faced with a similar problem when we try to make Lexi work on existing window systems; namely, different window systems have incompatible programming interfaces. Things are a bit tougher this time, though, because we can’t afford to implement our own nonstandard window system.</p>
<p class="calibre1">But there’s a saving grace. Like look-and-feel standards, window system interfaces aren’t radically different from one another, because all window systems do generally the same thing. We need a uniform set of windowing abstractions that lets us take different window system implementations and slide any one of them under a common interface.</p>
<p class="calibre1"><a id="ch02sec2lev14"></a></p>
<h4 class="calibre15">Encapsulating Implementation Dependencies</h4>
<p class="calibre1">In <a href="part0011.html#ch02sec1lev2">Section 2.2</a> we introduced a Window class for displaying a glyph or glyph structure on the display. We didn’t specify the window system that this object worked with, because the truth is that it doesn’t come from any particular window system. The Window class encapsulates the things windows tend to do across window systems:</p>
<p class="indenthangingB1">• They provide operations for drawing basic geometric shapes.</p>
<p class="indenthangingB1">• They can iconify and de-iconify themselves.</p>
<p class="indenthangingB1"><a id="page_53"></a>• They can resize themselves.</p>
<p class="indenthangingB1">• They can (re)draw their contents on demand, for example, when they are deiconified or when an overlapped and obscured portion of their screen space is exposed.</p>
<p class="calibre1">The Window class must span the functionality of windows from different window systems. Let’s consider two extreme philosophies:</p>
<p class="indenthangingN">1. <em class="calibre7">Intersection of functionality.</em> The Window class interface provides only functionality that’s common to <em class="calibre7">all</em> window systems. The problem with this approach is that our Window interface winds up being only as powerful as the least capable window system. We can’t take advantage of more advanced features even if most (but not all) window systems support them.</p>
<p class="indenthangingN">2. <em class="calibre7">Union of functionality.</em> Create an interface that incorporates the capabilities of <em class="calibre7">all</em> existing systems. The trouble here is that the resulting interface may well be huge and incoherent. Besides, we’ll have to change it (and Lexi, which depends on it) anytime a vendor revises its window system interface.</p>
<p class="calibre1">Neither extreme is a viable solution, so our design will fall somewhere between the two. The Window class will provide a convenient interface that supports the most popular windowing features. Because Lexi will deal with this class directly, the Window class must also support the things Lexi knows about, namely, glyphs. That means Window’s interface must include a basic set of graphics operations that lets glyphs draw themselves in the window. <a href="part0011.html#ch02tab03">Table 2.3</a> gives a sampling of the operations in the Window class interface.</p>
<p class="caption"><a id="ch02tab03"></a>Table 2.3: Window class interface</p>
<p class="image"><img src="../images/00029.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">Window is an abstract class. Concrete subclasses of Window support the different kinds of windows that users deal with. For example, application windows, icons, and warning dialogs are all windows, but they have somewhat different behaviors. So we can define subclasses like ApplicationWindow, Icon Window, and DialogWindow to capture these <a id="page_54"></a>differences. The resulting class hierarchy gives applications like Lexi a uniform and intuitive windowing abstraction, one that doesn’t depend on any particular vendor’s window system:</p>
<p class="image"><img src="../images/00030.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">Now that we’ve defined a window interface for Lexi to work with, where does the real platform-specific window come in? If we’re not implementing our own window system, then at some point our window abstraction must be implemented in terms of what the target window system provides. So where does that implementation live?</p>
<p class="calibre1">One approach is to implement multiple versions of the Window class and its subclasses, one version for each windowing platform. We’d have to choose the version to use when we build Lexi for a given platform. But imagine the maintenance headaches we’d have keeping track of multiple classes, all named “Window” but each implemented on a different window system. Alternatively, we could create implementation-specific subclasses of each class in the Window hierarchy—and end up with another subclass explosion problem like the one we had trying to add embellishments. Both of these alternatives have another drawback: Neither gives us the flexibility to change the window system we use after we’ve compiled the program. So we’ll have to keep several different executables around as well.</p>
<p class="calibre1">Neither alternative is very appealing, but what else can we do? The same thing we did for formatting and embellishment, namely, <em class="calibre7">encapsulate the concept that varies.</em> What varies in this case is the window system implementation. If we encapsulate a window system’s functionality in an object, then we can implement our Window class and subclasses in terms of that object’s interface. Moreover, if that interface can serve all the window systems we’re interested in, then we won’t have to change Window or any of its subclasses to support different window systems. We can configure window objects to the window system we want simply by passing them the right window system-encapsulating object. We can even configure the window at run-time.</p>
<p class="calibre1"><a id="ch02sec2lev15"></a></p>
<h4 class="calibre15"><a id="page_55"></a>Window and WindowImp</h4>
<p class="calibre1">We’ll define a separate <strong class="calibre4">WindowImp</strong> class hierarchy in which to hide different window system implementations. WindowImp is an abstract class for objects that encapsulate window system-dependent code. To make Lexi work on a particular window system, we configure each window object with an instance of a WindowImp subclass for that system. The following diagram shows the relationship between the Window and WindowImp hierarchies:</p>
<p class="image"><img src="../images/00031.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">By hiding the implementations in WindowImp classes, we avoid polluting the Window classes with window system dependencies, which keeps the Window class hierarchy comparatively small and stable. Meanwhile we can easily extend the implementation hierarchy to support new window systems.</p>
<p class="calibre1"><a id="ch02sec3lev1"></a></p>
<h5 class="calibre16">WindowImp Subclasses</h5>
<p class="calibre1">Subclasses of WindowImp convert requests into window system-specific operations. Consider the example we used in <a href="part0011.html#ch02sec1lev2">Section 2.2</a>. We defined the <code class="calibre13">Rectangle::Draw</code> in terms of the <code class="calibre13">DrawRect</code> operation on the Window instance:</p>
<p class="programlisting"><img src="../images/00032.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">The default implementation of <code class="calibre13">DrawRect</code> uses the abstract operation for drawing rectangles declared by WindowImp:</p>
<p class="programlisting"><img src="../images/00033.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1"><a id="page_56"></a>where <code class="calibre13">_imp</code> is a member variable of Window that stores the WindowImp with which the Window is configured. The window implementation is defined by the instance of the WindowImp subclass that <code class="calibre13">_imp</code> points to. For an XWindowImp (that is, a WindowImp subclass for the X Window System), the <code class="calibre13">DeviceRect</code>’s implementation might look like</p>
<p class="programlisting"><img src="../images/00034.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1"><code class="calibre13">DeviceRect</code> is defined like this because <code class="calibre13">XDrawRectangle</code> (the X interface for drawing a rectangle) defines a rectangle in terms of its lower left corner, its width, and its height. <code class="calibre13">DeviceRect</code> must compute these values from those supplied. First it ascertains the lower left corner (since (<code class="calibre13">x0</code>, <code class="calibre13">y0</code>) might be any one of the rectangle’s four corners) and then calculates the width and height.</p>
<p class="calibre1">PMWindowImp (a subclass of WindowImp for Presentation Manager) would define <code class="calibre13">DeviceRect</code> differently:</p>
<p class="programlisting"><img src="../images/00035.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1"><a id="page_57"></a>Why is this so different from the X version? Well, PM doesn’t have an operation for drawing rectangles explicitly as X does. Instead, PM has a more general interface for specifying vertices of multisegment shapes (called a <strong class="calibre4">path)</strong> and for outlining or filling the area they enclose.</p>
<p class="calibre1">PM’s implementation of <code class="calibre13">DeviceRect</code> is obviously quite different from X’s, but that doesn’t matter. WindowImp hides variations in window system interfaces behind a potentially large but stable interface. That lets Window subclass writers focus on the window abstraction and not on window system details. It also lets us add support for new window systems without disturbing the Window classes.</p>
<p class="calibre1"><a id="ch02sec3lev2"></a></p>
<h5 class="calibre16">Configuring Windows with WindowImps</h5>
<p class="calibre1">A key issue we haven’t addressed is how a window gets configured with the proper WindowImp subclass in the first place. Stated another way, when does <code class="calibre13">_imp</code> get initialized, and who knows what window system (and consequently which WindowImp subclass) is in use? The window will need some kind of WindowImp before it can do anything interesting.</p>
<p class="calibre1">There are several possibilities, but we’ll focus on one that uses the Abstract Factory (<a href="part0013.html#page_87">87</a>) pattern. We can define an abstract factory class WindowSystemFactory that provides an interface for creating different kinds of window system-dependent implementation objects:</p>
<p class="programlisting"><img src="../images/00036.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">Now we can define a concrete factory for each window system:</p>
<p class="programlisting"><img src="../images/00037.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">The Window base class constructor can use the <code class="calibre13">WindowSystemFactory</code> interface to initialize the <code class="calibre13">_imp</code> member with the WindowImp that’s right for the window system:</p>
<p class="programlisting"><a id="page_58"></a><img src="../images/00038.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">The <code class="calibre13">windowSystemFactory</code> variable is a well-known instance of a WindowSystemFactory subclass, akin to the well-known <code class="calibre13">guiFactory</code> variable defining the look and feel. The <code class="calibre13">windowSystemFactory</code> variable can be initialized in the same way.</p>
<p class="calibre1"><a id="ch02sec2lev16"></a></p>
<h4 class="calibre15">Bridge Pattern</h4>
<p class="calibre1">The WindowImp class defines an interface to common window system facilities, but its design is driven by different constraints than Window’s interface. Application programmers won’t deal with WindowImp’s interface directly; they only deal with Window objects. So WindowImp’s interface needn’t match the application programmer’s view of the world, as was our concern in the design of the Window class hierarchy and interface. WindowImp’s interface can more closely reflect what window systems actually provide, warts and all. It can be biased toward either an intersection or a union of functionality approach, whichever suits the target window systems best.</p>
<p class="calibre1">The important thing to realize is that Window’s interface caters to the applications programmer, while WindowImp caters to window systems. Separating windowing functionality into Window and WindowImp hierarchies lets us implement and specialize these interfaces independently. Objects from these hierarchies cooperate to let Lexi work without modification on multiple window systems.</p>
<p class="calibre1">The relationship between Window and WindowImp is an example of the Bridge (<a href="part0014.html#page_151">151</a>) pattern. The intent behind Bridge is to allow separate class hierarchies to work together even as they evolve independently. Our design criteria led us to create two separate class hierarchies, one that supports the logical notion of windows, and another for capturing different implementations of windows. The Bridge pattern lets us maintain and enhance our logical windowing abstractions without touching window system-dependent code, and vice versa.</p>
<p class="calibre1"><a id="ch02sec1lev7"></a></p>
<h3 class="calibre2">2.7 User Operations</h3>
<p class="calibre1">Some of Lexi’s functionality is available through the document’s WYSIWYG representation. You enter and delete text, move the insertion point, and select ranges of text by pointing, clicking, and typing directly in the document. Other functionality is accessed indirectly through user operations in Lexi’s pull-down menus, buttons, and keyboard accelerators. The functionality includes operations for</p>
<p class="indenthangingB1">• creating a new document,</p>
<p class="indenthangingB1">• opening, saving, and printing an existing document,</p>
<p class="indenthangingB1"><a id="page_59"></a>• cutting selected text out of the document and pasting it back in,</p>
<p class="indenthangingB1">• changing the font and style of selected text,</p>
<p class="indenthangingB1">• changing the formatting of text, such as its alignment and justification,</p>
<p class="indenthangingB1">• quitting the application,</p>
<p class="indenthangingB1">• and on and on.</p>
<p class="calibre1">Lexi provides different user interfaces for these operations. But we don’t want to associate a particular user operation with a particular user interface, because we may want multiple user interfaces to the same operation (you can turn the page using either a page button or a menu operation, for example). We may also want to change the interface in the future.</p>
<p class="calibre1">Furthermore, these operations are implemented in many different classes. We as implementors want to access their functionality without creating a lot of dependencies between implementation and user interface classes. Otherwise we’ll end up with a tightly coupled implementation, which will be harder to understand, extend, and maintain.</p>
<p class="calibre1">To further complicate matters, we want Lexi to support undo and redo<sup class="calibre8"><a id="ch02fn_08"></a><a href="part0022.html#ch02fn08">8</a></sup> of most <em class="calibre7">but not all</em> its functionality. Specifically, we want to be able to undo document-modifying operations like delete, with which a user can destroy lots of data inadvertently. But we shouldn’t try to undo an operation like saving a drawing or quitting the application. These operations should have no effect on the undo process. We also don’t want an arbitrary limit on the number of levels of undo and redo.</p>
<p class="calibre1">It’s clear that support for user operations permeates the application. The challenge is to come up with a simple and extensible mechanism that satisfies all of these needs.</p>
<p class="calibre1"><a id="ch02sec2lev17"></a></p>
<h4 class="calibre15">Encapsulating a Request</h4>
<p class="calibre1">From our perspective as designers, a pull-down menu is just another kind of glyph that contains other glyphs. What distinguishes pull-down menus from other glyphs that have children is that most glyphs in menus do some work in response to an up-click.</p>
<p class="calibre1">Let’s assume that these work-performing glyphs are instances of a Glyph subclass called <strong class="calibre4">MenuItem</strong> and that they do their work in response to a request from a client.<sup class="calibre8"><a id="ch02fn_09"></a><a href="part0022.html#ch02fn09">9</a></sup> Carrying out the request might involve an operation on one object, or many operations on many objects, or something in between.</p>
<p class="calibre1">We could define a subclass of MenuItem for every user operation and then hard-code each subclass to carry out the request. But that’s not really right; we don’t need a subclass of MenuItem for each request any more than we need a subclass for each text <a id="page_60"></a>string in a pull-down menu. Moreover, this approach couples the request to a particular user interface, making it hard to fulfill the request through a different user interface.</p>
<p class="calibre1">To illustrate, suppose you could advance to the last page in the document both through a MenuItem in a pull-down menu <em class="calibre7">and</em> by pressing a page icon at the bottom of Lexi’s interface (which might be more convenient for short documents). If we associate the request with a MenuItem through inheritance, then we must do the same for the page icon and any other kind of widget that might issue such a request. That can give rise to a number of classes approaching the product of the number of widget types and the number of requests.</p>
<p class="calibre1">What’s missing is a mechanism that lets us parameterize menu items by the request they should fulfill. That way we avoid a proliferation of subclasses and allow for greater flexibility at run-time. We could parameterize MenuItem with a function to call, but that’s not a complete solution for at least three reasons:</p>
<p class="indenthangingN">1. It doesn’t address the undo/redo problem.</p>
<p class="indenthangingN">2. It’s hard to associate state with a function. For example, a function that changes the font needs to know <em class="calibre7">which</em> font.</p>
<p class="indenthangingN">3. Functions are hard to extend, and it’s hard to reuse parts of them.</p>
<p class="calibre1">These reasons suggest that we should parameterize MenuItems with an <em class="calibre7">object,</em> not a function. Then we can use inheritance to extend and reuse the request’s implementation. We also have a place to store state and implement undo/redo functionality. Here we have another example of encapsulating the concept that varies, in this case a request. We’ll encapsulate each request in a <strong class="calibre4">command</strong> object.</p>
<p class="calibre1"><a id="ch02sec2lev18"></a></p>
<h4 class="calibre15">Command Class and Subclasses</h4>
<p class="calibre1">First we define a <strong class="calibre4">Command</strong> abstract class to provide an interface for issuing a request. The basic interface consists of a single abstract operation called “Execute.” Subclasses of Command implement Execute in different ways to fulfill different requests. Some subclasses may delegate part or all of the work to other objects. Other subclasses may be in a position to fulfill the request entirely on their own (see <a href="part0011.html#ch02fig11">Figure 2.11</a>). To the requester, however, a Command object is a Command object—they are treated uniformly.</p>
<p class="caption"><a id="ch02fig11"></a>Figure 2.11: Partial Command class hierarchy</p>
<p class="image"><img src="../images/00039.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">Now MenuItem can store a Command object that encapsulates a request (<a href="part0011.html#ch02fig12">Figure 2.12</a>). We give each menu item object an instance of the Command subclass that’s suitable for that menu item, just as we specify the text to appear in the menu item. When a user chooses a particular menu item, the MenuItem simply calls Execute on its Command object to carry out the request. Note that buttons and other widgets can use commands in the same way menu items do.</p>
<p class="caption"><a id="page_61"></a><a id="ch02fig12"></a>Figure 2.12: MenuItem-Command relationship</p>
<p class="image"><img src="../images/00040.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1"><a id="ch02sec2lev19"></a></p>
<h4 class="calibre15"><a id="page_62"></a>Undoability</h4>
<p class="calibre1">Undo/redo is an important capability in interactive applications. To undo and redo commands, we add an Unexecute operation to Command’s interface. Unexecute reverses the effects of a preceding Execute operation using whatever undo information Execute stored. In the case of a FontCommand, for example, the Execute operation would store the range of text affected by the font change along with the original font(s). FontCommand’s Unexecute operation would restore the range of text to its original font(s).</p>
<p class="calibre1">Sometimes undoability must be determined at run-time. A request to change the font of a selection does nothing if the text already appears in that font. Suppose the user selects some text and then requests a spurious font change. What should be the result of a subsequent undo request? Should a meaningless change cause the undo request to do something equally meaningless? Probably not. If the user repeats the spurious font change several times, he shouldn’t have to perform exactly the same number of undo operations to get back to the last meaningful operation. If the net effect of executing a command was nothing, then there’s no need for a corresponding undo request.</p>
<p class="calibre1">So to determine if a command is undoable, we add an abstract Reversible operation to the Command interface. Reversible returns a Boolean value. Subclasses can redefine this operation to return true or false based on run-time criteria.</p>
<p class="calibre1"><a id="ch02sec2lev20"></a></p>
<h4 class="calibre15">Command History</h4>
<p class="calibre1">The final step in supporting arbitrary-level undo and redo is to define a <strong class="calibre4">command history,</strong> or list of commands that have been executed (or unexecuted, if some commands have been undone). Conceptually, the command history looks like this:</p>
<p class="image"><img src="../images/00041.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">Each circle represents a Command object. In this case the user has issued four commands. The leftmost command was issued first, followed by the second-leftmost, and so on until the most recently issued command, which is rightmost. The line marked “present” keeps track of the most recently executed (and unexecuted) command.</p>
<p class="calibre1">To undo the last command, we simply call Unexecute on the most recent command:</p>
<p class="image"><a id="page_63"></a><img src="../images/00042.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">After unexecuting the command, we move the “present” line one command to the left. If the user chooses undo again, the next-most recently issued command will be undone in the same way, and we’re left in the state depicted here:</p>
<p class="image"><img src="../images/00043.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">You can see that by simply repeating this procedure we get multiple levels of undo. The number of levels is limited only by the length of the command history.</p>
<p class="calibre1">To redo a command that’s just been undone, we do the same thing in reverse. Commands to the right of the present line are commands that may be redone in the future. To redo the last undone command, we call Execute on the command to the right of the present line:</p>
<p class="image"><img src="../images/00044.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">Then we advance the present line so that a subsequent redo will call redo on the following command in the future.</p>
<p class="image"><a id="page_64"></a><img src="../images/00045.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">Of course, if the subsequent operation is not another redo but an undo, then the command to the left of the present line will be undone. Thus the user can effectively go back and forth in time as needed to recover from errors.</p>
<p class="calibre1"><a id="ch02sec2lev21"></a></p>
<h4 class="calibre15">Command Pattern</h4>
<p class="calibre1">Lexi’s commands are an application of the Command (<a href="part0015.html#page_233">233</a>) pattern, which describes how to encapsulate a request. The Command pattern prescribes a uniform interface for issuing requests that lets you configure clients to handle different requests. The interface shields clients from the request’s implementation. A command may delegate all, part, or none of the request’s implementation to other objects. This is perfect for applications like Lexi that must provide centralized access to functionality scattered throughout the application. The pattern also discusses undo and redo mechanisms built on the basic Command interface.</p>
<p class="calibre1"><a id="ch02sec1lev8"></a></p>
<h3 class="calibre2">2.8 Spelling Checking and Hyphenation</h3>
<p class="calibre1">The last design problem involves textual analysis, specifically checking for misspellings and introducing hyphenation points where needed for good formatting.</p>
<p class="calibre1">The constraints here are similar to those we had for the formatting design problem in <a href="part0011.html#ch02sec1lev3">Section 2.3</a>. As was the case for linebreaking strategies, there’s more than one way to check spelling and compute hyphenation points. So here too we want to support multiple algorithms. A diverse set of algorithms can provide a choice of space/time/quality trade-offs. We should make it easy to add new algorithms as well.</p>
<p class="calibre1">We also want to avoid wiring this functionality into the document structure. This goal is even more important here than it was in the formatting case, because spelling checking and hyphenation are just two of potentially many kinds of analyses we may want Lexi to support. Inevitably we’ll want to expand Lexi’s analytical abilities over time. We might add searching, word counting, a calculation facility for adding up tabular values, grammar checking, and so forth. But we don’t want to change the Glyph class and all its subclasses every time we introduce new functionality of this sort.</p>
<p class="calibre1"><a id="page_65"></a>There are actually two pieces to this puzzle: (1) accessing the information to be analyzed, which we have scattered over the glyphs in the document structure, and (2) doing the analysis. We’ll look at these two pieces separately.</p>
<p class="calibre1"><a id="ch02sec2lev22"></a></p>
<h4 class="calibre15">Accessing Scattered Information</h4>
<p class="calibre1">Many kinds of analysis require examining the text character by character. The text we need to analyze is scattered throughout a hierarchical structure of glyph objects. To examine text in such a structure, we need an access mechanism that has knowledge about the data structures in which objects are stored. Some glyphs might store their children in linked lists, others might use arrays, and still others might use more esoteric data structures. Our access mechanism must be able to handle all of these possibilities.</p>
<p class="calibre1">An added complication is that different analyses access information in different ways. <em class="calibre7">Most</em> analyses will traverse the text from beginning to end. But some do the opposite—a reverse search, for example, needs to progress through the text backward rather than forward. Evaluating algebraic expressions could require an inorder traversal.</p>
<p class="calibre1">So our access mechanism must accommodate differing data structures, and we must support different kinds of traversals, such as preorder, postorder, and inorder.</p>
<p class="calibre1"><a id="ch02sec2lev23"></a></p>
<h4 class="calibre15">Encapsulating Access and Traversal</h4>
<p class="calibre1">Right now our glyph interface uses an integer index to let clients refer to children. Although that might be reasonable for glyph classes that store their children in an array, it may be inefficient for glyphs that use a linked list. An important role of the glyph abstraction is to hide the data structure in which children are stored. That way we can change the data structure a glyph class uses without affecting other classes.</p>
<p class="calibre1">Therefore only the glyph can know the data structure it uses. A corollary is that the glyph interface shouldn’t be biased toward one data structure or another. It shouldn’t be better suited to arrays than to linked lists, for example, as it is now.</p>
<p class="calibre1">We can solve this problem and support several different kinds of traversals at the same time. We can put multiple access and traversal capabilities directly in the glyph classes and provide a way to choose among them, perhaps by supplying an enumerated constant as a parameter. The classes pass this parameter around during a traversal to ensure they’re all doing the same kind of traversal. They have to pass around any information they’ve accumulated during traversal.</p>
<p class="calibre1">We might add the following abstract operations to Glyph’s interface to support this approach:</p>
<p class="programlisting"><a id="page_66"></a><img src="../images/00046.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">Operations <code class="calibre13">First</code>, <code class="calibre13">Next</code>, and <code class="calibre13">IsDone</code> control the traversal. <code class="calibre13">First</code> initializes the traversal. It takes the kind of traversal as a parameter of type <code class="calibre13">Traversal</code>, an enumerated constant with values such as <code class="calibre13">CHILDREN</code> (to traverse the glyph’s immediate children only), <code class="calibre13">PREORDER</code> (to traverse the entire structure in preorder), <code class="calibre13">POSTORDER</code>, and <code class="calibre13">INORDER</code>. <code class="calibre13">Next</code> advances to the next glyph in the traversal, and <code class="calibre13">IsDone</code> reports whether the traversal is over or not. <code class="calibre13">GetCurrent</code> replaces the <code class="calibre13">Child</code> operation; it accesses the current glyph in the traversal. <code class="calibre13">Insert</code> replaces the old operation; it inserts the given glyph at the current position.</p>
<p class="calibre1">An analysis would use the following C++ code to do a preorder traversal of a glyph structure rooted at <code class="calibre13">g</code>:</p>
<p class="programlisting"><img src="../images/00047.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">Notice that we’ve banished the integer index from the glyph interface. There’s no longer anything that biases the interface toward one kind of collection or another. We’ve also saved clients from having to implement common kinds of traversals themselves.</p>
<p class="calibre1">But this approach still has problems. For one thing, it can’t support new traversals without either extending the set of enumerated values or adding new operations. Say we wanted to have a variation on preorder traversal that automatically skips non-textual glyphs. We’d have to change the <code class="calibre13">Traversal</code> enumeration to include something like <code class="calibre13">TEXTUAL_PREORDER</code>.</p>
<p class="calibre1">We’d like to avoid changing existing declarations. Putting the traversal mechanism entirely in the Glyph class hierarchy makes it hard to modify or extend without changing lots of classes. It’s also difficult to reuse the mechanism to traverse other kinds of object structures. And we can’t have more than one traversal in progress on a structure.</p>
<p class="calibre1">Once again, a better solution is to encapsulate the concept that varies, in this case the access and traversal mechanisms. We can introduce a class of objects called <strong class="calibre4">iterators</strong> whose sole purpose is to define different sets of these mechanisms. We can use inheritance to let us access different data structures uniformly and support new kinds of traversals as well. And we won’t have to change glyph interfaces or disturb existing glyph implementations to do it.</p>
<p class="calibre1"><a id="ch02sec2lev24"></a></p>
<h4 class="calibre15"><a id="page_67"></a>Iterator Class and Subclasses</h4>
<p class="calibre1">We’ll use an abstract class called <strong class="calibre4">Iterator</strong> to define a general interface for access and traversal. Concrete subclasses like <strong class="calibre4">ArrayIterator</strong> and <strong class="calibre4">ListIterator</strong> implement the interface to provide access to arrays and lists, while <strong class="calibre4">PreorderIterator, PostorderIterator,</strong> and the like implement different traversals on specific structures. Each Iterator subclass has a reference to the structure it traverses. Subclass instances are initialized with this reference when they are created. <a href="part0011.html#ch02fig13">Figure 2.13</a> illustrates the Iterator class along with several subclasses. Notice that we’ve added a CreateIterator abstract operation to the Glyph class interface to support iterators.</p>
<p class="caption"><a id="ch02fig13"></a>Figure 2.13: Iterator class and subclasses</p>
<p class="image"><img src="../images/00048.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">The Iterator interface provides operations First, Next, and IsDone for controlling the traversal. The ListIterator class implements First to point to the first element in the list, and Next advances the iterator to the next item in the list. IsDone returns whether or not the list pointer points beyond the last element in the list. CurrentItem dereferences the iterator to return the glyph it points to. An <code class="calibre13">ArrayIterator</code> class would do similar things but on an array of glyphs.</p>
<p class="calibre1">Now we can access the children of a glyph structure without knowing its representation:</p>
<p class="programlisting"><a id="page_68"></a><img src="../images/00049.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">CreateIterator returns a NullIterator instance by default. A NullIterator is a degenerate iterator for glyphs that have no children, that is, leaf glyphs. NullIterator’s IsDone operation always returns true.</p>
<p class="calibre1">A glyph subclass that has children will override CreateIterator to return an instance of a different Iterator subclass. <em class="calibre7">Which</em> subclass depends on the structure that stores the children. If the Row subclass of Glyph stores its children in a list <code class="calibre13">_children</code>, then its CreateIterator operation would look like this:</p>
<p class="programlisting"><img src="../images/00050.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">Iterators for preorder and inorder traversals implement their traversals in terms of glyph-specific iterators. The iterators for these traversals are supplied the root glyph in the structure they traverse. They call CreateIterator on the glyphs in the structure and use a stack to keep track of the resulting iterators.</p>
<p class="calibre1">For example, class <code class="calibre13">PreorderIterator</code> gets the iterator from the root glyph, initializes it to point to its first element, and then pushes it onto the stack:</p>
<p class="programlisting"><img src="../images/00051.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1"><code class="calibre13">CurrentItem</code> would simply call <code class="calibre13">CurrentItem</code> on the iterator at the top of the stack:</p>
<p class="programlisting"><a id="page_69"></a><img src="../images/00052.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">The <code class="calibre13">Next</code> operation gets the top iterator on the stack and asks its current item to create an iterator, in an effort to descend the glyph structure as far as possible (this is a preorder traversal, after all). <code class="calibre13">Next</code> sets the new iterator to the first item in the traversal and pushes it on the stack. Then <code class="calibre13">Next</code> tests the latest iterator; if its <code class="calibre13">IsDone</code> operation returns true, then we’ve finished traversing the current subtree (or leaf) in the traversal. In that case, <code class="calibre13">Next</code> pops the top iterator off the stack and repeats this process until it finds the next incomplete traversal, if there is one; if not, then we have finished traversing the structure.</p>
<p class="programlisting"><img src="../images/00053.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">Notice how the Iterator class hierarchy lets us add new kinds of traversals without modifying glyph classes—we simply subclass <code class="calibre13">Iterator</code> and add a new traversal as we have with <code class="calibre13">PreorderIterator</code>. Glyph subclasses use the same interface to give clients access to their children without revealing the underlying data structure they use to store them. Because iterators store their own copy of the state of a traversal, we can carry on multiple traversals simultaneously, even on the same structure. And though our traversals have been over glyph structures in this example, there’s no reason we can’t parameterize a class like <code class="calibre13">PreorderIterator</code> by the type of object in the structure. We’d use templates to do that in C++. Then we can reuse the machinery in <code class="calibre13">PreorderIterator</code> to traverse other structures.</p>
<p class="calibre1"><a id="ch02sec2lev25"></a></p>
<h4 class="calibre15">Iterator Pattern</h4>
<p class="calibre1">The Iterator (<a href="part0015.html#page_257">257</a>) pattern captures these techniques for supporting access and traversal over object structures. It’s applicable not only to composite structures but to collections as well. It abstracts the traversal algorithm and shields clients from the internal structure <a id="page_70"></a>of the objects they traverse. The Iterator pattern illustrates once more how encapsulating the concept that varies helps us gain flexibility and reusability. Even so, the problem of iteration has surprising depth, and the Iterator pattern covers many more nuances and trade-offs than we’ve considered here.</p>
<p class="calibre1"><a id="ch02sec2lev26"></a></p>
<h4 class="calibre15">Traversal versus Traversal Actions</h4>
<p class="calibre1">Now that we have a way of traversing the glyph structure, we need to check the spelling and do the hyphenation. Both analyses involve accumulating information during the traversal.</p>
<p class="calibre1">First we have to decide where to put the responsibility for analysis. We could put it in the Iterator classes, thereby making analysis an integral part of traversal. But we get more flexibility and potential for reuse if we distinguish between the traversal and the actions performed during traversal. That’s because different analyses often require the same kind of traversal. Hence we can reuse the same set of iterators for different analyses. For example, preorder traversal is common to many analyses, including spelling checking, hyphenation, forward search, and word count.</p>
<p class="calibre1">So analysis and traversal should be separate. Where else can we put the responsibility for analysis? We know there are many kinds of analyses we might want to do. Each analysis will do different things at different points in the traversal. Some glyphs are more significant than others depending on the kind of analysis. If we’re checking spelling or hyphenating, we want to consider character glyphs and not graphical ones like lines and bitmapped images. If we’re making color separations, we’d want to consider visible glyphs and not invisible ones. Inevitably, different analyses will analyze different glyphs.</p>
<p class="calibre1">Therefore a given analysis must be able to distinguish different kinds of glyphs. An obvious approach is to put the analytical capability into the glyph classes themselves. For each analysis we can add one or more abstract operations to the Glyph class and have subclasses implement them in accordance with the role they play in the analysis.</p>
<p class="calibre1">But the trouble with that approach is that we’ll have to change every glyph class whenever we add a new kind of analysis. We can ease this problem in some cases: If only a few classes participate in the analysis, or if most classes do the analysis the same way, then we can supply a default implementation for the abstract operation in the Glyph class. The default operation would cover the common case. Thus we’d limit changes to just the Glyph class and those subclasses that deviate from the norm.</p>
<p class="calibre1">Yet even if a default implementation reduces the number of changes, an insidious problem remains: Glyph’s interface expands with every new analytical capability. Over time the analytical operations will start to obscure the basic Glyph interface. It becomes hard to see that a glyph’s main purpose is to define and structure objects that have appearance and shape—that interface gets lost in the noise.</p>
<p class="calibre1"><a id="ch02sec2lev27"></a></p>
<h4 class="calibre15"><a id="page_71"></a>Encapsulating the Analysis</h4>
<p class="calibre1">From all indications, we need to encapsulate the analysis in a separate object, much like we’ve done many times before. We could put the machinery for a given analysis into its own class. We could use an instance of this class in conjunction with an appropriate iterator. The iterator would “carry” the instance to each glyph in the structure. The analysis object could then perform a piece of the analysis at each point in the traversal. The analyzer accumulates information of interest (characters in this case) as the traversal proceeds:</p>
<p class="image"><img src="../images/00054.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">The fundamental question with this approach is how the analysis object distinguishes different kinds of glyphs without resorting to type tests or downcasts. We don’t want a <code class="calibre13">SpellingChecker</code> class to include (pseudo)code like</p>
<p class="programlisting"><img src="../images/00055.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1"><a id="page_72"></a>This code is pretty ugly. It relies on fairly esoteric capabilities like type-safe casts. It’s hard to extend as well. We’ll have to remember to change the body of this function whenever we change the Glyph class hierarchy. In fact, this is the kind of code that object-oriented languages were intended to eliminate.</p>
<p class="calibre1">We want to avoid such a brute-force approach, but how? Let’s consider what happens when we add the following abstract operation to the Glyph class:</p>
<p class="programlisting">void CheckMe(SpellingChecker&amp;)</p>
<p class="calibre1">We define <code class="calibre13">CheckMe</code> in every Glyph subclass as follows:</p>
<p class="programlisting"><img src="../images/00056.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">where <code class="calibre13">GlyphSubclass</code> would be replaced by the name of the glyph subclass. Note that when <code class="calibre13">CheckMe</code> is called, the specific Glyph subclass is known—after all, we’re in one of its operations. In turn, the <code class="calibre13">SpellingChecker</code> class interface includes an operation like <code class="calibre13">CheckGlyphSubclass</code> for every Glyph subclass<sup class="calibre8"><a id="ch02fn_10"></a><a href="part0022.html#ch02fn10">10</a></sup>:</p>
<p class="programlisting"><img src="../images/00057.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1"><code class="calibre13">SpellingChecker</code>’s checking operation for <code class="calibre13">Character</code> glyphs might look something like this:</p>
<p class="programlisting1"><a id="page_73"></a><img src="../images/00058.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">Notice we’ve defined a special <code class="calibre13">GetCharCode</code> operation on just the <code class="calibre13">Character</code> class. The spelling checker can deal with subclass-specific operations without resorting to type tests or casts—it lets us treat objects specially.</p>
<p class="calibre1"><code class="calibre13">CheckCharacter</code> accumulates alphabetic characters into the <code class="calibre13">_currentWord</code> buffer. When it encounters a nonalphabetic character, such as an underscore, it uses the <code class="calibre13">IsMisspelled</code> operation to check the spelling of the word in <code class="calibre13">_currentWord</code>.<sup class="calibre8"><a id="ch02fn_11"></a><a href="part0022.html#ch02fn11">11</a></sup> If the word is misspelled, then <code class="calibre13">CheckCharacter</code> adds the word to the list of misspelled words. Then it must clear out the <code class="calibre13">_currentWord</code> buffer to ready it for the next word. When the traversal is over, you can retrieve the list of misspelled words with the <code class="calibre13">GetMisspellings</code> operation.</p>
<p class="calibre1">Now we can traverse the glyph structure, calling <code class="calibre13">CheckMe</code> on each glyph with the spelling checker as an argument. This effectively identifies each glyph to the SpellingChecker and prompts the checker to do the next increment in the spelling check.</p>
<p class="programlisting"><img src="../images/00059.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1"><a id="page_74"></a>The following interaction diagram illustrates how <code class="calibre13">Character</code> glyphs and the <code class="calibre13">SpellingChecker</code> object work together:</p>
<p class="image"><img src="../images/00060.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">This approach works for finding spelling errors, but how does it help us support multiple kinds of analysis? It looks like we have to add an operation like <code class="calibre13">CheckMe(SpellingChecker&amp;)</code> to Glyph and its subclasses whenever we add a new kind of analysis. That’s true if we insist on an <em class="calibre7">independent</em> class for every analysis. But there’s no reason why we can’t give <em class="calibre7">all</em> analysis classes the same interface. Doing so lets us use them polymorphically. That means we can replace analysis-specific operations like <code class="calibre13">CheckMe(SpellingChecker&amp;)</code> with an analysis-independent operation that takes a more general parameter.</p>
<p class="calibre1"><a id="ch02sec2lev28"></a></p>
<h4 class="calibre15">Visitor Class and Subclasses</h4>
<p class="calibre1">We’ll use the term <strong class="calibre4">visitor</strong> to refer generally to classes of objects that “visit” other objects during a traversal and do something appropriate.<sup class="calibre8"><a id="ch02fn_12"></a><a href="part0022.html#ch02fn12">12</a></sup> In this case we can define a <code class="calibre13">Visitor</code> class that defines an abstract interface for visiting glyphs in a structure.</p>
<p class="programlisting"><a id="page_75"></a><img src="../images/00061.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1">Concrete subclasses of <code class="calibre13">Visitor</code> perform different analyses. For example, we could have a <code class="calibre13">SpellingCheckingVisitor</code> subclass for checking spelling, and a <code class="calibre13">HyphenationVisitor</code> subclass for hyphenation. <code class="calibre13">SpellingCheckingVisitor</code> would be implemented exactly as we implemented <code class="calibre13">SpellingChecker</code> above, except the operation names would reflect the more general <code class="calibre13">Visitor</code> interface. For example, <code class="calibre13">CheckCharacter</code> would be called <code class="calibre13">VisitCharacter</code>.</p>
<p class="calibre1">Since <code class="calibre13">CheckMe</code> isn’t appropriate for visitors that don’t check anything, we’ll give it a more general name: <code class="calibre13">Accept</code>. Its argument must also change to take a <code class="calibre13">Visitor&amp;</code>, reflecting the fact that it can accept any visitor. Now adding a new analysis requires just defining a new subclass of <code class="calibre13">Visitor</code>—we don’t have to touch any of the glyph classes. We support all future analyses by adding this one operation to <code class="calibre13">Glyph</code> and its subclasses.</p>
<p class="calibre1">We’ve already seen how spelling checking works. We use a similar approach in <code class="calibre13">HyphenationVisitor</code> to accumulate text. But once <code class="calibre13">HyphenationVisitor</code>’s <code class="calibre13">VisitCharacter</code> operation has assembled an entire word, it works a little differently. Instead of checking the word for misspelling, it applies a hyphenation algorithm to determine the potential hyphenation points in the word, if any. Then at each hyphenation point, it inserts a <strong class="calibre4">discretionary</strong> glyph into the composition. Discretionary glyphs are instances of <code class="calibre13">Discretionary</code>, a subclass of <code class="calibre13">Glyph</code>.</p>
<p class="calibre1">A discretionary glyph has one of two possible appearances depending on whether or not it is the last character on a line. If it’s the last character, then the discretionary looks like a hyphen; if it’s not at the end of a line, then the discretionary has no appearance whatsoever. The discretionary checks its parent (a Row object) to see if it is the last child. The discretionary makes this check whenever it’s called on to draw itself or calculate its boundaries. The formatting strategy treats discretionaries the same as whitespace, making them candidates for ending a line. The following diagram shows how an embedded discretionary can appear.</p>
<p class="image"><a id="page_76"></a><img src="../images/00062.jpeg" alt="image" class="calibre11"/></p>
<p class="calibre1"><a id="ch02sec2lev29"></a></p>
<h4 class="calibre15">Visitor Pattern</h4>
<p class="calibre1">What we’ve described here is an application of the Visitor (<a href="part0015.html#page_331">331</a>) pattern. The Visitor class and its subclasses described earlier are the key participants in the pattern. The Visitor pattern captures the technique we’ve used to allow an open-ended number of analyses of glyph structures without having to change the glyph classes themselves. Another nice feature of visitors is that they can be applied not just to composites like our glyph structures but to <em class="calibre7">any</em> object structure. That includes sets, lists, even directed-acyclic graphs. Furthermore, the classes that a visitor can visit needn’t be related to each other through a common parent class. That means visitors can work across class hierarchies.</p>
<p class="calibre1">An important question to ask yourself before applying the Visitor pattern is, Which class hierarchies change most often? The pattern is most suitable when you want to be able to do a variety of different things to objects that have a stable class structure. Adding a new kind of visitor requires no change to that class structure, which is especially important when the class structure is large. But whenever you add a subclass to the structure, you’ll also have to update all your visitor interfaces to include a <code class="calibre13">Visit...</code> operation for that subclass. In our example that means adding a new <code class="calibre13">Glyph</code> subclass called <code class="calibre13">Foo</code> will require changing <code class="calibre13">Visitor</code> and all its subclasses to include a <code class="calibre13">VisitFoo</code> operation. But given our design constraints, we’re much more likely to add a new kind of analysis to Lexi than a new kind of Glyph. So the Visitor pattern is well-suited to our needs.</p>
<p class="calibre1"><a id="ch02sec1lev9"></a></p>
<h3 class="calibre2">2.9 Summary</h3>
<p class="calibre1">We’ve applied eight different patterns to Lexi’s design:</p>
<p class="indenthangingN">1. Composite (<a href="part0014.html#page_163">163</a>) to represent the document’s physical structure,</p>
<p class="indenthangingN">2. Strategy (<a href="part0015.html#page_315">315</a>) to allow different formatting algorithms,</p>
<p class="indenthangingN"><a id="page_77"></a>3. Decorator (<a href="part0014.html#page_175">175</a>) for embellishing the user interface,</p>
<p class="indenthangingN">4. Abstract Factory (<a href="part0013.html#page_87">87</a>) for supporting multiple look-and-feel standards,</p>
<p class="indenthangingN">5. Bridge (<a href="part0014.html#page_151">151</a>) to allow multiple windowing platforms,</p>
<p class="indenthangingN">6. Command (<a href="part0015.html#page_233">233</a>) for undoable user operations,</p>
<p class="indenthangingN">7. Iterator (<a href="part0015.html#page_257">257</a>) for accessing and traversing object structures, and</p>
<p class="indenthangingN">8. Visitor (<a href="part0015.html#page_331">331</a>) for allowing an open-ended number of analytical capabilities without complicating the document structure’s implementation.</p>
<p class="calibre1">None of these design issues is limited to document editing applications like Lexi. Indeed, most nontrivial applications will have occasion to use many of these patterns, though perhaps to do different things. A financial analysis application might use Composite to define investment portfolios made up of subportfolios and accounts of different sorts. A compiler might use the Strategy pattern to allow different register allocation schemes for different target machines. Applications with a graphical user interface will probably apply at least Decorator and Command just as we have here.</p>
<p class="calibre1">While we’ve covered several major problems in Lexi’s design, there are lots of others we haven’t discussed. Then again, this book describes more than just the eight patterns we’ve used here. So as you study the remaining patterns, think about how you might use each one in Lexi. Or better yet, think about using them in your own designs!</p>
</body></html>
